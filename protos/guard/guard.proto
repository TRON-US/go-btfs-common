syntax = "proto3";

package guard;

// gogo plugin toggles
option (gogoproto.gogoproto_import) = true;
option (gogoproto.goproto_registration) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.messagename_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
// golang option
option go_package = "guard";
// java options
option java_multiple_files = true;
option java_outer_classname = "GuardProto";
option java_package = "io.btfs.guard";

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";

service GuardService {
  rpc SubmitFileStoreMeta(FileStoreStatus) returns (Result);
  rpc SendQuestions(FileChallengeQuestions) returns (Result); //used for renter send the questions to guard
  rpc CheckFileStoreMeta(CheckFileStoreMetaRequest) returns (FileStoreStatus); //reserved for other nodes to check contract status
}

message Log {
  google.protobuf.Timestamp change_time = 1;
  bytes change_originator = 2;
  bytes change = 3;
}

//below rpc is needed for host by concept, and it work as BTFS
// service HostService{
// 	rpc challenge(ProofOfReplicateChallenge) returns (ProofOfReplicateChallenge){} //used for receieve challenge question and return the answer, TBD seems can be removed as the BTFS has embed function , no need for service
// 	rpc cancelContract(Contract) returns (Result){}  //removed for phase 2
// }

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
//ContractMeta is the information which will not be changed after proposal
//Contract technically is the contract execution record, it contains the contractMeta and state information
message ContractMeta {
  //Contract proposed by renter, will not be changed after renter proposed
  bytes contract_id = 1; //one id which generated by renter, and will be check unique by escrow service
  bytes renter_address = 2; //renter's wallet address
  bytes host_address = 3; //host’s wallet address
  bytes shard_hash = 4; //shard’s hash
  int32 shard_index = 5; //shard’s sequence of the original file
  int64 shard_file_size = 6; //shard’s file size
  bytes file_hash = 7; //original file's hash, reserved point32 back to FileStoreMeta
  google.protobuf.Timestamp rent_start = 8 [(gogoproto.stdtime) = true]; //rent start time
  google.protobuf.Timestamp rent_end = 9 [(gogoproto.stdtime) = true]; //rent end time
  bytes guard_address = 10; //renter proposed guard's address
  bytes escrow_address = 11; //renter proposed escrow's address
  int64 price = 12; //the price which agreed by host and rental, on the first phase, it equal to the proposed_price
  int64 amount = 13; //the amount which agreed by host and rental, on the first phase, it should be equal file_size*duration*agreed_price
  int64 collateral_amount = 14;
  enum Schedule {
    MONTHLY = 0;
    QUARTERLY = 1;
    ANNUALLY = 2;
  }
  Schedule payout_schedule = 15; // schedule for payouts
  int32 num_payouts = 16; // numbers of payouts
}

message Contract {
  //the contract executor record, changed frequently after proposal
  ContractMeta contract = 1;
  enum ContractState {
    DRAFT = 0; //the contract was draft, but the escrow service did not received the money
    SIGNED = 1; // the escrow service received the money from renter, the contract was start.
    UPLOADED = 2; //the first challenge was done, which means the shard was in the host, all pending payouts can be issued now
    LOST = 3; // the challenge failed, the following payout should be hold or even stopped
    CANCELED = 4; //if the shard was rebuild after LOST, or after some days of NOQUESTION, it go to CANCELED status
    CLOSED = 5; // the all work in such contract was done
  }
  ContractState state = 2;
  bytes renter_signature = 3; //renter’s signature for the sub contract
  bytes host_signature = 4; //host’s signature from the sub contract
  google.protobuf.Timestamp escrow_signed_time = 5 [(gogoproto.stdtime) = true]; //contract signed time
  bytes escrow_signature = 6; //escrow's signature
  repeated Log change_log = 7; //TBD one field to store the contract change log, need to discuss whether need the field
  google.protobuf.Timestamp last_modify_time = 8 [(gogoproto.stdtime) = true];
  bytes guard_signature = 9;
}

message FileStoreMeta {
  //file store meta prepared by renter, will not changed after proposal
  bytes renter_address = 1; // buyer wallet address
  bytes file_hash = 2; // file’s hash
  int64 file_size = 3; // file’s size
  google.protobuf.Timestamp rent_start = 4 [(gogoproto.stdtime) = true]; //rent start time
  google.protobuf.Timestamp rent_end = 5 [(gogoproto.stdtime) = true]; //rent end time
  int32 check_frequency = 6; // shard check frequency in a year,  1 means check once per year, 0 means check 12 per year(1 per month)
  int64 guard_fee = 7; // reserve: the fee which guard will charge for supporting
  int64 escrow_fee = 8; //reserve: the fee which escrow will charge for supporting
  int32 shard_count = 9; //shard's count, by default is 30
  int32 minimum_shards = 10; //minimum count of shards which can recover the whole file, by default is 10
  int32 recover_threshold = 11; //reserved field, indicate the threshold for starting to recover
  bytes escrow_address = 12;
  bytes guard_address = 13;
}

message FileStoreStatus {
  FileStoreMeta file_store_meta = 1;
  enum MetaState {
    DRAFT = 0; //the proposal was submit by renter
    UPLOADING = 1; //all related contracts were signed, and renter is uploading shards and questions
    RUNNING = 2; //guard complete the first challenge for all shards
    PARTIAL_LOST = 3; //some shards were lost, but the whole file is safe
    LOST = 4; //some shards were lost and the whole file cannot be recovered now
    DONE = 5; //all contracts were done
  }
  MetaState state = 2;
  repeated Contract contracts = 3;
  bytes renter_signature = 4; //renter's signature for FileStoreMeta and all contractMeta
  google.protobuf.Timestamp guard_receive_time = 5 [(gogoproto.stdtime) = true]; //guard received time, which used to calculate the timeout for cancel
  repeated Log change_log = 6;
  google.protobuf.Timestamp curent_time = 7 [(gogoproto.stdtime) = true]; //the time for generate the status
  bytes guard_signature = 8;
}

message ChallengeQuestion {
  bytes shard_hash = 1; //shard hash
  bytes host_address = 2; //host's address
  int32 chunk_index = 3; //the chunk's index for calculation
  bytes random_nonce = 4; //the challenge questions's random nonce
  bytes expect_answer = 5; //the challenge expected answer
}

message ProofOfReplicateChallenge {
  ChallengeQuestion question = 1; //of course expect_answer should be clear before send to the host`
  google.protobuf.Timestamp challenge_time = 2 [(gogoproto.stdtime) = true]; //challenge time from guard
  bytes guard_address = 3; //guard's address
  bytes guard_signature = 4; //guard signed for the challenge
  bytes host_answer = 5; //challenge answer
  google.protobuf.Timestamp host_sign_time = 6 [(gogoproto.stdtime) = true]; //response time from host
  bytes host_signature = 7;
}

message FileChallengeQuestions {
  bytes file_hash = 1;
  repeated ShardChallengeQuestions shard_questions = 2;
}

message ShardChallengeQuestions {
  bytes file_hash = 1; //file's hash
  bytes shard_hash = 2;
  bytes preparer_address = 3; //challenge questions preparer's address, it is renter address at phase 1
  int32 question_count = 4;
  repeated ChallengeQuestion questions = 5;
  google.protobuf.Timestamp prepare_time = 6 [(gogoproto.stdtime) = true];
  bytes preparer_signature = 7;
}

message CheckFileStoreMetaRequest {
  bytes file_hash = 1;
  bytes renter_address = 2;
  bytes requester_address = 3;
  google.protobuf.Timestamp request_time = 4 [(gogoproto.stdtime) = true];
  bytes signature = 5; //requester signed
}

enum ResponseCode {
  SUCCESS = 0;
  SIGNATURE_FORMAT_ERROR = 1;
  COMPUTE_ADDRESS_ERROR = 2;
  OTHER_ERROR = 20;
}

message Result {
  ResponseCode code = 1;
  string message = 2;
  google.protobuf.Timestamp response_time = 3 [(gogoproto.stdtime) = true];
}
