syntax = "proto3";

package guard;

// gogo plugin toggles
option (gogoproto.gogoproto_import) = true;
option (gogoproto.goproto_registration) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.messagename_all) = true;
option (gogoproto.populate_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
// golang option
option go_package = "guard";
// java options
option java_multiple_files = true;
option java_outer_classname = "GuardProto";
option java_package = "io.btfs.guard";

import "github.com/tron-us/protobuf/gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";

service GuardService {
  rpc SubmitFileStoreMeta(FileStoreStatus) returns (Result);
  rpc SendQuestions(FileChallengeQuestions) returns (Result); //used for renter send the questions to guard
  rpc CheckFileStoreMeta(CheckFileStoreMetaRequest) returns (FileStoreStatus); //reserved for other nodes to check contract status
  rpc ReadyForChallenge(ReadyForChallengeRequest) returns (Result);
  rpc ForceRepair(ForceRepairRequest) returns (Result);
}

message Log {
  google.protobuf.Timestamp change_time = 1 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
  string originator_pid = 2;
  string change = 3;
}

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
//ContractMeta is the information which will not be changed after proposal
//Contract technically is the contract execution record, it contains the contractMeta and state information
message ContractMeta {
  //Contract proposed by renter, will not be changed after renter proposed
  string contract_id = 1; //one id which generated by renter, and will be check unique by escrow service
  string renter_pid = 2; //renter's wallet peerId
  string host_pid = 3; //host’s wallet peerId
  string shard_hash = 4; //shard’s hash
  int32 shard_index = 5; //shard’s sequence of the original file
  int64 shard_file_size = 6; //shard’s file size
  string file_hash = 7; //original file's hash, reserved point32 back to FileStoreMeta
  google.protobuf.Timestamp rent_start = 8 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //rent start time
  google.protobuf.Timestamp rent_end = 9 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //rent end time
  string guard_pid = 10; //renter proposed guard's peerId
  string escrow_pid = 11; //renter proposed escrow's peerId
  int64 price = 12; //the price which agreed by host and rental, on the first phase, it equal to the proposed_price
  int64 amount = 13; //the amount which agreed by host and rental, on the first phase, it should be equal file_size*duration*agreed_price
  int64 collateral_amount = 14;
  enum Schedule {
    MONTHLY = 0;
    QUARTERLY = 1;
    ANNUALLY = 2;
  }
  Schedule payout_schedule = 15; // schedule for payouts
  int32 num_payouts = 16; // numbers of payouts
}

message Contract {
  //the contract executor record, changed frequently after proposal
  ContractMeta contract = 1 [
    (gogoproto.embed) = true,
    (gogoproto.nullable) = false
  ];
  enum ContractState {
    DRAFT = 0; //the contract was draft, but the escrow service did not received the money
    SIGNED = 1; // the escrow service received the money from renter, the contract was start.
    UPLOADED = 2; //the first challenge was done, which means the shard was in the host, all pending payouts can be issued now
    LOST = 3; // the challenge failed, the following payout should be hold or even stopped
    CANCELED = 4; //if the shard was rebuild after LOST, or after some days of NO QUESTION, it go to CANCELED status
    CLOSED = 5; // the all work in such contract was done
    RENEWED = 6; // the contract got renewed
    OBSOLETE = 7; //the contract was replaced with some other contract after it was canceled or renewed
    WARN = 8; //the shard is in warn status
  }
  ContractState state = 2;
  bytes renter_signature = 3; //renter’s signature for the sub contract
  bytes host_signature = 4; //host’s signature from the sub contract
  google.protobuf.Timestamp escrow_signed_time = 5 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //contract signed time
  bytes escrow_signature = 6; //escrow's signature
  repeated Log change_log = 7; //TBD one field to store the contract change log, need to discuss whether need the field
  google.protobuf.Timestamp last_modify_time = 8 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
  bytes guard_signature = 9;
  string preparer_pid = 10; //while the contract got renewed, some stakeholder take renter's place to prepare such contract
  bytes preparer_signature = 11;
  google.protobuf.Timestamp last_success_challenge_time = 12 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
  google.protobuf.Timestamp last_challenge_time = 13 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
  int32 challenge_times = 14; //total challenge times till now
  int32 challenge_warn_times = 15; //record times of timeout response after last success challenge time
  int32 challenge_success_times = 16; //record times of success after the contract was put into the warn status
}

message FileStoreMeta {
  //file store meta prepared by renter, will not changed after proposal
  string renter_pid = 1; // buyer wallet peerId
  string file_hash = 2; // file’s hash
  int64 file_size = 3; // file’s size
  google.protobuf.Timestamp rent_start = 4 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //rent start time
  google.protobuf.Timestamp rent_end = 5 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //rent end time
  int32 check_frequency = 6; //reserve: shard check frequency in days, 1 means check once per day
  int64 guard_fee = 7; // reserve: the fee which guard will charge for supporting
  int64 escrow_fee = 8; //reserve: the fee which escrow will charge for supporting
  int32 shard_count = 9; //shard's count, by default is 30
  int32 minimum_shards = 10; //minimum count of shards which can recover the whole file, by default is 10
  int32 recover_threshold = 11; //reserved field, indicate the threshold for starting to recover
  string escrow_pid = 12;
  string guard_pid = 13;
  int32 warn_challenge_times_limit = 14; //reserve: indicate how many times warn challenge will take the contract to cancel status, renter cannot set it now, use 7 as default
  int32 success_challenge_times_limit = 15; //reserve: indicate how many times success will take the contract from warn status back to right, renter cannot set it now, use 1 as default
  int32 check_frequency_warn = 16; //reserve: check frequency in days while in warn status, renter cannot set it now, use 1 as default
}

message FileStoreStatus {
  FileStoreMeta file_store_meta = 1 [
    (gogoproto.embed) = true,
    (gogoproto.nullable) = false
  ];
  enum MetaState {
    DRAFT = 0; //the proposal was submit by renter
    UPLOADING = 1; //all related contracts were signed, and renter is uploading shards and questions
    RUNNING = 2; //guard complete the first challenge for all shards
    PARTIAL_LOST = 3; //some shards were lost, but the whole file is safe
    LOST = 4; //some shards were lost and the whole file cannot be recovered now
    DONE = 5; //all contracts were done
    CANCELED = 6; //reserved for the cancel contract
  }
  MetaState state = 2;
  repeated Contract contracts = 3;
  bytes renter_signature = 4; //rental's signature for the first full file status with contracts
  google.protobuf.Timestamp guard_receive_time = 5 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //guard received time, which used to calculate the timeout for cancel
  repeated Log change_log = 6;
  google.protobuf.Timestamp current_time = 7 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //the time for generate the status
  bytes guard_signature = 8;
  enum RentalState {
    NEW = 0; //the rental was first initialized
    PARTIAL_NEW = 1; //part of the file status was new, indicate that some contracts were rebuild
    EXPIRED = 2; //the file rental was expired, indicate that all shards can be removed from host
    RENEW = 3; //the contract got renewed
  }
  RentalState rental_state = 9;
  string preparer_pid = 10; //the stakeholder who prepared such file, if the file is NEW state, the preparer is rental
  bytes preparer_signature = 11; //preparer's signature for FileStoreMeta
}

message ChallengeQuestion {
  string shard_hash = 1; //shard hash
  string host_pid = 2; //host's peerId
  int32 chunk_index = 3; //the chunk's index for calculation
  string nonce = 4; //the challenge questions's random nonce
  string expect_answer = 5; //the challenge expected answer
}

message ProofOfReplicateChallenge {
  ChallengeQuestion question = 1 [
    (gogoproto.embed) = true,
    (gogoproto.nullable) = false
  ]; //of course expect_answer should be clear before send to the host`
  google.protobuf.Timestamp challenge_time = 2 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //challenge time from guard
  string guard_pid = 3; //guard's peerId
  bytes guard_signature = 4; //guard signed for the challenge
  string host_answer = 5; //challenge answer
  google.protobuf.Timestamp host_sign_time = 6 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ]; //response time from host
  bytes host_signature = 7;
}

message FileChallengeQuestions {
  string file_hash = 1;
  repeated ShardChallengeQuestions shard_questions = 2;
}

message ShardChallengeQuestions {
  string file_hash = 1; //file's hash
  string shard_hash = 2;
  string preparer_pid = 3; //challenge questions preparer's peerId, it is renter peerId at phase 1
  int32 question_count = 4;
  repeated ChallengeQuestion questions = 5;
  google.protobuf.Timestamp prepare_time = 6 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
  bytes preparer_signature = 7;
}

message CheckFileStoreMetaRequest {
  string file_hash = 1;
  string renter_pid = 2;
  string requester_pid = 3;
  google.protobuf.Timestamp request_time = 4 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
  bytes signature = 5; //requester signed
}

message ReadyForChallengeRequest {
  string renter_pid = 1;
  string file_hash = 2;
  string shard_hash = 3;
  string contract_id = 4;
  string host_pid = 5;
  google.protobuf.Timestamp prepare_time = 6 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
  bytes signature = 7;
}

message ForceRepairRequest {
  string renter_pid = 1;
  string file_hash = 2;
  string auth_pid = 3; //the peer who was authorized to issue force repair request
  bytes signature = 4;
}

enum ResponseCode {
  SUCCESS = 0;
  SIGNATURE_FORMAT_ERROR = 1;
  COMPUTE_ADDRESS_ERROR = 2;
  OTHER_ERROR = 20;
}

message Result {
  ResponseCode code = 1;
  string message = 2;
  google.protobuf.Timestamp response_time = 3 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];
}
