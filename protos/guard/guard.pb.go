// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protos/guard/guard.proto

package guard

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/tron-us/protobuf/gogoproto"
	proto "github.com/tron-us/protobuf/proto"
	github_com_tron_us_protobuf_types "github.com/tron-us/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ResponseCode int32

const (
	ResponseCode_SUCCESS                ResponseCode = 0
	ResponseCode_SIGNATURE_FORMAT_ERROR ResponseCode = 1
	ResponseCode_COMPUTE_ADDRESS_ERROR  ResponseCode = 2
	ResponseCode_OTHER_ERROR            ResponseCode = 20
)

var ResponseCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "SIGNATURE_FORMAT_ERROR",
	2:  "COMPUTE_ADDRESS_ERROR",
	20: "OTHER_ERROR",
}

var ResponseCode_value = map[string]int32{
	"SUCCESS":                0,
	"SIGNATURE_FORMAT_ERROR": 1,
	"COMPUTE_ADDRESS_ERROR":  2,
	"OTHER_ERROR":            20,
}

func (x ResponseCode) String() string {
	return proto.EnumName(ResponseCode_name, int32(x))
}

func (ResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}

type ContractMeta_Schedule int32

const (
	ContractMeta_MONTHLY   ContractMeta_Schedule = 0
	ContractMeta_QUARTERLY ContractMeta_Schedule = 1
	ContractMeta_ANNUALLY  ContractMeta_Schedule = 2
)

var ContractMeta_Schedule_name = map[int32]string{
	0: "MONTHLY",
	1: "QUARTERLY",
	2: "ANNUALLY",
}

var ContractMeta_Schedule_value = map[string]int32{
	"MONTHLY":   0,
	"QUARTERLY": 1,
	"ANNUALLY":  2,
}

func (x ContractMeta_Schedule) String() string {
	return proto.EnumName(ContractMeta_Schedule_name, int32(x))
}

func (ContractMeta_Schedule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{1, 0}
}

type Contract_ContractState int32

const (
	Contract_DRAFT    Contract_ContractState = 0
	Contract_SIGNED   Contract_ContractState = 1
	Contract_UPLOADED Contract_ContractState = 2
	Contract_LOST     Contract_ContractState = 3
	Contract_CANCELED Contract_ContractState = 4
	Contract_CLOSED   Contract_ContractState = 5
	Contract_RENEWED  Contract_ContractState = 6
	Contract_OBSOLETE Contract_ContractState = 7
	Contract_WARN     Contract_ContractState = 8
)

var Contract_ContractState_name = map[int32]string{
	0: "DRAFT",
	1: "SIGNED",
	2: "UPLOADED",
	3: "LOST",
	4: "CANCELED",
	5: "CLOSED",
	6: "RENEWED",
	7: "OBSOLETE",
	8: "WARN",
}

var Contract_ContractState_value = map[string]int32{
	"DRAFT":    0,
	"SIGNED":   1,
	"UPLOADED": 2,
	"LOST":     3,
	"CANCELED": 4,
	"CLOSED":   5,
	"RENEWED":  6,
	"OBSOLETE": 7,
	"WARN":     8,
}

func (x Contract_ContractState) String() string {
	return proto.EnumName(Contract_ContractState_name, int32(x))
}

func (Contract_ContractState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{2, 0}
}

type FileStoreStatus_MetaState int32

const (
	FileStoreStatus_DRAFT        FileStoreStatus_MetaState = 0
	FileStoreStatus_UPLOADING    FileStoreStatus_MetaState = 1
	FileStoreStatus_RUNNING      FileStoreStatus_MetaState = 2
	FileStoreStatus_PARTIAL_LOST FileStoreStatus_MetaState = 3
	FileStoreStatus_LOST         FileStoreStatus_MetaState = 4
	FileStoreStatus_DONE         FileStoreStatus_MetaState = 5
	FileStoreStatus_CANCELED     FileStoreStatus_MetaState = 6
)

var FileStoreStatus_MetaState_name = map[int32]string{
	0: "DRAFT",
	1: "UPLOADING",
	2: "RUNNING",
	3: "PARTIAL_LOST",
	4: "LOST",
	5: "DONE",
	6: "CANCELED",
}

var FileStoreStatus_MetaState_value = map[string]int32{
	"DRAFT":        0,
	"UPLOADING":    1,
	"RUNNING":      2,
	"PARTIAL_LOST": 3,
	"LOST":         4,
	"DONE":         5,
	"CANCELED":     6,
}

func (x FileStoreStatus_MetaState) String() string {
	return proto.EnumName(FileStoreStatus_MetaState_name, int32(x))
}

func (FileStoreStatus_MetaState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{4, 0}
}

type FileStoreStatus_RentalState int32

const (
	FileStoreStatus_NEW         FileStoreStatus_RentalState = 0
	FileStoreStatus_PARTIAL_NEW FileStoreStatus_RentalState = 1
	FileStoreStatus_EXPIRED     FileStoreStatus_RentalState = 2
	FileStoreStatus_RENEW       FileStoreStatus_RentalState = 3
)

var FileStoreStatus_RentalState_name = map[int32]string{
	0: "NEW",
	1: "PARTIAL_NEW",
	2: "EXPIRED",
	3: "RENEW",
}

var FileStoreStatus_RentalState_value = map[string]int32{
	"NEW":         0,
	"PARTIAL_NEW": 1,
	"EXPIRED":     2,
	"RENEW":       3,
}

func (x FileStoreStatus_RentalState) String() string {
	return proto.EnumName(FileStoreStatus_RentalState_name, int32(x))
}

func (FileStoreStatus_RentalState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{4, 1}
}

type ListHostContractsRequest_SelectState int32

const (
	ListHostContractsRequest_ALL    ListHostContractsRequest_SelectState = 0
	ListHostContractsRequest_ACTIVE ListHostContractsRequest_SelectState = 1
	ListHostContractsRequest_CLOSED ListHostContractsRequest_SelectState = 2
)

var ListHostContractsRequest_SelectState_name = map[int32]string{
	0: "ALL",
	1: "ACTIVE",
	2: "CLOSED",
}

var ListHostContractsRequest_SelectState_value = map[string]int32{
	"ALL":    0,
	"ACTIVE": 1,
	"CLOSED": 2,
}

func (x ListHostContractsRequest_SelectState) String() string {
	return proto.EnumName(ListHostContractsRequest_SelectState_name, int32(x))
}

func (ListHostContractsRequest_SelectState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{10, 0}
}

type Log struct {
	ChangeTime           time.Time `protobuf:"bytes,1,opt,name=change_time,json=changeTime,proto3,stdtime" json:"change_time" pg:"change_time"`
	OriginatorPid        string    `protobuf:"bytes,2,opt,name=originator_pid,json=originatorPid,proto3" json:"originator_pid,omitempty" pg:"originator_pid"`
	Change               string    `protobuf:"bytes,3,opt,name=change,proto3" json:"change,omitempty" pg:"change"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

func (m *Log) GetChangeTime() time.Time {
	if m != nil {
		return m.ChangeTime
	}
	return time.Time{}
}

func (m *Log) GetOriginatorPid() string {
	if m != nil {
		return m.OriginatorPid
	}
	return ""
}

func (m *Log) GetChange() string {
	if m != nil {
		return m.Change
	}
	return ""
}

func (*Log) XXX_MessageName() string {
	return "guard.Log"
}

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
//ContractMeta is the information which will not be changed after proposal
//Contract technically is the contract execution record, it contains the contractMeta and state information
type ContractMeta struct {
	//Contract proposed by renter, will not be changed after renter proposed
	ContractId           string                `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty" pg:"contract_id"`
	RenterPid            string                `protobuf:"bytes,2,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	HostPid              string                `protobuf:"bytes,3,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ShardHash            string                `protobuf:"bytes,4,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	ShardIndex           int32                 `protobuf:"varint,5,opt,name=shard_index,json=shardIndex,proto3" json:"shard_index,omitempty" pg:"shard_index"`
	ShardFileSize        int64                 `protobuf:"varint,6,opt,name=shard_file_size,json=shardFileSize,proto3" json:"shard_file_size,omitempty" pg:"shard_file_size"`
	FileHash             string                `protobuf:"bytes,7,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RentStart            time.Time             `protobuf:"bytes,8,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start" pg:"rent_start"`
	RentEnd              time.Time             `protobuf:"bytes,9,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end" pg:"rent_end"`
	GuardPid             string                `protobuf:"bytes,10,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	EscrowPid            string                `protobuf:"bytes,11,opt,name=escrow_pid,json=escrowPid,proto3" json:"escrow_pid,omitempty" pg:"escrow_pid"`
	Price                int64                 `protobuf:"varint,12,opt,name=price,proto3" json:"price,omitempty" pg:"price"`
	Amount               int64                 `protobuf:"varint,13,opt,name=amount,proto3" json:"amount,omitempty" pg:"amount"`
	CollateralAmount     int64                 `protobuf:"varint,14,opt,name=collateral_amount,json=collateralAmount,proto3" json:"collateral_amount,omitempty" pg:"collateral_amount"`
	PayoutSchedule       ContractMeta_Schedule `protobuf:"varint,15,opt,name=payout_schedule,json=payoutSchedule,proto3,enum=guard.ContractMeta_Schedule" json:"payout_schedule,omitempty" pg:"payout_schedule"`
	NumPayouts           int32                 `protobuf:"varint,16,opt,name=num_payouts,json=numPayouts,proto3" json:"num_payouts,omitempty" pg:"num_payouts"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-" pg:"-"`
	XXX_unrecognized     []byte                `json:"-" pg:"-"`
	XXX_sizecache        int32                 `json:"-" pg:"-"`
}

func (m *ContractMeta) Reset()         { *m = ContractMeta{} }
func (m *ContractMeta) String() string { return proto.CompactTextString(m) }
func (*ContractMeta) ProtoMessage()    {}
func (*ContractMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{1}
}
func (m *ContractMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractMeta.Merge(m, src)
}
func (m *ContractMeta) XXX_Size() int {
	return m.Size()
}
func (m *ContractMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ContractMeta proto.InternalMessageInfo

func (m *ContractMeta) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *ContractMeta) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ContractMeta) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ContractMeta) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ContractMeta) GetShardIndex() int32 {
	if m != nil {
		return m.ShardIndex
	}
	return 0
}

func (m *ContractMeta) GetShardFileSize() int64 {
	if m != nil {
		return m.ShardFileSize
	}
	return 0
}

func (m *ContractMeta) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ContractMeta) GetRentStart() time.Time {
	if m != nil {
		return m.RentStart
	}
	return time.Time{}
}

func (m *ContractMeta) GetRentEnd() time.Time {
	if m != nil {
		return m.RentEnd
	}
	return time.Time{}
}

func (m *ContractMeta) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ContractMeta) GetEscrowPid() string {
	if m != nil {
		return m.EscrowPid
	}
	return ""
}

func (m *ContractMeta) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ContractMeta) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ContractMeta) GetCollateralAmount() int64 {
	if m != nil {
		return m.CollateralAmount
	}
	return 0
}

func (m *ContractMeta) GetPayoutSchedule() ContractMeta_Schedule {
	if m != nil {
		return m.PayoutSchedule
	}
	return ContractMeta_MONTHLY
}

func (m *ContractMeta) GetNumPayouts() int32 {
	if m != nil {
		return m.NumPayouts
	}
	return 0
}

func (*ContractMeta) XXX_MessageName() string {
	return "guard.ContractMeta"
}

type Contract struct {
	//the contract executor record, changed frequently after proposal
	ContractMeta             `protobuf:"bytes,1,opt,name=contract,proto3,embedded=contract" json:"contract" pg:"contract"`
	State                    Contract_ContractState `protobuf:"varint,2,opt,name=state,proto3,enum=guard.Contract_ContractState" json:"state,omitempty" pg:"state"`
	RenterSignature          []byte                 `protobuf:"bytes,3,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty" pg:"renter_signature"`
	HostSignature            []byte                 `protobuf:"bytes,4,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty" pg:"host_signature"`
	EscrowSignedTime         time.Time              `protobuf:"bytes,5,opt,name=escrow_signed_time,json=escrowSignedTime,proto3,stdtime" json:"escrow_signed_time" pg:"escrow_signed_time"`
	EscrowSignature          []byte                 `protobuf:"bytes,6,opt,name=escrow_signature,json=escrowSignature,proto3" json:"escrow_signature,omitempty" pg:"escrow_signature"`
	ChangeLog                []*Log                 `protobuf:"bytes,7,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty" pg:"change_log"`
	LastModifyTime           time.Time              `protobuf:"bytes,8,opt,name=last_modify_time,json=lastModifyTime,proto3,stdtime" json:"last_modify_time" pg:"last_modify_time"`
	GuardSignature           []byte                 `protobuf:"bytes,9,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	PreparerPid              string                 `protobuf:"bytes,10,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	PreparerSignature        []byte                 `protobuf:"bytes,11,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	LastSuccessChallengeTime time.Time              `protobuf:"bytes,12,opt,name=last_success_challenge_time,json=lastSuccessChallengeTime,proto3,stdtime" json:"last_success_challenge_time" pg:"last_success_challenge_time"`
	LastChallengeTime        time.Time              `protobuf:"bytes,13,opt,name=last_challenge_time,json=lastChallengeTime,proto3,stdtime" json:"last_challenge_time" pg:"last_challenge_time"`
	ChallengeTimes           int32                  `protobuf:"varint,14,opt,name=challenge_times,json=challengeTimes,proto3" json:"challenge_times,omitempty" pg:"challenge_times"`
	ChallengeWarnTimes       int32                  `protobuf:"varint,15,opt,name=challenge_warn_times,json=challengeWarnTimes,proto3" json:"challenge_warn_times,omitempty" pg:"challenge_warn_times"`
	ChallengeSuccessTimes    int32                  `protobuf:"varint,16,opt,name=challenge_success_times,json=challengeSuccessTimes,proto3" json:"challenge_success_times,omitempty" pg:"challenge_success_times"`
	XXX_NoUnkeyedLiteral     struct{}               `json:"-" pg:"-"`
	XXX_unrecognized         []byte                 `json:"-" pg:"-"`
	XXX_sizecache            int32                  `json:"-" pg:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{2}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetState() Contract_ContractState {
	if m != nil {
		return m.State
	}
	return Contract_DRAFT
}

func (m *Contract) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *Contract) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (m *Contract) GetEscrowSignedTime() time.Time {
	if m != nil {
		return m.EscrowSignedTime
	}
	return time.Time{}
}

func (m *Contract) GetEscrowSignature() []byte {
	if m != nil {
		return m.EscrowSignature
	}
	return nil
}

func (m *Contract) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *Contract) GetLastModifyTime() time.Time {
	if m != nil {
		return m.LastModifyTime
	}
	return time.Time{}
}

func (m *Contract) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *Contract) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *Contract) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (m *Contract) GetLastSuccessChallengeTime() time.Time {
	if m != nil {
		return m.LastSuccessChallengeTime
	}
	return time.Time{}
}

func (m *Contract) GetLastChallengeTime() time.Time {
	if m != nil {
		return m.LastChallengeTime
	}
	return time.Time{}
}

func (m *Contract) GetChallengeTimes() int32 {
	if m != nil {
		return m.ChallengeTimes
	}
	return 0
}

func (m *Contract) GetChallengeWarnTimes() int32 {
	if m != nil {
		return m.ChallengeWarnTimes
	}
	return 0
}

func (m *Contract) GetChallengeSuccessTimes() int32 {
	if m != nil {
		return m.ChallengeSuccessTimes
	}
	return 0
}

func (*Contract) XXX_MessageName() string {
	return "guard.Contract"
}

type FileStoreMeta struct {
	//file store meta prepared by renter, will not changed after proposal
	RenterPid                  string    `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash                   string    `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	FileSize                   int64     `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty" pg:"file_size"`
	RentStart                  time.Time `protobuf:"bytes,4,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start" pg:"rent_start"`
	RentEnd                    time.Time `protobuf:"bytes,5,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end" pg:"rent_end"`
	CheckFrequency             int32     `protobuf:"varint,6,opt,name=check_frequency,json=checkFrequency,proto3" json:"check_frequency,omitempty" pg:"check_frequency"`
	GuardFee                   int64     `protobuf:"varint,7,opt,name=guard_fee,json=guardFee,proto3" json:"guard_fee,omitempty" pg:"guard_fee"`
	EscrowFee                  int64     `protobuf:"varint,8,opt,name=escrow_fee,json=escrowFee,proto3" json:"escrow_fee,omitempty" pg:"escrow_fee"`
	ShardCount                 int32     `protobuf:"varint,9,opt,name=shard_count,json=shardCount,proto3" json:"shard_count,omitempty" pg:"shard_count"`
	MinimumShards              int32     `protobuf:"varint,10,opt,name=minimum_shards,json=minimumShards,proto3" json:"minimum_shards,omitempty" pg:"minimum_shards"`
	RecoverThreshold           int32     `protobuf:"varint,11,opt,name=recover_threshold,json=recoverThreshold,proto3" json:"recover_threshold,omitempty" pg:"recover_threshold"`
	EscrowPid                  string    `protobuf:"bytes,12,opt,name=escrow_pid,json=escrowPid,proto3" json:"escrow_pid,omitempty" pg:"escrow_pid"`
	GuardPid                   string    `protobuf:"bytes,13,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	WarnChallengeTimesLimit    int32     `protobuf:"varint,14,opt,name=warn_challenge_times_limit,json=warnChallengeTimesLimit,proto3" json:"warn_challenge_times_limit,omitempty" pg:"warn_challenge_times_limit"`
	SuccessChallengeTimesLimit int32     `protobuf:"varint,15,opt,name=success_challenge_times_limit,json=successChallengeTimesLimit,proto3" json:"success_challenge_times_limit,omitempty" pg:"success_challenge_times_limit"`
	CheckFrequencyWarn         int32     `protobuf:"varint,16,opt,name=check_frequency_warn,json=checkFrequencyWarn,proto3" json:"check_frequency_warn,omitempty" pg:"check_frequency_warn"`
	XXX_NoUnkeyedLiteral       struct{}  `json:"-" pg:"-"`
	XXX_unrecognized           []byte    `json:"-" pg:"-"`
	XXX_sizecache              int32     `json:"-" pg:"-"`
}

func (m *FileStoreMeta) Reset()         { *m = FileStoreMeta{} }
func (m *FileStoreMeta) String() string { return proto.CompactTextString(m) }
func (*FileStoreMeta) ProtoMessage()    {}
func (*FileStoreMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{3}
}
func (m *FileStoreMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreMeta.Merge(m, src)
}
func (m *FileStoreMeta) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreMeta proto.InternalMessageInfo

func (m *FileStoreMeta) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *FileStoreMeta) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *FileStoreMeta) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *FileStoreMeta) GetRentStart() time.Time {
	if m != nil {
		return m.RentStart
	}
	return time.Time{}
}

func (m *FileStoreMeta) GetRentEnd() time.Time {
	if m != nil {
		return m.RentEnd
	}
	return time.Time{}
}

func (m *FileStoreMeta) GetCheckFrequency() int32 {
	if m != nil {
		return m.CheckFrequency
	}
	return 0
}

func (m *FileStoreMeta) GetGuardFee() int64 {
	if m != nil {
		return m.GuardFee
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowFee() int64 {
	if m != nil {
		return m.EscrowFee
	}
	return 0
}

func (m *FileStoreMeta) GetShardCount() int32 {
	if m != nil {
		return m.ShardCount
	}
	return 0
}

func (m *FileStoreMeta) GetMinimumShards() int32 {
	if m != nil {
		return m.MinimumShards
	}
	return 0
}

func (m *FileStoreMeta) GetRecoverThreshold() int32 {
	if m != nil {
		return m.RecoverThreshold
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowPid() string {
	if m != nil {
		return m.EscrowPid
	}
	return ""
}

func (m *FileStoreMeta) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *FileStoreMeta) GetWarnChallengeTimesLimit() int32 {
	if m != nil {
		return m.WarnChallengeTimesLimit
	}
	return 0
}

func (m *FileStoreMeta) GetSuccessChallengeTimesLimit() int32 {
	if m != nil {
		return m.SuccessChallengeTimesLimit
	}
	return 0
}

func (m *FileStoreMeta) GetCheckFrequencyWarn() int32 {
	if m != nil {
		return m.CheckFrequencyWarn
	}
	return 0
}

func (*FileStoreMeta) XXX_MessageName() string {
	return "guard.FileStoreMeta"
}

type FileStoreStatus struct {
	FileStoreMeta        `protobuf:"bytes,1,opt,name=file_store_meta,json=fileStoreMeta,proto3,embedded=file_store_meta" json:"file_store_meta" pg:"file_store_meta"`
	State                FileStoreStatus_MetaState   `protobuf:"varint,2,opt,name=state,proto3,enum=guard.FileStoreStatus_MetaState" json:"state,omitempty" pg:"state"`
	Contracts            []*Contract                 `protobuf:"bytes,3,rep,name=contracts,proto3" json:"contracts,omitempty" pg:"contracts"`
	RenterSignature      []byte                      `protobuf:"bytes,4,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty" pg:"renter_signature"`
	GuardReceiveTime     time.Time                   `protobuf:"bytes,5,opt,name=guard_receive_time,json=guardReceiveTime,proto3,stdtime" json:"guard_receive_time" pg:"guard_receive_time"`
	ChangeLog            []*Log                      `protobuf:"bytes,6,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty" pg:"change_log"`
	CurrentTime          time.Time                   `protobuf:"bytes,7,opt,name=current_time,json=currentTime,proto3,stdtime" json:"current_time" pg:"current_time"`
	GuardSignature       []byte                      `protobuf:"bytes,8,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	RentalState          FileStoreStatus_RentalState `protobuf:"varint,9,opt,name=rental_state,json=rentalState,proto3,enum=guard.FileStoreStatus_RentalState" json:"rental_state,omitempty" pg:"rental_state"`
	PreparerPid          string                      `protobuf:"bytes,10,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	PreparerSignature    []byte                      `protobuf:"bytes,11,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-" pg:"-"`
	XXX_unrecognized     []byte                      `json:"-" pg:"-"`
	XXX_sizecache        int32                       `json:"-" pg:"-"`
}

func (m *FileStoreStatus) Reset()         { *m = FileStoreStatus{} }
func (m *FileStoreStatus) String() string { return proto.CompactTextString(m) }
func (*FileStoreStatus) ProtoMessage()    {}
func (*FileStoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{4}
}
func (m *FileStoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreStatus.Merge(m, src)
}
func (m *FileStoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreStatus proto.InternalMessageInfo

func (m *FileStoreStatus) GetState() FileStoreStatus_MetaState {
	if m != nil {
		return m.State
	}
	return FileStoreStatus_DRAFT
}

func (m *FileStoreStatus) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func (m *FileStoreStatus) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *FileStoreStatus) GetGuardReceiveTime() time.Time {
	if m != nil {
		return m.GuardReceiveTime
	}
	return time.Time{}
}

func (m *FileStoreStatus) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *FileStoreStatus) GetCurrentTime() time.Time {
	if m != nil {
		return m.CurrentTime
	}
	return time.Time{}
}

func (m *FileStoreStatus) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *FileStoreStatus) GetRentalState() FileStoreStatus_RentalState {
	if m != nil {
		return m.RentalState
	}
	return FileStoreStatus_NEW
}

func (m *FileStoreStatus) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *FileStoreStatus) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (*FileStoreStatus) XXX_MessageName() string {
	return "guard.FileStoreStatus"
}

type ChallengeQuestion struct {
	ShardHash            string   `protobuf:"bytes,1,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	HostPid              string   `protobuf:"bytes,2,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ChunkIndex           int32    `protobuf:"varint,3,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty" pg:"chunk_index"`
	Nonce                string   `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty" pg:"nonce"`
	ExpectAnswer         string   `protobuf:"bytes,5,opt,name=expect_answer,json=expectAnswer,proto3" json:"expect_answer,omitempty" pg:"expect_answer"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *ChallengeQuestion) Reset()         { *m = ChallengeQuestion{} }
func (m *ChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*ChallengeQuestion) ProtoMessage()    {}
func (*ChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{5}
}
func (m *ChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeQuestion.Merge(m, src)
}
func (m *ChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeQuestion proto.InternalMessageInfo

func (m *ChallengeQuestion) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ChallengeQuestion) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ChallengeQuestion) GetChunkIndex() int32 {
	if m != nil {
		return m.ChunkIndex
	}
	return 0
}

func (m *ChallengeQuestion) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *ChallengeQuestion) GetExpectAnswer() string {
	if m != nil {
		return m.ExpectAnswer
	}
	return ""
}

func (*ChallengeQuestion) XXX_MessageName() string {
	return "guard.ChallengeQuestion"
}

type ProofOfReplicateChallenge struct {
	ChallengeQuestion    `protobuf:"bytes,1,opt,name=question,proto3,embedded=question" json:"question" pg:"question"`
	ChallengeTime        time.Time `protobuf:"bytes,2,opt,name=challenge_time,json=challengeTime,proto3,stdtime" json:"challenge_time" pg:"challenge_time"`
	GuardPid             string    `protobuf:"bytes,3,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	GuardSignature       []byte    `protobuf:"bytes,4,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	HostAnswer           string    `protobuf:"bytes,5,opt,name=host_answer,json=hostAnswer,proto3" json:"host_answer,omitempty" pg:"host_answer"`
	HostSignTime         time.Time `protobuf:"bytes,6,opt,name=host_sign_time,json=hostSignTime,proto3,stdtime" json:"host_sign_time" pg:"host_sign_time"`
	HostSignature        []byte    `protobuf:"bytes,7,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty" pg:"host_signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *ProofOfReplicateChallenge) Reset()         { *m = ProofOfReplicateChallenge{} }
func (m *ProofOfReplicateChallenge) String() string { return proto.CompactTextString(m) }
func (*ProofOfReplicateChallenge) ProtoMessage()    {}
func (*ProofOfReplicateChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{6}
}
func (m *ProofOfReplicateChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofOfReplicateChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofOfReplicateChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofOfReplicateChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofOfReplicateChallenge.Merge(m, src)
}
func (m *ProofOfReplicateChallenge) XXX_Size() int {
	return m.Size()
}
func (m *ProofOfReplicateChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofOfReplicateChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_ProofOfReplicateChallenge proto.InternalMessageInfo

func (m *ProofOfReplicateChallenge) GetChallengeTime() time.Time {
	if m != nil {
		return m.ChallengeTime
	}
	return time.Time{}
}

func (m *ProofOfReplicateChallenge) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ProofOfReplicateChallenge) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetHostAnswer() string {
	if m != nil {
		return m.HostAnswer
	}
	return ""
}

func (m *ProofOfReplicateChallenge) GetHostSignTime() time.Time {
	if m != nil {
		return m.HostSignTime
	}
	return time.Time{}
}

func (m *ProofOfReplicateChallenge) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (*ProofOfReplicateChallenge) XXX_MessageName() string {
	return "guard.ProofOfReplicateChallenge"
}

type FileChallengeQuestions struct {
	FileHash             string                     `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardQuestions       []*ShardChallengeQuestions `protobuf:"bytes,2,rep,name=shard_questions,json=shardQuestions,proto3" json:"shard_questions,omitempty" pg:"shard_questions"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" pg:"-"`
	XXX_unrecognized     []byte                     `json:"-" pg:"-"`
	XXX_sizecache        int32                      `json:"-" pg:"-"`
}

func (m *FileChallengeQuestions) Reset()         { *m = FileChallengeQuestions{} }
func (m *FileChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*FileChallengeQuestions) ProtoMessage()    {}
func (*FileChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{7}
}
func (m *FileChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChallengeQuestions.Merge(m, src)
}
func (m *FileChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *FileChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_FileChallengeQuestions proto.InternalMessageInfo

func (m *FileChallengeQuestions) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *FileChallengeQuestions) GetShardQuestions() []*ShardChallengeQuestions {
	if m != nil {
		return m.ShardQuestions
	}
	return nil
}

func (*FileChallengeQuestions) XXX_MessageName() string {
	return "guard.FileChallengeQuestions"
}

type ShardChallengeQuestions struct {
	FileHash             string               `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string               `protobuf:"bytes,2,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	PreparerPid          string               `protobuf:"bytes,3,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	QuestionCount        int32                `protobuf:"varint,4,opt,name=question_count,json=questionCount,proto3" json:"question_count,omitempty" pg:"question_count"`
	Questions            []*ChallengeQuestion `protobuf:"bytes,5,rep,name=questions,proto3" json:"questions,omitempty" pg:"questions"`
	PrepareTime          time.Time            `protobuf:"bytes,6,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	PreparerSignature    []byte               `protobuf:"bytes,7,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-" pg:"-"`
	XXX_unrecognized     []byte               `json:"-" pg:"-"`
	XXX_sizecache        int32                `json:"-" pg:"-"`
}

func (m *ShardChallengeQuestions) Reset()         { *m = ShardChallengeQuestions{} }
func (m *ShardChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*ShardChallengeQuestions) ProtoMessage()    {}
func (*ShardChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{8}
}
func (m *ShardChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardChallengeQuestions.Merge(m, src)
}
func (m *ShardChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *ShardChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_ShardChallengeQuestions proto.InternalMessageInfo

func (m *ShardChallengeQuestions) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ShardChallengeQuestions) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ShardChallengeQuestions) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *ShardChallengeQuestions) GetQuestionCount() int32 {
	if m != nil {
		return m.QuestionCount
	}
	return 0
}

func (m *ShardChallengeQuestions) GetQuestions() []*ChallengeQuestion {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *ShardChallengeQuestions) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *ShardChallengeQuestions) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (*ShardChallengeQuestions) XXX_MessageName() string {
	return "guard.ShardChallengeQuestions"
}

type CheckFileStoreMetaRequest struct {
	FileHash             string    `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RenterPid            string    `protobuf:"bytes,2,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	RequesterPid         string    `protobuf:"bytes,3,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestTime          time.Time `protobuf:"bytes,4,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time" pg:"request_time"`
	Signature            []byte    `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *CheckFileStoreMetaRequest) Reset()         { *m = CheckFileStoreMetaRequest{} }
func (m *CheckFileStoreMetaRequest) String() string { return proto.CompactTextString(m) }
func (*CheckFileStoreMetaRequest) ProtoMessage()    {}
func (*CheckFileStoreMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{9}
}
func (m *CheckFileStoreMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckFileStoreMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckFileStoreMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckFileStoreMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckFileStoreMetaRequest.Merge(m, src)
}
func (m *CheckFileStoreMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckFileStoreMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckFileStoreMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckFileStoreMetaRequest proto.InternalMessageInfo

func (m *CheckFileStoreMetaRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *CheckFileStoreMetaRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*CheckFileStoreMetaRequest) XXX_MessageName() string {
	return "guard.CheckFileStoreMetaRequest"
}

type ListHostContractsRequest struct {
	HostPid              string                               `protobuf:"bytes,1,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	RequesterPid         string                               `protobuf:"bytes,2,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestPageSize      int32                                `protobuf:"varint,3,opt,name=request_page_size,json=requestPageSize,proto3" json:"request_page_size,omitempty" pg:"request_page_size"`
	RequestPageIndex     int32                                `protobuf:"varint,4,opt,name=request_page_index,json=requestPageIndex,proto3" json:"request_page_index,omitempty" pg:"request_page_index"`
	LastModifyTimeSince  time.Time                            `protobuf:"bytes,5,opt,name=last_modify_time_since,json=lastModifyTimeSince,proto3,stdtime" json:"last_modify_time_since" pg:"last_modify_time_since"`
	LastModifyTimeTo     time.Time                            `protobuf:"bytes,6,opt,name=last_modify_time_to,json=lastModifyTimeTo,proto3,stdtime" json:"last_modify_time_to" pg:"last_modify_time_to"`
	State                ListHostContractsRequest_SelectState `protobuf:"varint,7,opt,name=state,proto3,enum=guard.ListHostContractsRequest_SelectState" json:"state,omitempty" pg:"state"`
	RequestTime          time.Time                            `protobuf:"bytes,8,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time" pg:"request_time"`
	Signature            []byte                               `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-" pg:"-"`
	XXX_unrecognized     []byte                               `json:"-" pg:"-"`
	XXX_sizecache        int32                                `json:"-" pg:"-"`
}

func (m *ListHostContractsRequest) Reset()         { *m = ListHostContractsRequest{} }
func (m *ListHostContractsRequest) String() string { return proto.CompactTextString(m) }
func (*ListHostContractsRequest) ProtoMessage()    {}
func (*ListHostContractsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{10}
}
func (m *ListHostContractsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHostContractsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHostContractsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHostContractsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHostContractsRequest.Merge(m, src)
}
func (m *ListHostContractsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListHostContractsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHostContractsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListHostContractsRequest proto.InternalMessageInfo

func (m *ListHostContractsRequest) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ListHostContractsRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *ListHostContractsRequest) GetRequestPageSize() int32 {
	if m != nil {
		return m.RequestPageSize
	}
	return 0
}

func (m *ListHostContractsRequest) GetRequestPageIndex() int32 {
	if m != nil {
		return m.RequestPageIndex
	}
	return 0
}

func (m *ListHostContractsRequest) GetLastModifyTimeSince() time.Time {
	if m != nil {
		return m.LastModifyTimeSince
	}
	return time.Time{}
}

func (m *ListHostContractsRequest) GetLastModifyTimeTo() time.Time {
	if m != nil {
		return m.LastModifyTimeTo
	}
	return time.Time{}
}

func (m *ListHostContractsRequest) GetState() ListHostContractsRequest_SelectState {
	if m != nil {
		return m.State
	}
	return ListHostContractsRequest_ALL
}

func (m *ListHostContractsRequest) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *ListHostContractsRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ListHostContractsRequest) XXX_MessageName() string {
	return "guard.ListHostContractsRequest"
}

type ContractsList struct {
	Request              *ListHostContractsRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty" pg:"request"`
	GenerateTime         time.Time                 `protobuf:"bytes,2,opt,name=generate_time,json=generateTime,proto3,stdtime" json:"generate_time" pg:"generate_time"`
	Contracts            []*Contract               `protobuf:"bytes,3,rep,name=contracts,proto3" json:"contracts,omitempty" pg:"contracts"`
	Count                int32                     `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty" pg:"count"`
	Signature            []byte                    `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-" pg:"-"`
	XXX_unrecognized     []byte                    `json:"-" pg:"-"`
	XXX_sizecache        int32                     `json:"-" pg:"-"`
}

func (m *ContractsList) Reset()         { *m = ContractsList{} }
func (m *ContractsList) String() string { return proto.CompactTextString(m) }
func (*ContractsList) ProtoMessage()    {}
func (*ContractsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{11}
}
func (m *ContractsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractsList.Merge(m, src)
}
func (m *ContractsList) XXX_Size() int {
	return m.Size()
}
func (m *ContractsList) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractsList.DiscardUnknown(m)
}

var xxx_messageInfo_ContractsList proto.InternalMessageInfo

func (m *ContractsList) GetRequest() *ListHostContractsRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ContractsList) GetGenerateTime() time.Time {
	if m != nil {
		return m.GenerateTime
	}
	return time.Time{}
}

func (m *ContractsList) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func (m *ContractsList) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ContractsList) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ContractsList) XXX_MessageName() string {
	return "guard.ContractsList"
}

type ReadyForChallengeRequest struct {
	RenterPid            string    `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash             string    `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string    `protobuf:"bytes,3,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	ContractId           string    `protobuf:"bytes,4,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty" pg:"contract_id"`
	HostPid              string    `protobuf:"bytes,5,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	PrepareTime          time.Time `protobuf:"bytes,6,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	Signature            []byte    `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *ReadyForChallengeRequest) Reset()         { *m = ReadyForChallengeRequest{} }
func (m *ReadyForChallengeRequest) String() string { return proto.CompactTextString(m) }
func (*ReadyForChallengeRequest) ProtoMessage()    {}
func (*ReadyForChallengeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{12}
}
func (m *ReadyForChallengeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadyForChallengeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadyForChallengeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadyForChallengeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadyForChallengeRequest.Merge(m, src)
}
func (m *ReadyForChallengeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadyForChallengeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadyForChallengeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadyForChallengeRequest proto.InternalMessageInfo

func (m *ReadyForChallengeRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *ReadyForChallengeRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ReadyForChallengeRequest) XXX_MessageName() string {
	return "guard.ReadyForChallengeRequest"
}

type ForceRepairRequest struct {
	RenterPid            string   `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash             string   `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	AuthPid              string   `protobuf:"bytes,3,opt,name=auth_pid,json=authPid,proto3" json:"auth_pid,omitempty" pg:"auth_pid"`
	Signature            []byte   `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *ForceRepairRequest) Reset()         { *m = ForceRepairRequest{} }
func (m *ForceRepairRequest) String() string { return proto.CompactTextString(m) }
func (*ForceRepairRequest) ProtoMessage()    {}
func (*ForceRepairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{13}
}
func (m *ForceRepairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForceRepairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForceRepairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForceRepairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForceRepairRequest.Merge(m, src)
}
func (m *ForceRepairRequest) XXX_Size() int {
	return m.Size()
}
func (m *ForceRepairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ForceRepairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ForceRepairRequest proto.InternalMessageInfo

func (m *ForceRepairRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ForceRepairRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ForceRepairRequest) GetAuthPid() string {
	if m != nil {
		return m.AuthPid
	}
	return ""
}

func (m *ForceRepairRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ForceRepairRequest) XXX_MessageName() string {
	return "guard.ForceRepairRequest"
}

type Result struct {
	Code                 ResponseCode `protobuf:"varint,1,opt,name=code,proto3,enum=guard.ResponseCode" json:"code,omitempty" pg:"code"`
	Message              string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty" pg:"message"`
	ResponseTime         time.Time    `protobuf:"bytes,3,opt,name=response_time,json=responseTime,proto3,stdtime" json:"response_time" pg:"response_time"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-" pg:"-"`
	XXX_unrecognized     []byte       `json:"-" pg:"-"`
	XXX_sizecache        int32        `json:"-" pg:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{14}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetCode() ResponseCode {
	if m != nil {
		return m.Code
	}
	return ResponseCode_SUCCESS
}

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Result) GetResponseTime() time.Time {
	if m != nil {
		return m.ResponseTime
	}
	return time.Time{}
}

func (*Result) XXX_MessageName() string {
	return "guard.Result"
}
func init() {
	proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	golang_proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	golang_proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	golang_proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	golang_proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	proto.RegisterEnum("guard.FileStoreStatus_RentalState", FileStoreStatus_RentalState_name, FileStoreStatus_RentalState_value)
	golang_proto.RegisterEnum("guard.FileStoreStatus_RentalState", FileStoreStatus_RentalState_name, FileStoreStatus_RentalState_value)
	proto.RegisterEnum("guard.ListHostContractsRequest_SelectState", ListHostContractsRequest_SelectState_name, ListHostContractsRequest_SelectState_value)
	golang_proto.RegisterEnum("guard.ListHostContractsRequest_SelectState", ListHostContractsRequest_SelectState_name, ListHostContractsRequest_SelectState_value)
	proto.RegisterType((*Log)(nil), "guard.Log")
	golang_proto.RegisterType((*Log)(nil), "guard.Log")
	proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	golang_proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	proto.RegisterType((*Contract)(nil), "guard.Contract")
	golang_proto.RegisterType((*Contract)(nil), "guard.Contract")
	proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	golang_proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	golang_proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	golang_proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	golang_proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	golang_proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	golang_proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	golang_proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	proto.RegisterType((*ListHostContractsRequest)(nil), "guard.ListHostContractsRequest")
	golang_proto.RegisterType((*ListHostContractsRequest)(nil), "guard.ListHostContractsRequest")
	proto.RegisterType((*ContractsList)(nil), "guard.ContractsList")
	golang_proto.RegisterType((*ContractsList)(nil), "guard.ContractsList")
	proto.RegisterType((*ReadyForChallengeRequest)(nil), "guard.ReadyForChallengeRequest")
	golang_proto.RegisterType((*ReadyForChallengeRequest)(nil), "guard.ReadyForChallengeRequest")
	proto.RegisterType((*ForceRepairRequest)(nil), "guard.ForceRepairRequest")
	golang_proto.RegisterType((*ForceRepairRequest)(nil), "guard.ForceRepairRequest")
	proto.RegisterType((*Result)(nil), "guard.Result")
	golang_proto.RegisterType((*Result)(nil), "guard.Result")
}

func init() { proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }
func init() { golang_proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }

var fileDescriptor_ad5b6eccdc9ebee8 = []byte{
	// 2295 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0xcd, 0x73, 0xdb, 0xc6,
	0x15, 0x37, 0x48, 0x82, 0x1f, 0x8f, 0x5f, 0xd0, 0x5a, 0x71, 0x20, 0x25, 0x96, 0x54, 0x66, 0xd2,
	0xc8, 0x49, 0x4d, 0x67, 0x9c, 0x8e, 0x3b, 0x99, 0x7e, 0xa4, 0x34, 0x05, 0xc9, 0x4a, 0x69, 0x52,
	0x59, 0x50, 0x75, 0xdd, 0x0b, 0x06, 0x06, 0x57, 0x24, 0xc6, 0x24, 0xc0, 0x00, 0xa0, 0x1d, 0x67,
	0xa6, 0x3d, 0xf4, 0xd6, 0xe9, 0x4c, 0xa7, 0xa7, 0x4e, 0x4e, 0xbd, 0xf5, 0x90, 0x7f, 0xa0, 0xc7,
	0x4e, 0x8f, 0xbe, 0x35, 0x7f, 0x41, 0xda, 0xda, 0xff, 0x44, 0x8e, 0x9d, 0x7d, 0x0b, 0x10, 0x1f,
	0xa2, 0xec, 0xa1, 0xe3, 0x8b, 0x86, 0xfb, 0xbe, 0xf6, 0xed, 0xdb, 0xf7, 0xde, 0xef, 0x2d, 0x04,
	0xea, 0xdc, 0x73, 0x03, 0xd7, 0xbf, 0x31, 0x5e, 0x98, 0xde, 0x48, 0xfc, 0x6d, 0x23, 0x89, 0xc8,
	0xb8, 0xd8, 0xfe, 0x70, 0x6c, 0x07, 0x93, 0xc5, 0x83, 0xb6, 0xe5, 0xce, 0x6e, 0x04, 0x9e, 0xeb,
	0x5c, 0x5f, 0xf8, 0x37, 0x50, 0xe0, 0xc1, 0xe2, 0xec, 0xc6, 0xd8, 0x1d, 0xbb, 0xb8, 0xc0, 0x5f,
	0x42, 0x71, 0x7b, 0x77, 0xec, 0xba, 0xe3, 0x29, 0x8b, 0xa5, 0x02, 0x7b, 0xc6, 0xfc, 0xc0, 0x9c,
	0xcd, 0x85, 0x40, 0xeb, 0x4f, 0x12, 0xe4, 0x7b, 0xee, 0x98, 0x68, 0x50, 0xb5, 0x26, 0xa6, 0x33,
	0x66, 0x06, 0x97, 0x50, 0xa5, 0x3d, 0x69, 0xbf, 0x7a, 0x73, 0xbb, 0x2d, 0xd4, 0xdb, 0x91, 0x7a,
	0x7b, 0x18, 0xa9, 0xdf, 0x2e, 0x3f, 0xfd, 0x76, 0xf7, 0xd2, 0x5f, 0xfe, 0xb3, 0x2b, 0x51, 0x10,
	0x8a, 0x9c, 0x45, 0xde, 0x85, 0x86, 0xeb, 0xd9, 0x63, 0xdb, 0x31, 0x03, 0xd7, 0x33, 0xe6, 0xf6,
	0x48, 0xcd, 0xed, 0x49, 0xfb, 0x15, 0x5a, 0x8f, 0xa9, 0x27, 0xf6, 0x88, 0x5c, 0x81, 0xa2, 0x50,
	0x52, 0xf3, 0xc8, 0x0e, 0x57, 0xad, 0xaf, 0x65, 0xa8, 0x75, 0x5d, 0x27, 0xf0, 0x4c, 0x2b, 0xb8,
	0xcb, 0x02, 0x93, 0xec, 0x42, 0xd5, 0x0a, 0xd7, 0x86, 0x3d, 0x42, 0xb7, 0x2a, 0x14, 0x22, 0xd2,
	0xf1, 0x88, 0x5c, 0x05, 0xf0, 0x98, 0x13, 0xb0, 0xe4, 0x66, 0x15, 0x41, 0xe1, 0x1b, 0x6d, 0x41,
	0x79, 0xe2, 0xfa, 0x01, 0x32, 0xc5, 0x56, 0x25, 0xbe, 0xe6, 0xac, 0xab, 0x00, 0xfe, 0xc4, 0xf4,
	0x46, 0xc6, 0xc4, 0xf4, 0x27, 0x6a, 0x41, 0x68, 0x22, 0xe5, 0x8e, 0xe9, 0x4f, 0xf8, 0xce, 0x82,
	0x6d, 0x3b, 0x23, 0xf6, 0x85, 0x2a, 0xef, 0x49, 0xfb, 0x32, 0x15, 0x1a, 0xc7, 0x9c, 0x42, 0x7e,
	0x08, 0x4d, 0x21, 0x70, 0x66, 0x4f, 0x99, 0xe1, 0xdb, 0x5f, 0x32, 0xb5, 0xb8, 0x27, 0xed, 0xe7,
	0x69, 0x1d, 0xc9, 0x87, 0xf6, 0x94, 0xe9, 0xf6, 0x97, 0x8c, 0xbc, 0x05, 0x15, 0x94, 0xc0, 0x6d,
	0x4a, 0xb8, 0x4d, 0x99, 0x13, 0x70, 0x97, 0xae, 0x70, 0xdf, 0xf0, 0x03, 0xd3, 0x0b, 0xd4, 0xf2,
	0x1a, 0x51, 0xc7, 0x43, 0xea, 0x5c, 0x8d, 0x7c, 0x02, 0x65, 0x34, 0xc2, 0x9c, 0x91, 0x5a, 0x59,
	0xc3, 0x44, 0x89, 0x6b, 0x69, 0xce, 0x88, 0xbb, 0x88, 0x09, 0x86, 0x61, 0x02, 0xe1, 0x22, 0x12,
	0xc2, 0x38, 0x31, 0xdf, 0xf2, 0xdc, 0xc7, 0xc8, 0xad, 0x8a, 0x38, 0x09, 0x0a, 0x67, 0x6f, 0x82,
	0x3c, 0xf7, 0x6c, 0x8b, 0xa9, 0x35, 0x3c, 0xbc, 0x58, 0xf0, 0x0b, 0x36, 0x67, 0xee, 0xc2, 0x09,
	0xd4, 0x3a, 0x92, 0xc3, 0x15, 0xf9, 0x00, 0x36, 0x2c, 0x77, 0x3a, 0x35, 0x03, 0xe6, 0x99, 0x53,
	0x23, 0x14, 0x69, 0xa0, 0x88, 0x12, 0x33, 0x3a, 0x42, 0x58, 0x83, 0xe6, 0xdc, 0x7c, 0xe2, 0x2e,
	0x02, 0xc3, 0xb7, 0x26, 0x6c, 0xb4, 0x98, 0x32, 0xb5, 0xb9, 0x27, 0xed, 0x37, 0x6e, 0xbe, 0xdd,
	0x16, 0xc5, 0x91, 0x4c, 0x95, 0xb6, 0x1e, 0xca, 0xd0, 0x86, 0x50, 0x8a, 0xd6, 0xfc, 0x26, 0x9d,
	0xc5, 0xcc, 0x10, 0x54, 0x5f, 0x55, 0xc4, 0x4d, 0x3a, 0x8b, 0xd9, 0x89, 0xa0, 0xb4, 0x7e, 0x0c,
	0xe5, 0xa5, 0x70, 0x15, 0x4a, 0x77, 0x07, 0xfd, 0xe1, 0x9d, 0xde, 0x7d, 0xe5, 0x12, 0xa9, 0x43,
	0xe5, 0xb3, 0xd3, 0x0e, 0x1d, 0x6a, 0xb4, 0x77, 0x5f, 0x91, 0x48, 0x0d, 0xca, 0x9d, 0x7e, 0xff,
	0xb4, 0xd3, 0xeb, 0xdd, 0x57, 0x72, 0xad, 0x3f, 0x97, 0xa1, 0x1c, 0x39, 0x40, 0x3e, 0x86, 0x72,
	0x94, 0x94, 0x61, 0xed, 0x5c, 0x5e, 0xe1, 0xa3, 0x88, 0xfd, 0x37, 0xdf, 0xee, 0x4a, 0x74, 0x29,
	0x4e, 0x3e, 0x02, 0xd9, 0x0f, 0xcc, 0x80, 0x61, 0xf2, 0x36, 0x6e, 0x5e, 0xcd, 0xe8, 0x2d, 0x7f,
	0xe8, 0x5c, 0x88, 0x0a, 0x59, 0x72, 0x0d, 0x94, 0x30, 0xed, 0x7d, 0x7b, 0xec, 0x98, 0xc1, 0xc2,
	0x13, 0xa5, 0x54, 0xa3, 0x4d, 0x41, 0xd7, 0x23, 0x32, 0x2f, 0x49, 0x2c, 0x81, 0x58, 0xb0, 0x80,
	0x82, 0x75, 0x4e, 0x8d, 0xc5, 0x28, 0x90, 0xf0, 0x9a, 0xb9, 0x20, 0x1b, 0x89, 0x3e, 0x20, 0xaf,
	0x91, 0x4e, 0x8a, 0xd0, 0xd7, 0x51, 0x1d, 0xbb, 0xc1, 0x35, 0x50, 0x12, 0x36, 0xc5, 0xe6, 0x45,
	0xe1, 0x65, 0x2c, 0x2b, 0xb6, 0xbf, 0x06, 0x61, 0x1b, 0x31, 0xa6, 0xee, 0x58, 0x2d, 0xed, 0xe5,
	0xf7, 0xab, 0x37, 0x21, 0x0c, 0x45, 0xcf, 0x1d, 0xd3, 0x8a, 0xe0, 0xf2, 0x56, 0xd5, 0x07, 0x65,
	0x6a, 0xfa, 0x81, 0x31, 0x73, 0x47, 0xf6, 0xd9, 0x13, 0xe1, 0xe7, 0x3a, 0x95, 0xd3, 0xe0, 0xda,
	0x77, 0x51, 0x19, 0xbd, 0x7c, 0x0f, 0x9a, 0x22, 0xfb, 0x63, 0x27, 0x2b, 0xe8, 0x64, 0x03, 0xc9,
	0xb1, 0x8f, 0x3f, 0x80, 0xda, 0xdc, 0x63, 0x73, 0xd3, 0x0b, 0xbb, 0x8d, 0xa8, 0x94, 0x6a, 0x44,
	0xe3, 0xd5, 0x70, 0x1d, 0xc8, 0x52, 0x24, 0x36, 0x57, 0x45, 0x73, 0x1b, 0x11, 0x27, 0xb6, 0x68,
	0xc1, 0x5b, 0x78, 0x14, 0x7f, 0x61, 0x59, 0xcc, 0xf7, 0x0d, 0x6b, 0x62, 0x4e, 0xa7, 0x6c, 0xd9,
	0x85, 0x6b, 0x6b, 0x9c, 0x4a, 0xe5, 0x86, 0x74, 0x61, 0xa7, 0x1b, 0x99, 0xc1, 0xf3, 0x0d, 0xe1,
	0x32, 0x6e, 0x92, 0x31, 0x5e, 0x5f, 0xc3, 0xf8, 0x06, 0x37, 0x90, 0xb6, 0xfa, 0x1e, 0x34, 0xd3,
	0x06, 0x7d, 0xac, 0x63, 0x99, 0x36, 0xac, 0xa4, 0x9c, 0x4f, 0x3e, 0x84, 0xcd, 0x58, 0xf0, 0xb1,
	0xe9, 0x39, 0xa1, 0x74, 0x13, 0xa5, 0xc9, 0x92, 0x77, 0xcf, 0xf4, 0x1c, 0xa1, 0x71, 0x0b, 0xde,
	0x8c, 0x35, 0xa2, 0xd0, 0x08, 0x25, 0x51, 0xbc, 0x6f, 0x2c, 0xd9, 0xe1, 0x81, 0x51, 0xaf, 0xf5,
	0x3b, 0xa8, 0xa7, 0x8a, 0x85, 0x54, 0x40, 0x3e, 0xa0, 0x9d, 0xc3, 0xa1, 0x72, 0x89, 0x00, 0x14,
	0xf5, 0xe3, 0xa3, 0xbe, 0x76, 0x20, 0xea, 0xf8, 0xf4, 0xa4, 0x37, 0xe8, 0x1c, 0x68, 0x07, 0x4a,
	0x8e, 0x94, 0xa1, 0xd0, 0x1b, 0xe8, 0x43, 0x25, 0xcf, 0xe9, 0xdd, 0x4e, 0xbf, 0xab, 0xf5, 0xb4,
	0x03, 0xa5, 0xc0, 0x35, 0xba, 0xbd, 0x81, 0xae, 0x1d, 0x28, 0x32, 0xef, 0x0a, 0x54, 0xeb, 0x6b,
	0xf7, 0xb4, 0x03, 0xa5, 0xc8, 0xc5, 0x06, 0xb7, 0xf5, 0x41, 0x4f, 0x1b, 0x6a, 0x4a, 0x89, 0xab,
	0xdf, 0xeb, 0xd0, 0xbe, 0x52, 0x6e, 0xfd, 0x43, 0x86, 0x3a, 0x76, 0xfd, 0xc0, 0xf5, 0x18, 0xa2,
	0x57, 0x1a, 0x9c, 0xa4, 0x2c, 0x38, 0xa5, 0x90, 0x21, 0x97, 0x41, 0x86, 0x88, 0x89, 0xc0, 0x92,
	0xc7, 0x0e, 0x89, 0x4c, 0xc4, 0x94, 0x34, 0x6c, 0x14, 0xbe, 0x3f, 0x6c, 0xc8, 0xaf, 0x02, 0x1b,
	0x98, 0x02, 0xcc, 0x7a, 0x68, 0x9c, 0x79, 0xec, 0xf3, 0x05, 0x73, 0xac, 0x27, 0x58, 0xdd, 0x98,
	0x02, 0xcc, 0x7a, 0x78, 0x18, 0x51, 0x63, 0x7c, 0x39, 0x63, 0x0c, 0x21, 0x30, 0x1f, 0xe2, 0xcb,
	0x21, 0x63, 0x09, 0x7c, 0xe1, 0xdc, 0x32, 0x72, 0x43, 0x7c, 0xe1, 0xec, 0x25, 0x0e, 0x5b, 0x88,
	0x15, 0x95, 0x04, 0x0e, 0x77, 0x11, 0x25, 0xde, 0x85, 0xc6, 0xcc, 0x76, 0xec, 0xd9, 0x62, 0x66,
	0x20, 0xd5, 0xc7, 0xba, 0x94, 0x69, 0x3d, 0xa4, 0xea, 0x48, 0xe4, 0xc8, 0xe3, 0x31, 0xcb, 0x7d,
	0xc4, 0x3c, 0x23, 0x98, 0x78, 0xcc, 0x9f, 0xb8, 0x53, 0x81, 0x66, 0x32, 0x55, 0x42, 0xc6, 0x30,
	0xa2, 0x67, 0x30, 0xaf, 0x96, 0xc5, 0xbc, 0x14, 0x5e, 0xd6, 0x33, 0x78, 0xf9, 0x53, 0xd8, 0xc6,
	0x2c, 0xcf, 0x54, 0x87, 0x31, 0xb5, 0x67, 0x76, 0x10, 0xd6, 0xc8, 0x9b, 0x5c, 0x22, 0x55, 0x4f,
	0x7e, 0x8f, 0xb3, 0x49, 0x07, 0xae, 0xae, 0xee, 0x05, 0x91, 0xbe, 0xa8, 0x9a, 0x6d, 0x7f, 0x45,
	0xa1, 0x87, 0x26, 0xb0, 0xde, 0x52, 0xb7, 0x82, 0x55, 0x17, 0x96, 0x0e, 0x49, 0x5f, 0x0d, 0x2f,
	0xba, 0xd6, 0xdf, 0x8a, 0xd0, 0x5c, 0x26, 0x2e, 0xaf, 0x9c, 0x85, 0x4f, 0x0e, 0xa1, 0x29, 0xd2,
	0x8f, 0xd3, 0x8c, 0x19, 0x0b, 0xcc, 0x10, 0xd7, 0x36, 0xc3, 0xa6, 0x9c, 0xca, 0xf4, 0x04, 0xb0,
	0xd5, 0xcf, 0x52, 0x25, 0x70, 0x2b, 0x8d, 0x6e, 0x7b, 0x59, 0x6d, 0xb1, 0x5d, 0x9b, 0xcb, 0xa6,
	0x00, 0xee, 0x3a, 0x54, 0x22, 0x84, 0xf4, 0xd5, 0x3c, 0xc2, 0x41, 0x33, 0x83, 0x8c, 0x34, 0x96,
	0x58, 0x89, 0x87, 0x85, 0xd5, 0x78, 0x48, 0x81, 0x88, 0xcb, 0xf3, 0x98, 0xc5, 0xec, 0x47, 0xec,
	0x15, 0x80, 0x0e, 0xf5, 0xa9, 0x50, 0x0f, 0x81, 0x2e, 0x89, 0x5e, 0xc5, 0x17, 0xa1, 0xd7, 0x11,
	0xd4, 0xac, 0x85, 0x87, 0x85, 0x87, 0x1b, 0x97, 0xd6, 0xd8, 0xb8, 0x1a, 0x6a, 0x5e, 0x04, 0x5b,
	0xe5, 0x95, 0xb0, 0xa5, 0x41, 0x8d, 0x2b, 0x99, 0x53, 0x43, 0xdc, 0x44, 0x05, 0x6f, 0xa2, 0x75,
	0xc1, 0x4d, 0x50, 0x14, 0x15, 0x77, 0x51, 0xf5, 0xe2, 0xc5, 0xeb, 0x47, 0xbf, 0xd6, 0x19, 0x54,
	0x96, 0xf7, 0x9e, 0xec, 0xd5, 0x75, 0xa8, 0x88, 0xfe, 0x7c, 0xdc, 0x3f, 0x52, 0x24, 0x6c, 0xbe,
	0xa7, 0xfd, 0x3e, 0x5f, 0xe4, 0x88, 0x02, 0xb5, 0x93, 0x0e, 0x1d, 0x1e, 0x77, 0x7a, 0x46, 0xd8,
	0xb5, 0xa3, 0xfe, 0x5d, 0xe0, 0xbf, 0x0e, 0x06, 0x7d, 0x4d, 0x91, 0x53, 0x9d, 0xbc, 0xd8, 0xfa,
	0x04, 0xaa, 0x89, 0x53, 0x91, 0x12, 0xe4, 0xfb, 0xda, 0x3d, 0xe5, 0x12, 0x69, 0x42, 0x35, 0xb2,
	0xc5, 0x09, 0xb8, 0x93, 0xf6, 0x9b, 0x93, 0x63, 0x8a, 0xb8, 0x50, 0x01, 0x19, 0x7b, 0xbe, 0x92,
	0x6f, 0x7d, 0x2d, 0xc1, 0xc6, 0xb2, 0xd4, 0x3e, 0x5b, 0x30, 0x3f, 0xb0, 0x5d, 0x27, 0xf3, 0x80,
	0x90, 0xb2, 0x0f, 0x88, 0xe4, 0xd3, 0x23, 0x97, 0x7e, 0x7a, 0xf0, 0x57, 0xcd, 0x64, 0xe1, 0x3c,
	0x0c, 0xdf, 0x16, 0x79, 0xd1, 0xd3, 0x90, 0x24, 0xde, 0x16, 0x9b, 0x20, 0x3b, 0xae, 0x63, 0xb1,
	0xf0, 0x59, 0x22, 0x16, 0xe4, 0x1d, 0xa8, 0xb3, 0x2f, 0xe6, 0xcc, 0x0a, 0x0c, 0xd3, 0xf1, 0x1f,
	0x33, 0x0f, 0x93, 0xb6, 0x42, 0x6b, 0x82, 0xd8, 0x41, 0x5a, 0xeb, 0x0f, 0x79, 0xd8, 0x3a, 0xf1,
	0x5c, 0xf7, 0x6c, 0x70, 0x46, 0xd9, 0x7c, 0x6a, 0x5b, 0x66, 0xc0, 0x96, 0xbe, 0x93, 0x5f, 0x40,
	0xf9, 0xf3, 0xd0, 0xff, 0xb0, 0x9e, 0xd5, 0xa8, 0xaa, 0xb2, 0xe7, 0x4b, 0x0e, 0xab, 0x91, 0x0e,
	0xf9, 0x15, 0x34, 0x32, 0x63, 0x44, 0x6e, 0x8d, 0xfc, 0xad, 0xa7, 0x46, 0x83, 0x74, 0x1b, 0xcd,
	0x67, 0xda, 0xe8, 0x8a, 0xf4, 0x2e, 0xac, 0x4c, 0xef, 0x5d, 0xa8, 0x62, 0x9c, 0x53, 0x31, 0x01,
	0x4e, 0x12, 0x11, 0x21, 0x9f, 0x26, 0x06, 0x60, 0xe1, 0x73, 0x71, 0x0d, 0x9f, 0x6b, 0xd1, 0x98,
	0x1c, 0xbd, 0x6f, 0x33, 0xc3, 0x74, 0x69, 0xc5, 0x30, 0xdd, 0xfa, 0x3d, 0x5c, 0xe1, 0x75, 0x75,
	0x2e, 0xa6, 0x7e, 0x1a, 0xf3, 0xa5, 0x0c, 0xe6, 0x1f, 0x45, 0x4f, 0xca, 0x28, 0xde, 0xbe, 0x9a,
	0xc3, 0x5e, 0xb2, 0x13, 0x5e, 0x12, 0x62, 0xd9, 0x79, 0xab, 0xb4, 0x81, 0x6a, 0xcb, 0x75, 0xeb,
	0xdf, 0x39, 0x78, 0xf3, 0x02, 0xd9, 0x17, 0x7b, 0x90, 0xce, 0xe9, 0x5c, 0x36, 0xa7, 0xb3, 0x3d,
	0x20, 0x7f, 0xbe, 0x07, 0xbc, 0x0b, 0x8d, 0xc8, 0xfb, 0x10, 0xb2, 0x0b, 0x02, 0x8e, 0x23, 0xaa,
	0x40, 0xed, 0x5b, 0x50, 0x89, 0x0f, 0x29, 0xe3, 0x21, 0x2f, 0xcc, 0x44, 0x1a, 0x8b, 0xf2, 0xf6,
	0x19, 0xee, 0xb6, 0xfe, 0x55, 0x46, 0x7e, 0xe2, 0x4d, 0xae, 0xee, 0x55, 0xa5, 0x8b, 0x7a, 0xd5,
	0x73, 0x09, 0xb6, 0xba, 0x08, 0x9d, 0x49, 0x78, 0xa3, 0x0c, 0x3d, 0x7b, 0x69, 0x4c, 0x5f, 0xf4,
	0x89, 0xe2, 0x1d, 0xa8, 0x7b, 0xc2, 0x4c, 0x2a, 0xa8, 0xb5, 0x25, 0x91, 0x0b, 0x1d, 0x41, 0xb4,
	0x16, 0xc7, 0x5e, 0x67, 0xe4, 0xab, 0x86, 0x9a, 0x78, 0xec, 0xb7, 0xa1, 0x12, 0x9f, 0x56, 0xc6,
	0xd3, 0xc6, 0x84, 0xd6, 0x3f, 0x0b, 0xa0, 0xf6, 0x6c, 0x3f, 0xb8, 0xe3, 0xfa, 0x41, 0x04, 0xb3,
	0x7e, 0x74, 0xc8, 0x64, 0x43, 0x93, 0xd2, 0x0d, 0xed, 0xdc, 0x19, 0x72, 0x2b, 0xce, 0xf0, 0x3e,
	0x9f, 0xc0, 0xc4, 0x19, 0xe6, 0xe6, 0x38, 0x31, 0xd9, 0xca, 0x1c, 0xa4, 0x91, 0x71, 0x62, 0x8e,
	0xc5, 0x80, 0xfb, 0x23, 0x20, 0x29, 0x59, 0xd1, 0x28, 0x0b, 0xd1, 0xb8, 0xb6, 0x14, 0x16, 0xed,
	0xf2, 0x3e, 0x5c, 0xc9, 0xbe, 0x08, 0x0d, 0xdf, 0xe6, 0xfd, 0x73, 0x1d, 0x58, 0xbf, 0x9c, 0x7e,
	0x17, 0xea, 0xdc, 0x00, 0xd1, 0xc3, 0xc7, 0x53, 0xd2, 0x74, 0xe0, 0xae, 0x95, 0x76, 0x4a, 0xda,
	0xee, 0xd0, 0x25, 0x9d, 0x68, 0x28, 0x2a, 0x21, 0x14, 0x7f, 0x10, 0x4d, 0x0a, 0x17, 0x44, 0xbe,
	0xad, 0xb3, 0x29, 0xcb, 0x7c, 0x00, 0xc8, 0x26, 0x44, 0xf9, 0xb5, 0x24, 0x44, 0x25, 0x9b, 0x10,
	0x6d, 0xa8, 0x26, 0x36, 0xe7, 0xd0, 0xd9, 0xe9, 0xf5, 0xc4, 0x73, 0xaa, 0xd3, 0x1d, 0x1e, 0xff,
	0x5a, 0x53, 0xa4, 0xc4, 0x43, 0x29, 0xd7, 0xfa, 0x4e, 0x8a, 0xdf, 0x60, 0x3e, 0x3f, 0x0f, 0xf9,
	0x18, 0x4a, 0xe1, 0x76, 0x21, 0xe0, 0xec, 0xbe, 0xe4, 0xb4, 0x34, 0x92, 0x27, 0xc7, 0x50, 0x1f,
	0x33, 0x87, 0x79, 0x66, 0xf0, 0x0a, 0x58, 0x53, 0x8b, 0x54, 0xc3, 0x6a, 0x5f, 0x6b, 0x9c, 0xdc,
	0x04, 0x39, 0xd9, 0xbb, 0xc4, 0xe2, 0x25, 0xb5, 0xf3, 0x55, 0x0e, 0x54, 0xca, 0xcc, 0xd1, 0x93,
	0x43, 0xd7, 0x5b, 0xb6, 0xb0, 0xa8, 0x76, 0xbe, 0xcf, 0x4b, 0x30, 0xdd, 0x93, 0xf3, 0x2b, 0x3e,
	0x54, 0x26, 0x3f, 0x91, 0x16, 0xce, 0x7d, 0x22, 0x4d, 0xd6, 0xad, 0x9c, 0xae, 0xdb, 0xd7, 0xd6,
	0x4d, 0x53, 0xa1, 0x29, 0x65, 0x43, 0xf3, 0x47, 0x09, 0xc8, 0xa1, 0xeb, 0x59, 0x8c, 0xb2, 0xb9,
	0x69, 0x7b, 0xaf, 0x23, 0x28, 0x5b, 0x50, 0x36, 0x17, 0xc1, 0x24, 0xf9, 0x61, 0x97, 0xaf, 0xb9,
	0x5e, 0xca, 0x97, 0x42, 0xd6, 0x97, 0xbf, 0x4a, 0x50, 0xa4, 0xcc, 0x5f, 0x4c, 0x03, 0xf2, 0x1e,
	0x14, 0x2c, 0x77, 0x24, 0x3e, 0x76, 0x37, 0x96, 0x1f, 0xec, 0x28, 0xf3, 0xe7, 0xae, 0xe3, 0xb3,
	0xae, 0x3b, 0x62, 0x14, 0x05, 0x88, 0x0a, 0xa5, 0x19, 0xf3, 0x7d, 0x73, 0xcc, 0xa2, 0x49, 0x2e,
	0x5c, 0xf2, 0x14, 0xf5, 0x42, 0x79, 0x11, 0xc1, 0xfc, 0x3a, 0x29, 0x1a, 0xa9, 0x72, 0xe6, 0xfb,
	0x16, 0xd4, 0x92, 0x5b, 0xf3, 0x61, 0x54, 0x3f, 0xed, 0x76, 0x35, 0x5d, 0x57, 0x2e, 0x91, 0x6d,
	0xb8, 0xa2, 0x1f, 0x1f, 0xf5, 0x3b, 0xc3, 0x53, 0xaa, 0x19, 0x87, 0x03, 0x7a, 0xb7, 0x33, 0x34,
	0x34, 0x4a, 0x07, 0x54, 0x91, 0xc8, 0x16, 0xbc, 0xd1, 0x1d, 0xdc, 0x3d, 0x39, 0x1d, 0x6a, 0x46,
	0xe7, 0xe0, 0x80, 0x6a, 0xba, 0x1e, 0xb2, 0x72, 0x7c, 0xc2, 0x1d, 0x0c, 0xef, 0x68, 0x34, 0x24,
	0x6c, 0xde, 0xfc, 0x7b, 0x1e, 0x6a, 0x47, 0x38, 0x3f, 0x31, 0xef, 0x91, 0x6d, 0x31, 0xf2, 0x33,
	0xb8, 0xac, 0x2f, 0x1e, 0xcc, 0xec, 0x20, 0xfd, 0xe5, 0xe2, 0xca, 0xea, 0xd7, 0xc1, 0x76, 0x3d,
	0x0e, 0x12, 0x8f, 0xe0, 0xcf, 0xa1, 0xae, 0x33, 0x27, 0x1e, 0x3c, 0xc8, 0xd5, 0x84, 0xde, 0xf9,
	0xd9, 0x23, 0xab, 0xde, 0x07, 0x72, 0x1e, 0x53, 0xc9, 0xde, 0x72, 0x0e, 0xb8, 0x00, 0x6e, 0xb7,
	0x2f, 0xf0, 0x8e, 0x74, 0x61, 0xe3, 0x5c, 0x05, 0x92, 0xdd, 0xe5, 0x9e, 0xab, 0x6b, 0x33, 0xeb,
	0xd4, 0x4f, 0xa0, 0x9a, 0xc8, 0x55, 0xb2, 0x15, 0xed, 0x75, 0x2e, 0x7f, 0xb3, 0x8a, 0x9f, 0xc2,
	0xc6, 0xb9, 0x9e, 0x46, 0x5e, 0xd6, 0xed, 0xb6, 0x37, 0x33, 0x6d, 0x08, 0xbb, 0xe6, 0xed, 0x5f,
	0x7e, 0xf7, 0xbf, 0x1d, 0xe9, 0xe9, 0xb3, 0x1d, 0xe9, 0x9b, 0x67, 0x3b, 0xd2, 0x7f, 0x9f, 0xed,
	0x48, 0x5f, 0x3d, 0xdf, 0x91, 0xfe, 0xf5, 0x7c, 0x47, 0x7a, 0xfa, 0x7c, 0x47, 0x82, 0xba, 0xed,
	0xb6, 0x1f, 0x04, 0x67, 0xbe, 0x50, 0xbd, 0x0d, 0x78, 0xa3, 0x27, 0x3c, 0xd5, 0x4e, 0xa4, 0xdf,
	0x8a, 0xff, 0x15, 0x3d, 0x28, 0x62, 0xea, 0x7d, 0xf4, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf2,
	0x3b, 0xd6, 0x36, 0x55, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GuardServiceClient is the client API for GuardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GuardServiceClient interface {
	SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error)
	SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error)
	CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error)
	ReadyForChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*Result, error)
	ForceRepair(ctx context.Context, in *ForceRepairRequest, opts ...grpc.CallOption) (*Result, error)
	ListHostContracts(ctx context.Context, in *ListHostContractsRequest, opts ...grpc.CallOption) (*ContractsList, error)
}

type guardServiceClient struct {
	cc *grpc.ClientConn
}

func NewGuardServiceClient(cc *grpc.ClientConn) GuardServiceClient {
	return &guardServiceClient{cc}
}

func (c *guardServiceClient) SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SubmitFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SendQuestions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error) {
	out := new(FileStoreStatus)
	err := c.cc.Invoke(ctx, "/guard.GuardService/CheckFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ReadyForChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ReadyForChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ForceRepair(ctx context.Context, in *ForceRepairRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ForceRepair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ListHostContracts(ctx context.Context, in *ListHostContractsRequest, opts ...grpc.CallOption) (*ContractsList, error) {
	out := new(ContractsList)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ListHostContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuardServiceServer is the server API for GuardService service.
type GuardServiceServer interface {
	SubmitFileStoreMeta(context.Context, *FileStoreStatus) (*Result, error)
	SendQuestions(context.Context, *FileChallengeQuestions) (*Result, error)
	CheckFileStoreMeta(context.Context, *CheckFileStoreMetaRequest) (*FileStoreStatus, error)
	ReadyForChallenge(context.Context, *ReadyForChallengeRequest) (*Result, error)
	ForceRepair(context.Context, *ForceRepairRequest) (*Result, error)
	ListHostContracts(context.Context, *ListHostContractsRequest) (*ContractsList, error)
}

// UnimplementedGuardServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGuardServiceServer struct {
}

func (*UnimplementedGuardServiceServer) SubmitFileStoreMeta(ctx context.Context, req *FileStoreStatus) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitFileStoreMeta not implemented")
}
func (*UnimplementedGuardServiceServer) SendQuestions(ctx context.Context, req *FileChallengeQuestions) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendQuestions not implemented")
}
func (*UnimplementedGuardServiceServer) CheckFileStoreMeta(ctx context.Context, req *CheckFileStoreMetaRequest) (*FileStoreStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckFileStoreMeta not implemented")
}
func (*UnimplementedGuardServiceServer) ReadyForChallenge(ctx context.Context, req *ReadyForChallengeRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadyForChallenge not implemented")
}
func (*UnimplementedGuardServiceServer) ForceRepair(ctx context.Context, req *ForceRepairRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceRepair not implemented")
}
func (*UnimplementedGuardServiceServer) ListHostContracts(ctx context.Context, req *ListHostContractsRequest) (*ContractsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHostContracts not implemented")
}

func RegisterGuardServiceServer(s *grpc.Server, srv GuardServiceServer) {
	s.RegisterService(&_GuardService_serviceDesc, srv)
}

func _GuardService_SubmitFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileStoreStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SubmitFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, req.(*FileStoreStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_SendQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileChallengeQuestions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SendQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SendQuestions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SendQuestions(ctx, req.(*FileChallengeQuestions))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_CheckFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFileStoreMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/CheckFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, req.(*CheckFileStoreMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ReadyForChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadyForChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ReadyForChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ReadyForChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ReadyForChallenge(ctx, req.(*ReadyForChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ForceRepair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceRepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ForceRepair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ForceRepair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ForceRepair(ctx, req.(*ForceRepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ListHostContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ListHostContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ListHostContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ListHostContracts(ctx, req.(*ListHostContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GuardService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "guard.GuardService",
	HandlerType: (*GuardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitFileStoreMeta",
			Handler:    _GuardService_SubmitFileStoreMeta_Handler,
		},
		{
			MethodName: "SendQuestions",
			Handler:    _GuardService_SendQuestions_Handler,
		},
		{
			MethodName: "CheckFileStoreMeta",
			Handler:    _GuardService_CheckFileStoreMeta_Handler,
		},
		{
			MethodName: "ReadyForChallenge",
			Handler:    _GuardService_ReadyForChallenge_Handler,
		},
		{
			MethodName: "ForceRepair",
			Handler:    _GuardService_ForceRepair_Handler,
		},
		{
			MethodName: "ListHostContracts",
			Handler:    _GuardService_ListHostContracts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/guard/guard.proto",
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Change) > 0 {
		i -= len(m.Change)
		copy(dAtA[i:], m.Change)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Change)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OriginatorPid) > 0 {
		i -= len(m.OriginatorPid)
		copy(dAtA[i:], m.OriginatorPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.OriginatorPid)))
		i--
		dAtA[i] = 0x12
	}
	n1, err1 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.ChangeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChangeTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintGuard(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ContractMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumPayouts != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NumPayouts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PayoutSchedule != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.PayoutSchedule))
		i--
		dAtA[i] = 0x78
	}
	if m.CollateralAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CollateralAmount))
		i--
		dAtA[i] = 0x70
	}
	if m.Amount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x68
	}
	if m.Price != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x60
	}
	if len(m.EscrowPid) > 0 {
		i -= len(m.EscrowPid)
		copy(dAtA[i:], m.EscrowPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowPid)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x52
	}
	n2, err2 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentEnd, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintGuard(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x4a
	n3, err3 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentStart, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintGuard(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x42
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardFileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardFileSize))
		i--
		dAtA[i] = 0x30
	}
	if m.ShardIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChallengeSuccessTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeSuccessTimes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ChallengeWarnTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeWarnTimes))
		i--
		dAtA[i] = 0x78
	}
	if m.ChallengeTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeTimes))
		i--
		dAtA[i] = 0x70
	}
	n4, err4 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastChallengeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastChallengeTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintGuard(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x6a
	n5, err5 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastSuccessChallengeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastSuccessChallengeTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintGuard(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x62
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x4a
	}
	n6, err6 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastModifyTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintGuard(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x42
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.EscrowSignature) > 0 {
		i -= len(m.EscrowSignature)
		copy(dAtA[i:], m.EscrowSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowSignature)))
		i--
		dAtA[i] = 0x32
	}
	n7, err7 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.EscrowSignedTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.EscrowSignedTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintGuard(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x2a
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ContractMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FileStoreMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CheckFrequencyWarn != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CheckFrequencyWarn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SuccessChallengeTimesLimit != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.SuccessChallengeTimesLimit))
		i--
		dAtA[i] = 0x78
	}
	if m.WarnChallengeTimesLimit != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.WarnChallengeTimesLimit))
		i--
		dAtA[i] = 0x70
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EscrowPid) > 0 {
		i -= len(m.EscrowPid)
		copy(dAtA[i:], m.EscrowPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowPid)))
		i--
		dAtA[i] = 0x62
	}
	if m.RecoverThreshold != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RecoverThreshold))
		i--
		dAtA[i] = 0x58
	}
	if m.MinimumShards != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.MinimumShards))
		i--
		dAtA[i] = 0x50
	}
	if m.ShardCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardCount))
		i--
		dAtA[i] = 0x48
	}
	if m.EscrowFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.EscrowFee))
		i--
		dAtA[i] = 0x40
	}
	if m.GuardFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.GuardFee))
		i--
		dAtA[i] = 0x38
	}
	if m.CheckFrequency != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CheckFrequency))
		i--
		dAtA[i] = 0x30
	}
	n9, err9 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentEnd, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintGuard(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x2a
	n10, err10 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentStart, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintGuard(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x22
	if m.FileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x52
	}
	if m.RentalState != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RentalState))
		i--
		dAtA[i] = 0x48
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x42
	}
	n11, err11 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.CurrentTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.CurrentTime):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintGuard(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x3a
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	n12, err12 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.GuardReceiveTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.GuardReceiveTime):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintGuard(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x2a
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.FileStoreMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExpectAnswer) > 0 {
		i -= len(m.ExpectAnswer)
		copy(dAtA[i:], m.ExpectAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ExpectAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if m.ChunkIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChunkIndex))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProofOfReplicateChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofOfReplicateChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofOfReplicateChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n14, err14 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.HostSignTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.HostSignTime):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintGuard(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x32
	if len(m.HostAnswer) > 0 {
		i -= len(m.HostAnswer)
		copy(dAtA[i:], m.HostAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x1a
	}
	n15, err15 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.ChallengeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChallengeTime):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintGuard(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ChallengeQuestion.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FileChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardQuestions) > 0 {
		for iNdEx := len(m.ShardQuestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardQuestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n17, err17 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err17 != nil {
		return 0, err17
	}
	i -= n17
	i = encodeVarintGuard(dAtA, i, uint64(n17))
	i--
	dAtA[i] = 0x32
	if len(m.Questions) > 0 {
		for iNdEx := len(m.Questions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Questions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.QuestionCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.QuestionCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckFileStoreMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckFileStoreMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckFileStoreMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	n18, err18 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err18 != nil {
		return 0, err18
	}
	i -= n18
	i = encodeVarintGuard(dAtA, i, uint64(n18))
	i--
	dAtA[i] = 0x22
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListHostContractsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHostContractsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHostContractsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	n19, err19 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintGuard(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0x42
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	n20, err20 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastModifyTimeTo, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTimeTo):])
	if err20 != nil {
		return 0, err20
	}
	i -= n20
	i = encodeVarintGuard(dAtA, i, uint64(n20))
	i--
	dAtA[i] = 0x32
	n21, err21 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastModifyTimeSince, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTimeSince):])
	if err21 != nil {
		return 0, err21
	}
	i -= n21
	i = encodeVarintGuard(dAtA, i, uint64(n21))
	i--
	dAtA[i] = 0x2a
	if m.RequestPageIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestPageSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Count != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n22, err22 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.GenerateTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.GenerateTime):])
	if err22 != nil {
		return 0, err22
	}
	i -= n22
	i = encodeVarintGuard(dAtA, i, uint64(n22))
	i--
	dAtA[i] = 0x12
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadyForChallengeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadyForChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadyForChallengeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	n24, err24 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err24 != nil {
		return 0, err24
	}
	i -= n24
	i = encodeVarintGuard(dAtA, i, uint64(n24))
	i--
	dAtA[i] = 0x32
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForceRepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceRepairRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForceRepairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AuthPid) > 0 {
		i -= len(m.AuthPid)
		copy(dAtA[i:], m.AuthPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.AuthPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n25, err25 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.ResponseTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.ResponseTime):])
	if err25 != nil {
		return 0, err25
	}
	i -= n25
	i = encodeVarintGuard(dAtA, i, uint64(n25))
	i--
	dAtA[i] = 0x1a
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGuard(dAtA []byte, offset int, v uint64) int {
	offset -= sovGuard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedLog(r randyGuard, easy bool) *Log {
	this := &Log{}
	v1 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ChangeTime = *v1
	this.OriginatorPid = string(randStringGuard(r))
	this.Change = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 4)
	}
	return this
}

func NewPopulatedContractMeta(r randyGuard, easy bool) *ContractMeta {
	this := &ContractMeta{}
	this.ContractId = string(randStringGuard(r))
	this.RenterPid = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.ShardIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ShardIndex *= -1
	}
	this.ShardFileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ShardFileSize *= -1
	}
	this.FileHash = string(randStringGuard(r))
	v2 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentStart = *v2
	v3 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentEnd = *v3
	this.GuardPid = string(randStringGuard(r))
	this.EscrowPid = string(randStringGuard(r))
	this.Price = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Price *= -1
	}
	this.Amount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Amount *= -1
	}
	this.CollateralAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.CollateralAmount *= -1
	}
	this.PayoutSchedule = ContractMeta_Schedule([]int32{0, 1, 2}[r.Intn(3)])
	this.NumPayouts = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.NumPayouts *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 17)
	}
	return this
}

func NewPopulatedContract(r randyGuard, easy bool) *Contract {
	this := &Contract{}
	v4 := NewPopulatedContractMeta(r, easy)
	this.ContractMeta = *v4
	this.State = Contract_ContractState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	v5 := r.Intn(100)
	this.RenterSignature = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.RenterSignature[i] = byte(r.Intn(256))
	}
	v6 := r.Intn(100)
	this.HostSignature = make([]byte, v6)
	for i := 0; i < v6; i++ {
		this.HostSignature[i] = byte(r.Intn(256))
	}
	v7 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.EscrowSignedTime = *v7
	v8 := r.Intn(100)
	this.EscrowSignature = make([]byte, v8)
	for i := 0; i < v8; i++ {
		this.EscrowSignature[i] = byte(r.Intn(256))
	}
	if r.Intn(5) != 0 {
		v9 := r.Intn(5)
		this.ChangeLog = make([]*Log, v9)
		for i := 0; i < v9; i++ {
			this.ChangeLog[i] = NewPopulatedLog(r, easy)
		}
	}
	v10 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastModifyTime = *v10
	v11 := r.Intn(100)
	this.GuardSignature = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.PreparerPid = string(randStringGuard(r))
	v12 := r.Intn(100)
	this.PreparerSignature = make([]byte, v12)
	for i := 0; i < v12; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	v13 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastSuccessChallengeTime = *v13
	v14 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastChallengeTime = *v14
	this.ChallengeTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeTimes *= -1
	}
	this.ChallengeWarnTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeWarnTimes *= -1
	}
	this.ChallengeSuccessTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeSuccessTimes *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 17)
	}
	return this
}

func NewPopulatedFileStoreMeta(r randyGuard, easy bool) *FileStoreMeta {
	this := &FileStoreMeta{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.FileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FileSize *= -1
	}
	v15 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentStart = *v15
	v16 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentEnd = *v16
	this.CheckFrequency = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CheckFrequency *= -1
	}
	this.GuardFee = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.GuardFee *= -1
	}
	this.EscrowFee = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EscrowFee *= -1
	}
	this.ShardCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ShardCount *= -1
	}
	this.MinimumShards = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MinimumShards *= -1
	}
	this.RecoverThreshold = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RecoverThreshold *= -1
	}
	this.EscrowPid = string(randStringGuard(r))
	this.GuardPid = string(randStringGuard(r))
	this.WarnChallengeTimesLimit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WarnChallengeTimesLimit *= -1
	}
	this.SuccessChallengeTimesLimit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.SuccessChallengeTimesLimit *= -1
	}
	this.CheckFrequencyWarn = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CheckFrequencyWarn *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 17)
	}
	return this
}

func NewPopulatedFileStoreStatus(r randyGuard, easy bool) *FileStoreStatus {
	this := &FileStoreStatus{}
	v17 := NewPopulatedFileStoreMeta(r, easy)
	this.FileStoreMeta = *v17
	this.State = FileStoreStatus_MetaState([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	if r.Intn(5) != 0 {
		v18 := r.Intn(5)
		this.Contracts = make([]*Contract, v18)
		for i := 0; i < v18; i++ {
			this.Contracts[i] = NewPopulatedContract(r, easy)
		}
	}
	v19 := r.Intn(100)
	this.RenterSignature = make([]byte, v19)
	for i := 0; i < v19; i++ {
		this.RenterSignature[i] = byte(r.Intn(256))
	}
	v20 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GuardReceiveTime = *v20
	if r.Intn(5) != 0 {
		v21 := r.Intn(5)
		this.ChangeLog = make([]*Log, v21)
		for i := 0; i < v21; i++ {
			this.ChangeLog[i] = NewPopulatedLog(r, easy)
		}
	}
	v22 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.CurrentTime = *v22
	v23 := r.Intn(100)
	this.GuardSignature = make([]byte, v23)
	for i := 0; i < v23; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.RentalState = FileStoreStatus_RentalState([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.PreparerPid = string(randStringGuard(r))
	v24 := r.Intn(100)
	this.PreparerSignature = make([]byte, v24)
	for i := 0; i < v24; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 12)
	}
	return this
}

func NewPopulatedChallengeQuestion(r randyGuard, easy bool) *ChallengeQuestion {
	this := &ChallengeQuestion{}
	this.ShardHash = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.ChunkIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChunkIndex *= -1
	}
	this.Nonce = string(randStringGuard(r))
	this.ExpectAnswer = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedProofOfReplicateChallenge(r randyGuard, easy bool) *ProofOfReplicateChallenge {
	this := &ProofOfReplicateChallenge{}
	v25 := NewPopulatedChallengeQuestion(r, easy)
	this.ChallengeQuestion = *v25
	v26 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ChallengeTime = *v26
	this.GuardPid = string(randStringGuard(r))
	v27 := r.Intn(100)
	this.GuardSignature = make([]byte, v27)
	for i := 0; i < v27; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.HostAnswer = string(randStringGuard(r))
	v28 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.HostSignTime = *v28
	v29 := r.Intn(100)
	this.HostSignature = make([]byte, v29)
	for i := 0; i < v29; i++ {
		this.HostSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedFileChallengeQuestions(r randyGuard, easy bool) *FileChallengeQuestions {
	this := &FileChallengeQuestions{}
	this.FileHash = string(randStringGuard(r))
	if r.Intn(5) != 0 {
		v30 := r.Intn(5)
		this.ShardQuestions = make([]*ShardChallengeQuestions, v30)
		for i := 0; i < v30; i++ {
			this.ShardQuestions[i] = NewPopulatedShardChallengeQuestions(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 3)
	}
	return this
}

func NewPopulatedShardChallengeQuestions(r randyGuard, easy bool) *ShardChallengeQuestions {
	this := &ShardChallengeQuestions{}
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.PreparerPid = string(randStringGuard(r))
	this.QuestionCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.QuestionCount *= -1
	}
	if r.Intn(5) != 0 {
		v31 := r.Intn(5)
		this.Questions = make([]*ChallengeQuestion, v31)
		for i := 0; i < v31; i++ {
			this.Questions[i] = NewPopulatedChallengeQuestion(r, easy)
		}
	}
	v32 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v32
	v33 := r.Intn(100)
	this.PreparerSignature = make([]byte, v33)
	for i := 0; i < v33; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedCheckFileStoreMetaRequest(r randyGuard, easy bool) *CheckFileStoreMetaRequest {
	this := &CheckFileStoreMetaRequest{}
	this.FileHash = string(randStringGuard(r))
	this.RenterPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	v34 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RequestTime = *v34
	v35 := r.Intn(100)
	this.Signature = make([]byte, v35)
	for i := 0; i < v35; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedListHostContractsRequest(r randyGuard, easy bool) *ListHostContractsRequest {
	this := &ListHostContractsRequest{}
	this.HostPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	this.RequestPageSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageSize *= -1
	}
	this.RequestPageIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageIndex *= -1
	}
	v36 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastModifyTimeSince = *v36
	v37 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastModifyTimeTo = *v37
	this.State = ListHostContractsRequest_SelectState([]int32{0, 1, 2}[r.Intn(3)])
	v38 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RequestTime = *v38
	v39 := r.Intn(100)
	this.Signature = make([]byte, v39)
	for i := 0; i < v39; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 10)
	}
	return this
}

func NewPopulatedContractsList(r randyGuard, easy bool) *ContractsList {
	this := &ContractsList{}
	if r.Intn(5) != 0 {
		this.Request = NewPopulatedListHostContractsRequest(r, easy)
	}
	v40 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GenerateTime = *v40
	if r.Intn(5) != 0 {
		v41 := r.Intn(5)
		this.Contracts = make([]*Contract, v41)
		for i := 0; i < v41; i++ {
			this.Contracts[i] = NewPopulatedContract(r, easy)
		}
	}
	this.Count = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	v42 := r.Intn(100)
	this.Signature = make([]byte, v42)
	for i := 0; i < v42; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedReadyForChallengeRequest(r randyGuard, easy bool) *ReadyForChallengeRequest {
	this := &ReadyForChallengeRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.ContractId = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	v43 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v43
	v44 := r.Intn(100)
	this.Signature = make([]byte, v44)
	for i := 0; i < v44; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedForceRepairRequest(r randyGuard, easy bool) *ForceRepairRequest {
	this := &ForceRepairRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.AuthPid = string(randStringGuard(r))
	v45 := r.Intn(100)
	this.Signature = make([]byte, v45)
	for i := 0; i < v45; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 5)
	}
	return this
}

func NewPopulatedResult(r randyGuard, easy bool) *Result {
	this := &Result{}
	this.Code = ResponseCode([]int32{0, 1, 2, 20}[r.Intn(4)])
	this.Message = string(randStringGuard(r))
	v46 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResponseTime = *v46
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 4)
	}
	return this
}

type randyGuard interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneGuard(r randyGuard) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringGuard(r randyGuard) string {
	v47 := r.Intn(100)
	tmps := make([]rune, v47)
	for i := 0; i < v47; i++ {
		tmps[i] = randUTF8RuneGuard(r)
	}
	return string(tmps)
}
func randUnrecognizedGuard(r randyGuard, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldGuard(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldGuard(dAtA []byte, r randyGuard, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		v48 := r.Int63()
		if r.Intn(2) == 0 {
			v48 *= -1
		}
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(v48))
	case 1:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateGuard(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChangeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.OriginatorPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Change)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContractMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ShardIndex != 0 {
		n += 1 + sovGuard(uint64(m.ShardIndex))
	}
	if m.ShardFileSize != 0 {
		n += 1 + sovGuard(uint64(m.ShardFileSize))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.EscrowPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovGuard(uint64(m.Price))
	}
	if m.Amount != 0 {
		n += 1 + sovGuard(uint64(m.Amount))
	}
	if m.CollateralAmount != 0 {
		n += 1 + sovGuard(uint64(m.CollateralAmount))
	}
	if m.PayoutSchedule != 0 {
		n += 1 + sovGuard(uint64(m.PayoutSchedule))
	}
	if m.NumPayouts != 0 {
		n += 2 + sovGuard(uint64(m.NumPayouts))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ContractMeta.Size()
	n += 1 + l + sovGuard(uint64(l))
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.EscrowSignedTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.EscrowSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastSuccessChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	if m.ChallengeTimes != 0 {
		n += 1 + sovGuard(uint64(m.ChallengeTimes))
	}
	if m.ChallengeWarnTimes != 0 {
		n += 1 + sovGuard(uint64(m.ChallengeWarnTimes))
	}
	if m.ChallengeSuccessTimes != 0 {
		n += 2 + sovGuard(uint64(m.ChallengeSuccessTimes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovGuard(uint64(m.FileSize))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd)
	n += 1 + l + sovGuard(uint64(l))
	if m.CheckFrequency != 0 {
		n += 1 + sovGuard(uint64(m.CheckFrequency))
	}
	if m.GuardFee != 0 {
		n += 1 + sovGuard(uint64(m.GuardFee))
	}
	if m.EscrowFee != 0 {
		n += 1 + sovGuard(uint64(m.EscrowFee))
	}
	if m.ShardCount != 0 {
		n += 1 + sovGuard(uint64(m.ShardCount))
	}
	if m.MinimumShards != 0 {
		n += 1 + sovGuard(uint64(m.MinimumShards))
	}
	if m.RecoverThreshold != 0 {
		n += 1 + sovGuard(uint64(m.RecoverThreshold))
	}
	l = len(m.EscrowPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.WarnChallengeTimesLimit != 0 {
		n += 1 + sovGuard(uint64(m.WarnChallengeTimesLimit))
	}
	if m.SuccessChallengeTimesLimit != 0 {
		n += 1 + sovGuard(uint64(m.SuccessChallengeTimesLimit))
	}
	if m.CheckFrequencyWarn != 0 {
		n += 2 + sovGuard(uint64(m.CheckFrequencyWarn))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FileStoreMeta.Size()
	n += 1 + l + sovGuard(uint64(l))
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.GuardReceiveTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.CurrentTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RentalState != 0 {
		n += 1 + sovGuard(uint64(m.RentalState))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ChunkIndex != 0 {
		n += 1 + sovGuard(uint64(m.ChunkIndex))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ExpectAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProofOfReplicateChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ChallengeQuestion.Size()
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.HostSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ShardQuestions) > 0 {
		for _, e := range m.ShardQuestions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.QuestionCount != 0 {
		n += 1 + sovGuard(uint64(m.QuestionCount))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckFileStoreMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHostContractsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RequestPageSize != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageSize))
	}
	if m.RequestPageIndex != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageIndex))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTimeSince)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTimeTo)
	n += 1 + l + sovGuard(uint64(l))
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContractsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.GenerateTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovGuard(uint64(m.Count))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadyForChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForceRepairRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.AuthPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGuard(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.ResponseTime)
	n += 1 + l + sovGuard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGuard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGuard(x uint64) (n int) {
	return sovGuard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.ChangeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginatorPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginatorPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Change = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardIndex", wireType)
			}
			m.ShardIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardFileSize", wireType)
			}
			m.ShardFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAmount", wireType)
			}
			m.CollateralAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutSchedule", wireType)
			}
			m.PayoutSchedule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayoutSchedule |= ContractMeta_Schedule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPayouts", wireType)
			}
			m.NumPayouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPayouts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Contract_ContractState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.EscrowSignedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowSignature = append(m.EscrowSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowSignature == nil {
				m.EscrowSignature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastModifyTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastSuccessChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimes", wireType)
			}
			m.ChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeWarnTimes", wireType)
			}
			m.ChallengeWarnTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeWarnTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeSuccessTimes", wireType)
			}
			m.ChallengeSuccessTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeSuccessTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFrequency", wireType)
			}
			m.CheckFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckFrequency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardFee", wireType)
			}
			m.GuardFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowFee", wireType)
			}
			m.EscrowFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EscrowFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCount", wireType)
			}
			m.ShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumShards", wireType)
			}
			m.MinimumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumShards |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverThreshold", wireType)
			}
			m.RecoverThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarnChallengeTimesLimit", wireType)
			}
			m.WarnChallengeTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarnChallengeTimesLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessChallengeTimesLimit", wireType)
			}
			m.SuccessChallengeTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessChallengeTimesLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFrequencyWarn", wireType)
			}
			m.CheckFrequencyWarn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckFrequencyWarn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStoreMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileStoreMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FileStoreStatus_MetaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardReceiveTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.GuardReceiveTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.CurrentTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentalState", wireType)
			}
			m.RentalState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RentalState |= FileStoreStatus_RentalState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkIndex", wireType)
			}
			m.ChunkIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectAnswer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofOfReplicateChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeQuestion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChallengeQuestion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.ChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAnswer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.HostSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardQuestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardQuestions = append(m.ShardQuestions, &ShardChallengeQuestions{})
			if err := m.ShardQuestions[len(m.ShardQuestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionCount", wireType)
			}
			m.QuestionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuestionCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &ChallengeQuestion{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckFileStoreMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHostContractsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHostContractsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHostContractsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageSize", wireType)
			}
			m.RequestPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageIndex", wireType)
			}
			m.RequestPageIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTimeSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastModifyTimeSince, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTimeTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastModifyTimeTo, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ListHostContractsRequest_SelectState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &ListHostContractsRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.GenerateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadyForChallengeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadyForChallengeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadyForChallengeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceRepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceRepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceRepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.ResponseTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGuard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGuard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGuard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGuard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGuard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGuard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGuard = fmt.Errorf("proto: unexpected end of group")
)
