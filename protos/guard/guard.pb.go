// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protos/guard/guard.proto

package guard

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ResponseCode int32

const (
	ResponseCode_SUCCESS                ResponseCode = 0
	ResponseCode_SIGNATURE_FORMAT_ERROR ResponseCode = 1
	ResponseCode_COMPUTE_ADDRESS_ERROR  ResponseCode = 2
	ResponseCode_OTHER_ERROR            ResponseCode = 20
)

var ResponseCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "SIGNATURE_FORMAT_ERROR",
	2:  "COMPUTE_ADDRESS_ERROR",
	20: "OTHER_ERROR",
}

var ResponseCode_value = map[string]int32{
	"SUCCESS":                0,
	"SIGNATURE_FORMAT_ERROR": 1,
	"COMPUTE_ADDRESS_ERROR":  2,
	"OTHER_ERROR":            20,
}

func (x ResponseCode) String() string {
	return proto.EnumName(ResponseCode_name, int32(x))
}

func (ResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}

type ContractMeta_Schedule int32

const (
	ContractMeta_MONTHLY   ContractMeta_Schedule = 0
	ContractMeta_QUARTERLY ContractMeta_Schedule = 1
	ContractMeta_ANNUALLY  ContractMeta_Schedule = 2
)

var ContractMeta_Schedule_name = map[int32]string{
	0: "MONTHLY",
	1: "QUARTERLY",
	2: "ANNUALLY",
}

var ContractMeta_Schedule_value = map[string]int32{
	"MONTHLY":   0,
	"QUARTERLY": 1,
	"ANNUALLY":  2,
}

func (x ContractMeta_Schedule) String() string {
	return proto.EnumName(ContractMeta_Schedule_name, int32(x))
}

func (ContractMeta_Schedule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{1, 0}
}

type Contract_ContractState int32

const (
	Contract_DRAFT    Contract_ContractState = 0
	Contract_SIGNED   Contract_ContractState = 1
	Contract_UPLOADED Contract_ContractState = 2
	Contract_LOST     Contract_ContractState = 3
	Contract_CANCELED Contract_ContractState = 4
	Contract_CLOSED   Contract_ContractState = 5
)

var Contract_ContractState_name = map[int32]string{
	0: "DRAFT",
	1: "SIGNED",
	2: "UPLOADED",
	3: "LOST",
	4: "CANCELED",
	5: "CLOSED",
}

var Contract_ContractState_value = map[string]int32{
	"DRAFT":    0,
	"SIGNED":   1,
	"UPLOADED": 2,
	"LOST":     3,
	"CANCELED": 4,
	"CLOSED":   5,
}

func (x Contract_ContractState) String() string {
	return proto.EnumName(Contract_ContractState_name, int32(x))
}

func (Contract_ContractState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{2, 0}
}

type FileStoreStatus_MetaState int32

const (
	FileStoreStatus_DRAFT        FileStoreStatus_MetaState = 0
	FileStoreStatus_UPLOADING    FileStoreStatus_MetaState = 1
	FileStoreStatus_RUNNING      FileStoreStatus_MetaState = 2
	FileStoreStatus_PARTIAL_LOST FileStoreStatus_MetaState = 3
	FileStoreStatus_LOST         FileStoreStatus_MetaState = 4
	FileStoreStatus_DONE         FileStoreStatus_MetaState = 5
)

var FileStoreStatus_MetaState_name = map[int32]string{
	0: "DRAFT",
	1: "UPLOADING",
	2: "RUNNING",
	3: "PARTIAL_LOST",
	4: "LOST",
	5: "DONE",
}

var FileStoreStatus_MetaState_value = map[string]int32{
	"DRAFT":        0,
	"UPLOADING":    1,
	"RUNNING":      2,
	"PARTIAL_LOST": 3,
	"LOST":         4,
	"DONE":         5,
}

func (x FileStoreStatus_MetaState) String() string {
	return proto.EnumName(FileStoreStatus_MetaState_name, int32(x))
}

func (FileStoreStatus_MetaState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{4, 0}
}

type Log struct {
	ChangeTime           *types.Timestamp `protobuf:"bytes,1,opt,name=change_time,json=changeTime,proto3" json:"change_time,omitempty"`
	ChangeOriginator     []byte           `protobuf:"bytes,2,opt,name=change_originator,json=changeOriginator,proto3" json:"change_originator,omitempty"`
	Change               []byte           `protobuf:"bytes,3,opt,name=change,proto3" json:"change,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

func (m *Log) GetChangeTime() *types.Timestamp {
	if m != nil {
		return m.ChangeTime
	}
	return nil
}

func (m *Log) GetChangeOriginator() []byte {
	if m != nil {
		return m.ChangeOriginator
	}
	return nil
}

func (m *Log) GetChange() []byte {
	if m != nil {
		return m.Change
	}
	return nil
}

func (*Log) XXX_MessageName() string {
	return "guard.Log"
}

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
//ContractMeta is the information which will not be changed after proposal
//Contract technically is the contract execution record, it contains the contractMeta and state information
type ContractMeta struct {
	//Contract proposed by renter, will not be changed after renter proposed
	ContractId           []byte                `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	RenterAddress        []byte                `protobuf:"bytes,2,opt,name=renter_address,json=renterAddress,proto3" json:"renter_address,omitempty"`
	HostAddress          []byte                `protobuf:"bytes,3,opt,name=host_address,json=hostAddress,proto3" json:"host_address,omitempty"`
	ShardHash            []byte                `protobuf:"bytes,4,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty"`
	ShardIndex           int32                 `protobuf:"varint,5,opt,name=shard_index,json=shardIndex,proto3" json:"shard_index,omitempty"`
	ShardFileSize        int64                 `protobuf:"varint,6,opt,name=shard_file_size,json=shardFileSize,proto3" json:"shard_file_size,omitempty"`
	FileHash             []byte                `protobuf:"bytes,7,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	RentStart            *time.Time            `protobuf:"bytes,8,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start,omitempty"`
	RentEnd              *time.Time            `protobuf:"bytes,9,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end,omitempty"`
	GuardAddress         []byte                `protobuf:"bytes,10,opt,name=guard_address,json=guardAddress,proto3" json:"guard_address,omitempty"`
	EscrowAddress        []byte                `protobuf:"bytes,11,opt,name=escrow_address,json=escrowAddress,proto3" json:"escrow_address,omitempty"`
	Price                int64                 `protobuf:"varint,12,opt,name=price,proto3" json:"price,omitempty"`
	Amount               int64                 `protobuf:"varint,13,opt,name=amount,proto3" json:"amount,omitempty"`
	CollateralAmount     int64                 `protobuf:"varint,14,opt,name=collateral_amount,json=collateralAmount,proto3" json:"collateral_amount,omitempty"`
	PayoutSchedule       ContractMeta_Schedule `protobuf:"varint,15,opt,name=payout_schedule,json=payoutSchedule,proto3,enum=guard.ContractMeta_Schedule" json:"payout_schedule,omitempty"`
	NumPayouts           int32                 `protobuf:"varint,16,opt,name=num_payouts,json=numPayouts,proto3" json:"num_payouts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ContractMeta) Reset()         { *m = ContractMeta{} }
func (m *ContractMeta) String() string { return proto.CompactTextString(m) }
func (*ContractMeta) ProtoMessage()    {}
func (*ContractMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{1}
}
func (m *ContractMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractMeta.Merge(m, src)
}
func (m *ContractMeta) XXX_Size() int {
	return m.Size()
}
func (m *ContractMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ContractMeta proto.InternalMessageInfo

func (m *ContractMeta) GetContractId() []byte {
	if m != nil {
		return m.ContractId
	}
	return nil
}

func (m *ContractMeta) GetRenterAddress() []byte {
	if m != nil {
		return m.RenterAddress
	}
	return nil
}

func (m *ContractMeta) GetHostAddress() []byte {
	if m != nil {
		return m.HostAddress
	}
	return nil
}

func (m *ContractMeta) GetShardHash() []byte {
	if m != nil {
		return m.ShardHash
	}
	return nil
}

func (m *ContractMeta) GetShardIndex() int32 {
	if m != nil {
		return m.ShardIndex
	}
	return 0
}

func (m *ContractMeta) GetShardFileSize() int64 {
	if m != nil {
		return m.ShardFileSize
	}
	return 0
}

func (m *ContractMeta) GetFileHash() []byte {
	if m != nil {
		return m.FileHash
	}
	return nil
}

func (m *ContractMeta) GetRentStart() *time.Time {
	if m != nil {
		return m.RentStart
	}
	return nil
}

func (m *ContractMeta) GetRentEnd() *time.Time {
	if m != nil {
		return m.RentEnd
	}
	return nil
}

func (m *ContractMeta) GetGuardAddress() []byte {
	if m != nil {
		return m.GuardAddress
	}
	return nil
}

func (m *ContractMeta) GetEscrowAddress() []byte {
	if m != nil {
		return m.EscrowAddress
	}
	return nil
}

func (m *ContractMeta) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ContractMeta) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ContractMeta) GetCollateralAmount() int64 {
	if m != nil {
		return m.CollateralAmount
	}
	return 0
}

func (m *ContractMeta) GetPayoutSchedule() ContractMeta_Schedule {
	if m != nil {
		return m.PayoutSchedule
	}
	return ContractMeta_MONTHLY
}

func (m *ContractMeta) GetNumPayouts() int32 {
	if m != nil {
		return m.NumPayouts
	}
	return 0
}

func (*ContractMeta) XXX_MessageName() string {
	return "guard.ContractMeta"
}

type Contract struct {
	//the contract executor record, changed frequently after proposal
	Contract             *ContractMeta          `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty"`
	State                Contract_ContractState `protobuf:"varint,2,opt,name=state,proto3,enum=guard.Contract_ContractState" json:"state,omitempty"`
	RenterSignature      []byte                 `protobuf:"bytes,3,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty"`
	HostSignature        []byte                 `protobuf:"bytes,4,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty"`
	EscrowSignedTime     *time.Time             `protobuf:"bytes,5,opt,name=escrow_signed_time,json=escrowSignedTime,proto3,stdtime" json:"escrow_signed_time,omitempty"`
	EscrowSignature      []byte                 `protobuf:"bytes,6,opt,name=escrow_signature,json=escrowSignature,proto3" json:"escrow_signature,omitempty"`
	ChangeLog            []*Log                 `protobuf:"bytes,7,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty"`
	LastModifyTime       *time.Time             `protobuf:"bytes,8,opt,name=last_modify_time,json=lastModifyTime,proto3,stdtime" json:"last_modify_time,omitempty"`
	GuardSignature       []byte                 `protobuf:"bytes,9,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{2}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetContract() *ContractMeta {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *Contract) GetState() Contract_ContractState {
	if m != nil {
		return m.State
	}
	return Contract_DRAFT
}

func (m *Contract) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *Contract) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (m *Contract) GetEscrowSignedTime() *time.Time {
	if m != nil {
		return m.EscrowSignedTime
	}
	return nil
}

func (m *Contract) GetEscrowSignature() []byte {
	if m != nil {
		return m.EscrowSignature
	}
	return nil
}

func (m *Contract) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *Contract) GetLastModifyTime() *time.Time {
	if m != nil {
		return m.LastModifyTime
	}
	return nil
}

func (m *Contract) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (*Contract) XXX_MessageName() string {
	return "guard.Contract"
}

type FileStoreMeta struct {
	//file store meta prepared by renter, will not changed after proposal
	RenterAddress        []byte     `protobuf:"bytes,1,opt,name=renter_address,json=renterAddress,proto3" json:"renter_address,omitempty"`
	FileHash             []byte     `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	FileSize             int64      `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	RentStart            *time.Time `protobuf:"bytes,4,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start,omitempty"`
	RentEnd              *time.Time `protobuf:"bytes,5,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end,omitempty"`
	CheckFrequency       int32      `protobuf:"varint,6,opt,name=check_frequency,json=checkFrequency,proto3" json:"check_frequency,omitempty"`
	GuardFee             int64      `protobuf:"varint,7,opt,name=guard_fee,json=guardFee,proto3" json:"guard_fee,omitempty"`
	EscrowFee            int64      `protobuf:"varint,8,opt,name=escrow_fee,json=escrowFee,proto3" json:"escrow_fee,omitempty"`
	ShardCount           int32      `protobuf:"varint,9,opt,name=shard_count,json=shardCount,proto3" json:"shard_count,omitempty"`
	MinimumShards        int32      `protobuf:"varint,10,opt,name=minimum_shards,json=minimumShards,proto3" json:"minimum_shards,omitempty"`
	RecoverThreshold     int32      `protobuf:"varint,11,opt,name=recover_threshold,json=recoverThreshold,proto3" json:"recover_threshold,omitempty"`
	EscrowAddress        []byte     `protobuf:"bytes,12,opt,name=escrow_address,json=escrowAddress,proto3" json:"escrow_address,omitempty"`
	GuardAddress         []byte     `protobuf:"bytes,13,opt,name=guard_address,json=guardAddress,proto3" json:"guard_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *FileStoreMeta) Reset()         { *m = FileStoreMeta{} }
func (m *FileStoreMeta) String() string { return proto.CompactTextString(m) }
func (*FileStoreMeta) ProtoMessage()    {}
func (*FileStoreMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{3}
}
func (m *FileStoreMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreMeta.Merge(m, src)
}
func (m *FileStoreMeta) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreMeta proto.InternalMessageInfo

func (m *FileStoreMeta) GetRenterAddress() []byte {
	if m != nil {
		return m.RenterAddress
	}
	return nil
}

func (m *FileStoreMeta) GetFileHash() []byte {
	if m != nil {
		return m.FileHash
	}
	return nil
}

func (m *FileStoreMeta) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *FileStoreMeta) GetRentStart() *time.Time {
	if m != nil {
		return m.RentStart
	}
	return nil
}

func (m *FileStoreMeta) GetRentEnd() *time.Time {
	if m != nil {
		return m.RentEnd
	}
	return nil
}

func (m *FileStoreMeta) GetCheckFrequency() int32 {
	if m != nil {
		return m.CheckFrequency
	}
	return 0
}

func (m *FileStoreMeta) GetGuardFee() int64 {
	if m != nil {
		return m.GuardFee
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowFee() int64 {
	if m != nil {
		return m.EscrowFee
	}
	return 0
}

func (m *FileStoreMeta) GetShardCount() int32 {
	if m != nil {
		return m.ShardCount
	}
	return 0
}

func (m *FileStoreMeta) GetMinimumShards() int32 {
	if m != nil {
		return m.MinimumShards
	}
	return 0
}

func (m *FileStoreMeta) GetRecoverThreshold() int32 {
	if m != nil {
		return m.RecoverThreshold
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowAddress() []byte {
	if m != nil {
		return m.EscrowAddress
	}
	return nil
}

func (m *FileStoreMeta) GetGuardAddress() []byte {
	if m != nil {
		return m.GuardAddress
	}
	return nil
}

func (*FileStoreMeta) XXX_MessageName() string {
	return "guard.FileStoreMeta"
}

type FileStoreStatus struct {
	FileStoreMeta        *FileStoreMeta            `protobuf:"bytes,1,opt,name=file_store_meta,json=fileStoreMeta,proto3" json:"file_store_meta,omitempty"`
	State                FileStoreStatus_MetaState `protobuf:"varint,2,opt,name=state,proto3,enum=guard.FileStoreStatus_MetaState" json:"state,omitempty"`
	Contracts            []*Contract               `protobuf:"bytes,3,rep,name=contracts,proto3" json:"contracts,omitempty"`
	RenterSignature      []byte                    `protobuf:"bytes,4,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty"`
	GuardReceiveTime     *time.Time                `protobuf:"bytes,5,opt,name=guard_receive_time,json=guardReceiveTime,proto3,stdtime" json:"guard_receive_time,omitempty"`
	ChangeLog            []*Log                    `protobuf:"bytes,6,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty"`
	CurentTime           *time.Time                `protobuf:"bytes,7,opt,name=curent_time,json=curentTime,proto3,stdtime" json:"curent_time,omitempty"`
	GuardSignature       []byte                    `protobuf:"bytes,8,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *FileStoreStatus) Reset()         { *m = FileStoreStatus{} }
func (m *FileStoreStatus) String() string { return proto.CompactTextString(m) }
func (*FileStoreStatus) ProtoMessage()    {}
func (*FileStoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{4}
}
func (m *FileStoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreStatus.Merge(m, src)
}
func (m *FileStoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreStatus proto.InternalMessageInfo

func (m *FileStoreStatus) GetFileStoreMeta() *FileStoreMeta {
	if m != nil {
		return m.FileStoreMeta
	}
	return nil
}

func (m *FileStoreStatus) GetState() FileStoreStatus_MetaState {
	if m != nil {
		return m.State
	}
	return FileStoreStatus_DRAFT
}

func (m *FileStoreStatus) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func (m *FileStoreStatus) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *FileStoreStatus) GetGuardReceiveTime() *time.Time {
	if m != nil {
		return m.GuardReceiveTime
	}
	return nil
}

func (m *FileStoreStatus) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *FileStoreStatus) GetCurentTime() *time.Time {
	if m != nil {
		return m.CurentTime
	}
	return nil
}

func (m *FileStoreStatus) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (*FileStoreStatus) XXX_MessageName() string {
	return "guard.FileStoreStatus"
}

type ChallengeQuestion struct {
	ShardHash            []byte   `protobuf:"bytes,1,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty"`
	HostAddress          []byte   `protobuf:"bytes,2,opt,name=host_address,json=hostAddress,proto3" json:"host_address,omitempty"`
	ChunkIndex           int32    `protobuf:"varint,3,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty"`
	RandomNonce          []byte   `protobuf:"bytes,4,opt,name=random_nonce,json=randomNonce,proto3" json:"random_nonce,omitempty"`
	ExpectAnswer         []byte   `protobuf:"bytes,5,opt,name=expect_answer,json=expectAnswer,proto3" json:"expect_answer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChallengeQuestion) Reset()         { *m = ChallengeQuestion{} }
func (m *ChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*ChallengeQuestion) ProtoMessage()    {}
func (*ChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{5}
}
func (m *ChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeQuestion.Merge(m, src)
}
func (m *ChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeQuestion proto.InternalMessageInfo

func (m *ChallengeQuestion) GetShardHash() []byte {
	if m != nil {
		return m.ShardHash
	}
	return nil
}

func (m *ChallengeQuestion) GetHostAddress() []byte {
	if m != nil {
		return m.HostAddress
	}
	return nil
}

func (m *ChallengeQuestion) GetChunkIndex() int32 {
	if m != nil {
		return m.ChunkIndex
	}
	return 0
}

func (m *ChallengeQuestion) GetRandomNonce() []byte {
	if m != nil {
		return m.RandomNonce
	}
	return nil
}

func (m *ChallengeQuestion) GetExpectAnswer() []byte {
	if m != nil {
		return m.ExpectAnswer
	}
	return nil
}

func (*ChallengeQuestion) XXX_MessageName() string {
	return "guard.ChallengeQuestion"
}

type ProofOfReplicateChallenge struct {
	Question             *ChallengeQuestion `protobuf:"bytes,1,opt,name=question,proto3" json:"question,omitempty"`
	ChallengeTime        *time.Time         `protobuf:"bytes,2,opt,name=challenge_time,json=challengeTime,proto3,stdtime" json:"challenge_time,omitempty"`
	GuardAddress         []byte             `protobuf:"bytes,3,opt,name=guard_address,json=guardAddress,proto3" json:"guard_address,omitempty"`
	GuardSignature       []byte             `protobuf:"bytes,4,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty"`
	HostAnswer           []byte             `protobuf:"bytes,5,opt,name=host_answer,json=hostAnswer,proto3" json:"host_answer,omitempty"`
	HostSignTime         *time.Time         `protobuf:"bytes,6,opt,name=host_sign_time,json=hostSignTime,proto3,stdtime" json:"host_sign_time,omitempty"`
	HostSignature        []byte             `protobuf:"bytes,7,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ProofOfReplicateChallenge) Reset()         { *m = ProofOfReplicateChallenge{} }
func (m *ProofOfReplicateChallenge) String() string { return proto.CompactTextString(m) }
func (*ProofOfReplicateChallenge) ProtoMessage()    {}
func (*ProofOfReplicateChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{6}
}
func (m *ProofOfReplicateChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofOfReplicateChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofOfReplicateChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofOfReplicateChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofOfReplicateChallenge.Merge(m, src)
}
func (m *ProofOfReplicateChallenge) XXX_Size() int {
	return m.Size()
}
func (m *ProofOfReplicateChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofOfReplicateChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_ProofOfReplicateChallenge proto.InternalMessageInfo

func (m *ProofOfReplicateChallenge) GetQuestion() *ChallengeQuestion {
	if m != nil {
		return m.Question
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetChallengeTime() *time.Time {
	if m != nil {
		return m.ChallengeTime
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetGuardAddress() []byte {
	if m != nil {
		return m.GuardAddress
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetHostAnswer() []byte {
	if m != nil {
		return m.HostAnswer
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetHostSignTime() *time.Time {
	if m != nil {
		return m.HostSignTime
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (*ProofOfReplicateChallenge) XXX_MessageName() string {
	return "guard.ProofOfReplicateChallenge"
}

type FileChallengeQuestions struct {
	FileHash             []byte                     `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	ShardQuestions       []*ShardChallengeQuestions `protobuf:"bytes,2,rep,name=shard_questions,json=shardQuestions,proto3" json:"shard_questions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *FileChallengeQuestions) Reset()         { *m = FileChallengeQuestions{} }
func (m *FileChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*FileChallengeQuestions) ProtoMessage()    {}
func (*FileChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{7}
}
func (m *FileChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChallengeQuestions.Merge(m, src)
}
func (m *FileChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *FileChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_FileChallengeQuestions proto.InternalMessageInfo

func (m *FileChallengeQuestions) GetFileHash() []byte {
	if m != nil {
		return m.FileHash
	}
	return nil
}

func (m *FileChallengeQuestions) GetShardQuestions() []*ShardChallengeQuestions {
	if m != nil {
		return m.ShardQuestions
	}
	return nil
}

func (*FileChallengeQuestions) XXX_MessageName() string {
	return "guard.FileChallengeQuestions"
}

type ShardChallengeQuestions struct {
	FileHash             []byte               `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	ShardHash            []byte               `protobuf:"bytes,2,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty"`
	PreparerAddress      []byte               `protobuf:"bytes,3,opt,name=preparer_address,json=preparerAddress,proto3" json:"preparer_address,omitempty"`
	QuestionCount        int32                `protobuf:"varint,4,opt,name=question_count,json=questionCount,proto3" json:"question_count,omitempty"`
	Questions            []*ChallengeQuestion `protobuf:"bytes,5,rep,name=questions,proto3" json:"questions,omitempty"`
	PrepareTime          *time.Time           `protobuf:"bytes,6,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time,omitempty"`
	PreparerSignature    []byte               `protobuf:"bytes,7,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ShardChallengeQuestions) Reset()         { *m = ShardChallengeQuestions{} }
func (m *ShardChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*ShardChallengeQuestions) ProtoMessage()    {}
func (*ShardChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{8}
}
func (m *ShardChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardChallengeQuestions.Merge(m, src)
}
func (m *ShardChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *ShardChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_ShardChallengeQuestions proto.InternalMessageInfo

func (m *ShardChallengeQuestions) GetFileHash() []byte {
	if m != nil {
		return m.FileHash
	}
	return nil
}

func (m *ShardChallengeQuestions) GetShardHash() []byte {
	if m != nil {
		return m.ShardHash
	}
	return nil
}

func (m *ShardChallengeQuestions) GetPreparerAddress() []byte {
	if m != nil {
		return m.PreparerAddress
	}
	return nil
}

func (m *ShardChallengeQuestions) GetQuestionCount() int32 {
	if m != nil {
		return m.QuestionCount
	}
	return 0
}

func (m *ShardChallengeQuestions) GetQuestions() []*ChallengeQuestion {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *ShardChallengeQuestions) GetPrepareTime() *time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return nil
}

func (m *ShardChallengeQuestions) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (*ShardChallengeQuestions) XXX_MessageName() string {
	return "guard.ShardChallengeQuestions"
}

type CheckFileStoreMetaRequest struct {
	FileHash             []byte     `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	RenterAddress        []byte     `protobuf:"bytes,2,opt,name=renter_address,json=renterAddress,proto3" json:"renter_address,omitempty"`
	RequesterAddress     []byte     `protobuf:"bytes,3,opt,name=requester_address,json=requesterAddress,proto3" json:"requester_address,omitempty"`
	RequestTime          *time.Time `protobuf:"bytes,4,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time,omitempty"`
	Signature            []byte     `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CheckFileStoreMetaRequest) Reset()         { *m = CheckFileStoreMetaRequest{} }
func (m *CheckFileStoreMetaRequest) String() string { return proto.CompactTextString(m) }
func (*CheckFileStoreMetaRequest) ProtoMessage()    {}
func (*CheckFileStoreMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{9}
}
func (m *CheckFileStoreMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckFileStoreMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckFileStoreMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckFileStoreMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckFileStoreMetaRequest.Merge(m, src)
}
func (m *CheckFileStoreMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckFileStoreMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckFileStoreMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckFileStoreMetaRequest proto.InternalMessageInfo

func (m *CheckFileStoreMetaRequest) GetFileHash() []byte {
	if m != nil {
		return m.FileHash
	}
	return nil
}

func (m *CheckFileStoreMetaRequest) GetRenterAddress() []byte {
	if m != nil {
		return m.RenterAddress
	}
	return nil
}

func (m *CheckFileStoreMetaRequest) GetRequesterAddress() []byte {
	if m != nil {
		return m.RequesterAddress
	}
	return nil
}

func (m *CheckFileStoreMetaRequest) GetRequestTime() *time.Time {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *CheckFileStoreMetaRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*CheckFileStoreMetaRequest) XXX_MessageName() string {
	return "guard.CheckFileStoreMetaRequest"
}

type Result struct {
	Code                 ResponseCode `protobuf:"varint,1,opt,name=code,proto3,enum=guard.ResponseCode" json:"code,omitempty"`
	Message              string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	ResponseTime         *time.Time   `protobuf:"bytes,3,opt,name=response_time,json=responseTime,proto3,stdtime" json:"response_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{10}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetCode() ResponseCode {
	if m != nil {
		return m.Code
	}
	return ResponseCode_SUCCESS
}

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Result) GetResponseTime() *time.Time {
	if m != nil {
		return m.ResponseTime
	}
	return nil
}

func (*Result) XXX_MessageName() string {
	return "guard.Result"
}
func init() {
	proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	golang_proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	golang_proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	golang_proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	golang_proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	proto.RegisterType((*Log)(nil), "guard.Log")
	golang_proto.RegisterType((*Log)(nil), "guard.Log")
	proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	golang_proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	proto.RegisterType((*Contract)(nil), "guard.Contract")
	golang_proto.RegisterType((*Contract)(nil), "guard.Contract")
	proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	golang_proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	golang_proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	golang_proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	golang_proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	golang_proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	golang_proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	golang_proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	proto.RegisterType((*Result)(nil), "guard.Result")
	golang_proto.RegisterType((*Result)(nil), "guard.Result")
}

func init() { proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }
func init() { golang_proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }

var fileDescriptor_ad5b6eccdc9ebee8 = []byte{
	// 1710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcd, 0x6f, 0xdb, 0xc8,
	0x15, 0x0f, 0xf5, 0x61, 0x4b, 0x4f, 0xa4, 0xc4, 0xcc, 0xa6, 0x29, 0xe3, 0x6e, 0x1c, 0xaf, 0x8a,
	0x34, 0x4e, 0x8b, 0x28, 0x80, 0x77, 0xb1, 0x97, 0x4d, 0x51, 0x28, 0x12, 0xed, 0xb8, 0x90, 0x25,
	0xef, 0x50, 0x06, 0x9a, 0x5e, 0x08, 0x9a, 0x1c, 0x49, 0xc4, 0x4a, 0xa4, 0x96, 0x1f, 0xd9, 0xcd,
	0x1e, 0x7a, 0xed, 0xb5, 0x28, 0x7a, 0xe8, 0xb9, 0xff, 0x44, 0x6f, 0x45, 0x7b, 0xcb, 0xb1, 0x40,
	0x8f, 0x3d, 0xb4, 0x48, 0xfe, 0x80, 0x5e, 0x7b, 0x2c, 0xe6, 0xcd, 0x90, 0xfa, 0x74, 0xaa, 0x60,
	0x2f, 0x86, 0xe6, 0x37, 0xbf, 0xa7, 0x79, 0xf3, 0x3e, 0x7e, 0x6f, 0x64, 0x30, 0xe6, 0x51, 0x98,
	0x84, 0xf1, 0xd3, 0x71, 0xea, 0x44, 0x9e, 0xf8, 0xdb, 0x42, 0x88, 0x94, 0x71, 0x71, 0xf0, 0x64,
	0xec, 0x27, 0x93, 0xf4, 0xba, 0xe5, 0x86, 0xb3, 0xa7, 0xe3, 0x70, 0x1c, 0x3e, 0xc5, 0xdd, 0xeb,
	0x74, 0x84, 0x2b, 0x5c, 0xe0, 0x27, 0x61, 0x75, 0xf0, 0x60, 0x1c, 0x86, 0xe3, 0x29, 0x5b, 0xb0,
	0x12, 0x7f, 0xc6, 0xe2, 0xc4, 0x99, 0xcd, 0x05, 0xa1, 0xf9, 0x5b, 0x05, 0x8a, 0xbd, 0x70, 0x4c,
	0xbe, 0x80, 0x9a, 0x3b, 0x71, 0x82, 0x31, 0xb3, 0x39, 0xc3, 0x50, 0x8e, 0x94, 0xe3, 0xda, 0xc9,
	0x41, 0x4b, 0x98, 0xb7, 0x32, 0xf3, 0xd6, 0x30, 0x33, 0xa7, 0x20, 0xe8, 0x1c, 0x20, 0x3f, 0x83,
	0xdb, 0xd2, 0x38, 0x8c, 0xfc, 0xb1, 0x1f, 0x38, 0x49, 0x18, 0x19, 0x85, 0x23, 0xe5, 0x58, 0xa5,
	0xba, 0xd8, 0x18, 0xe4, 0x38, 0xb9, 0x0b, 0x7b, 0x02, 0x33, 0x8a, 0xc8, 0x90, 0xab, 0xe6, 0xdf,
	0xca, 0xa0, 0x76, 0xc2, 0x20, 0x89, 0x1c, 0x37, 0xb9, 0x60, 0x89, 0x43, 0x1e, 0x40, 0xcd, 0x95,
	0x6b, 0xdb, 0xf7, 0xd0, 0x25, 0x95, 0x42, 0x06, 0x9d, 0x7b, 0xe4, 0x21, 0xd4, 0x23, 0x16, 0x24,
	0x2c, 0xb2, 0x1d, 0xcf, 0x8b, 0x58, 0x1c, 0xcb, 0x33, 0x35, 0x81, 0xb6, 0x05, 0x48, 0x3e, 0x01,
	0x75, 0x12, 0xc6, 0x49, 0x4e, 0x12, 0xc7, 0xd6, 0x38, 0x96, 0x51, 0xee, 0x03, 0xc4, 0x13, 0x27,
	0xf2, 0xec, 0x89, 0x13, 0x4f, 0x8c, 0x12, 0x12, 0xaa, 0x88, 0xbc, 0x70, 0xe2, 0x09, 0xf7, 0x44,
	0x6c, 0xfb, 0x81, 0xc7, 0xbe, 0x35, 0xca, 0x47, 0xca, 0x71, 0x99, 0x0a, 0x8b, 0x73, 0x8e, 0x90,
	0x9f, 0x40, 0x43, 0x10, 0x46, 0xfe, 0x94, 0xd9, 0xb1, 0xff, 0x1d, 0x33, 0xf6, 0x8e, 0x94, 0xe3,
	0x22, 0xd5, 0x10, 0x3e, 0xf5, 0xa7, 0xcc, 0xf2, 0xbf, 0x63, 0xe4, 0x47, 0x50, 0x45, 0x06, 0x1e,
	0xb3, 0x8f, 0xc7, 0x54, 0x38, 0x80, 0xa7, 0xfc, 0x02, 0x80, 0x3b, 0x6e, 0xc7, 0x89, 0x13, 0x25,
	0x46, 0xe5, 0xff, 0x65, 0xe0, 0x79, 0xe9, 0x77, 0xff, 0x7a, 0xa0, 0xd0, 0x2a, 0xb7, 0xb1, 0xb8,
	0x09, 0xf9, 0x02, 0x2a, 0xf8, 0x05, 0x2c, 0xf0, 0x8c, 0xea, 0x8e, 0xe6, 0xfb, 0xdc, 0xc2, 0x0c,
	0x3c, 0xf2, 0x63, 0xd0, 0xb0, 0xc2, 0xf2, 0x30, 0x01, 0xba, 0xa7, 0x22, 0x98, 0xc5, 0xe9, 0x21,
	0xd4, 0x59, 0xec, 0x46, 0xe1, 0x37, 0x39, 0xab, 0x26, 0x22, 0x2e, 0xd0, 0x8c, 0x76, 0x07, 0xca,
	0xf3, 0xc8, 0x77, 0x99, 0xa1, 0x62, 0x10, 0xc4, 0x82, 0x27, 0xde, 0x99, 0x85, 0x69, 0x90, 0x18,
	0x1a, 0xc2, 0x72, 0x85, 0xd5, 0x13, 0x4e, 0xa7, 0x4e, 0xc2, 0x22, 0x67, 0x6a, 0x4b, 0x4a, 0x1d,
	0x29, 0xfa, 0x62, 0xa3, 0x2d, 0xc8, 0x26, 0x34, 0xe6, 0xce, 0xeb, 0x30, 0x4d, 0xec, 0xd8, 0x9d,
	0x30, 0x2f, 0x9d, 0x32, 0xa3, 0x71, 0xa4, 0x1c, 0xd7, 0x4f, 0x3e, 0x6e, 0x89, 0x6e, 0x59, 0x2e,
	0xa1, 0x96, 0x25, 0x39, 0xb4, 0x2e, 0x8c, 0xb2, 0x35, 0xcf, 0x68, 0x90, 0xce, 0x6c, 0x81, 0xc6,
	0x86, 0x2e, 0x32, 0x1a, 0xa4, 0xb3, 0x4b, 0x81, 0x34, 0x3f, 0x83, 0x4a, 0x4e, 0xae, 0xc1, 0xfe,
	0xc5, 0xa0, 0x3f, 0x7c, 0xd1, 0x7b, 0xa9, 0xdf, 0x22, 0x1a, 0x54, 0xbf, 0xbc, 0x6a, 0xd3, 0xa1,
	0x49, 0x7b, 0x2f, 0x75, 0x85, 0xa8, 0x50, 0x69, 0xf7, 0xfb, 0x57, 0xed, 0x5e, 0xef, 0xa5, 0x5e,
	0x68, 0xfe, 0xb9, 0x04, 0x95, 0xcc, 0x01, 0xf2, 0x14, 0x2a, 0x59, 0xb1, 0xca, 0x7e, 0xfa, 0x68,
	0x8b, 0x8f, 0x34, 0x27, 0x91, 0x4f, 0xa1, 0x1c, 0x27, 0x4e, 0xc2, 0xb0, 0x8c, 0xeb, 0x27, 0xf7,
	0xd7, 0xd8, 0xf9, 0x07, 0x8b, 0x93, 0xa8, 0xe0, 0x92, 0xc7, 0xa0, 0xcb, 0x26, 0x88, 0xfd, 0x71,
	0xe0, 0x24, 0x69, 0x94, 0x35, 0x56, 0x43, 0xe0, 0x56, 0x06, 0xf3, 0xec, 0x61, 0x23, 0x2c, 0x88,
	0xa2, 0xd2, 0x35, 0x8e, 0x2e, 0x68, 0x7d, 0x20, 0x32, 0xc9, 0x9c, 0xc8, 0x3c, 0xa1, 0x08, 0xe5,
	0x1d, 0x0b, 0x4a, 0x17, 0xb6, 0x16, 0x9a, 0xa2, 0x3a, 0x3c, 0x06, 0x7d, 0xe9, 0xfb, 0xc4, 0xc1,
	0x7b, 0xc2, 0xc3, 0x05, 0x57, 0x1c, 0xfd, 0x18, 0xa4, 0xac, 0xd8, 0xd3, 0x70, 0x6c, 0xec, 0x1f,
	0x15, 0x8f, 0x6b, 0x27, 0x20, 0xc3, 0xd0, 0x0b, 0xc7, 0xb4, 0x2a, 0x76, 0xb9, 0x60, 0xfd, 0x12,
	0xf4, 0xa9, 0x13, 0x27, 0xf6, 0x2c, 0xf4, 0xfc, 0xd1, 0x6b, 0xe1, 0xe3, 0xae, 0x3d, 0x53, 0xe7,
	0x96, 0x17, 0x68, 0x88, 0x1e, 0x3e, 0x82, 0x86, 0xa8, 0xfd, 0x85, 0x83, 0x55, 0x74, 0xb0, 0x8e,
	0x70, 0xee, 0x5f, 0xf3, 0x57, 0xa0, 0xad, 0x24, 0x81, 0x54, 0xa1, 0xdc, 0xa5, 0xed, 0xd3, 0xa1,
	0x7e, 0x8b, 0x00, 0xec, 0x59, 0xe7, 0x67, 0x7d, 0xb3, 0x2b, 0xaa, 0xe2, 0xea, 0xb2, 0x37, 0x68,
	0x77, 0xcd, 0xae, 0x5e, 0x20, 0x15, 0x28, 0xf5, 0x06, 0xd6, 0x50, 0x2f, 0x72, 0xbc, 0xd3, 0xee,
	0x77, 0xcc, 0x9e, 0xd9, 0xd5, 0x4b, 0xdc, 0xa2, 0xd3, 0x1b, 0x58, 0x66, 0x57, 0x2f, 0x37, 0xff,
	0x50, 0x02, 0x0d, 0x65, 0x22, 0x09, 0x23, 0x86, 0xf2, 0xb7, 0xa9, 0x6e, 0xca, 0x36, 0x75, 0x5b,
	0x91, 0x94, 0xc2, 0x9a, 0xa4, 0x64, 0x9b, 0xa8, 0x48, 0x45, 0x6c, 0x29, 0xdc, 0x44, 0x31, 0x5a,
	0xd5, 0x9b, 0xd2, 0xf7, 0xd3, 0x9b, 0xf2, 0x87, 0xea, 0xcd, 0x23, 0x68, 0xb8, 0x13, 0xe6, 0x7e,
	0x65, 0x8f, 0x22, 0xf6, 0x75, 0xca, 0x02, 0xf7, 0x35, 0x16, 0x45, 0x99, 0xd6, 0x11, 0x3e, 0xcd,
	0x50, 0x7e, 0x07, 0x91, 0x9c, 0x11, 0x63, 0xa8, 0x99, 0x45, 0x5a, 0x41, 0xe0, 0x94, 0x31, 0x2e,
	0xdc, 0xb2, 0xb6, 0xf8, 0x6e, 0x05, 0x77, 0xab, 0x02, 0xe1, 0xdb, 0xb9, 0x70, 0xbb, 0x28, 0x2a,
	0xd5, 0x25, 0xe1, 0xee, 0xa0, 0x9c, 0x3c, 0x84, 0xfa, 0xcc, 0x0f, 0xfc, 0x59, 0x3a, 0xb3, 0x11,
	0x15, 0xb2, 0x57, 0xa6, 0x9a, 0x44, 0x2d, 0x04, 0xb9, 0x44, 0x45, 0xcc, 0x0d, 0x5f, 0xb1, 0xc8,
	0x4e, 0x26, 0x11, 0x8b, 0x27, 0xe1, 0xd4, 0x43, 0xe9, 0x2b, 0x53, 0x5d, 0x6e, 0x0c, 0x33, 0x7c,
	0x8b, 0x48, 0xaa, 0xdb, 0x44, 0x72, 0x43, 0x70, 0xb5, 0x4d, 0xc1, 0x6d, 0xfe, 0xa9, 0x04, 0x8d,
	0xbc, 0x2c, 0x78, 0xc9, 0xa5, 0x31, 0x79, 0x06, 0x0d, 0x91, 0x54, 0x8e, 0xd9, 0x33, 0x96, 0x38,
	0x52, 0x5e, 0xee, 0xc8, 0x4e, 0x59, 0xa9, 0x23, 0xaa, 0x8d, 0x56, 0xca, 0xea, 0xf3, 0x55, 0x91,
	0x39, 0x5a, 0xb7, 0x11, 0x87, 0xb4, 0x38, 0x77, 0x45, 0x67, 0x9e, 0x40, 0x35, 0x13, 0x2a, 0x3e,
	0x42, 0x79, 0x67, 0x36, 0xd6, 0x04, 0x8a, 0x2e, 0x18, 0x5b, 0x65, 0xa9, 0xb4, 0x5d, 0x96, 0xfa,
	0x40, 0x44, 0x20, 0x22, 0xe6, 0x32, 0xff, 0x15, 0xfb, 0x40, 0xbd, 0x41, 0x5b, 0x2a, 0x4c, 0xa5,
	0xde, 0x2c, 0x8b, 0xc8, 0xde, 0xfb, 0x44, 0xa4, 0x0d, 0x35, 0x37, 0xc5, 0x1a, 0xc6, 0x33, 0xf7,
	0x77, 0x3c, 0x13, 0x84, 0xd1, 0x4d, 0xda, 0x51, 0xb9, 0x41, 0x3b, 0xaa, 0x79, 0x50, 0x97, 0x75,
	0x43, 0x83, 0xaa, 0xd0, 0x8a, 0xf3, 0xfe, 0x99, 0xae, 0xf0, 0x61, 0x43, 0xaf, 0xfa, 0x7d, 0xbe,
	0x28, 0x10, 0x1d, 0xd4, 0xcb, 0x36, 0x1d, 0x9e, 0xb7, 0x7b, 0xb6, 0x54, 0x90, 0x4c, 0x4b, 0x4a,
	0xfc, 0x53, 0x77, 0xd0, 0x37, 0xf5, 0x72, 0xf3, 0x2f, 0x0a, 0xdc, 0xee, 0x4c, 0x9c, 0xe9, 0x94,
	0x05, 0x63, 0xf6, 0x65, 0xca, 0xe2, 0xc4, 0x0f, 0x83, 0xb5, 0x37, 0x8d, 0xb2, 0xfe, 0xa6, 0x59,
	0x7f, 0x15, 0x15, 0x36, 0x5f, 0x45, 0xfc, 0x01, 0x36, 0x49, 0x83, 0xaf, 0xe4, 0xb3, 0xa7, 0x28,
	0xba, 0x07, 0x21, 0xf1, 0xec, 0xf9, 0x04, 0xd4, 0xc8, 0x09, 0xbc, 0x70, 0x66, 0x07, 0x61, 0xe0,
	0x66, 0x09, 0xae, 0x09, 0xac, 0xcf, 0x21, 0x5e, 0xe5, 0xec, 0xdb, 0x39, 0x73, 0x13, 0xdb, 0x09,
	0xe2, 0x6f, 0x58, 0x84, 0x79, 0x55, 0xa9, 0x2a, 0xc0, 0x36, 0x62, 0xcd, 0xff, 0x16, 0xe0, 0xde,
	0x65, 0x14, 0x86, 0xa3, 0xc1, 0x88, 0xb2, 0xf9, 0xd4, 0x77, 0x9d, 0x84, 0xe5, 0x17, 0x22, 0x9f,
	0x41, 0xe5, 0x6b, 0x79, 0x29, 0x59, 0xe8, 0x46, 0x56, 0x78, 0xeb, 0x97, 0xa6, 0x39, 0x93, 0x9c,
	0x41, 0xdd, 0xcd, 0xb6, 0x45, 0x76, 0x0b, 0x3b, 0x66, 0x57, 0xcb, 0xed, 0x30, 0xc1, 0x1b, 0x7d,
	0x5a, 0xdc, 0xf2, 0x30, 0xda, 0x52, 0x05, 0xa5, 0x6d, 0x55, 0xc0, 0x63, 0x2a, 0xc2, 0xbe, 0x1c,
	0x0d, 0xc0, 0xa8, 0x23, 0x42, 0x4e, 0x97, 0x86, 0xb4, 0xf0, 0x7b, 0x6f, 0x47, 0xbf, 0xd5, 0x6c,
	0x8c, 0xa3, 0xdb, 0x9b, 0xc3, 0x7e, 0x7f, 0xcb, 0xb0, 0x6f, 0xfe, 0x06, 0xee, 0xf2, 0xd6, 0xdf,
	0x88, 0xe4, 0xda, 0x60, 0x51, 0xd6, 0x06, 0xcb, 0x59, 0xf6, 0xe0, 0xcd, 0xe2, 0xcd, 0x0b, 0x88,
	0x37, 0xda, 0xa1, 0x4c, 0x0d, 0x0a, 0xe7, 0xe6, 0xb7, 0xd2, 0x3a, 0x9a, 0xe5, 0xeb, 0xe6, 0x3f,
	0x0a, 0xf0, 0xc3, 0x1b, 0xb8, 0xef, 0xf7, 0x60, 0xb5, 0xbc, 0x0b, 0xeb, 0xe5, 0xfd, 0x18, 0xf4,
	0x79, 0xc4, 0xe6, 0x4e, 0xb4, 0x34, 0x3f, 0xe5, 0xb3, 0x28, 0xc3, 0x97, 0x1e, 0xb5, 0xd9, 0x2d,
	0xe4, 0x9c, 0x28, 0x89, 0x19, 0x90, 0xa1, 0x62, 0x54, 0x7c, 0x0e, 0xd5, 0xc5, 0x65, 0xcb, 0x78,
	0xd9, 0x9b, 0xeb, 0x70, 0x41, 0x25, 0x1d, 0x50, 0xe5, 0x89, 0x1f, 0x96, 0xce, 0x9a, 0xb4, 0xc2,
	0x6c, 0x3e, 0x01, 0x92, 0x5f, 0x67, 0x3d, 0xa3, 0xb7, 0xb3, 0x9d, 0x45, 0x56, 0xff, 0xa3, 0xc0,
	0xbd, 0x0e, 0x8e, 0xd1, 0x95, 0x51, 0xc0, 0xd0, 0xab, 0xf7, 0xc7, 0x75, 0xc7, 0x1f, 0x55, 0x38,
	0x11, 0xf1, 0xeb, 0x36, 0x02, 0xac, 0xe7, 0x1b, 0x19, 0xb9, 0x03, 0xaa, 0xc4, 0x44, 0x08, 0x76,
	0x7d, 0x6b, 0xd4, 0xa4, 0x15, 0x86, 0xe0, 0x63, 0xa8, 0x2e, 0x6e, 0x5e, 0x96, 0xf9, 0xce, 0x6f,
	0xfc, 0x7b, 0x05, 0xf6, 0x28, 0x8b, 0xd3, 0x69, 0x42, 0x1e, 0x41, 0xc9, 0x0d, 0x3d, 0xf1, 0x1b,
	0xb6, 0x9e, 0xbf, 0xb9, 0x29, 0x8b, 0xe7, 0x61, 0x10, 0xb3, 0x4e, 0xe8, 0x31, 0x8a, 0x04, 0x62,
	0xc0, 0xfe, 0x8c, 0xc5, 0xb1, 0x33, 0x16, 0xda, 0x50, 0xa5, 0xd9, 0x92, 0x98, 0xa0, 0x45, 0x92,
	0x2f, 0x3c, 0x2e, 0xee, 0xda, 0x83, 0x99, 0x19, 0xdf, 0xf8, 0xa9, 0x0b, 0xea, 0xf2, 0xb1, 0x5c,
	0xdb, 0xad, 0xab, 0x4e, 0xc7, 0xb4, 0x2c, 0xfd, 0x16, 0x39, 0x80, 0xbb, 0xfc, 0xbd, 0xd8, 0x1e,
	0x5e, 0x51, 0xd3, 0x3e, 0x1d, 0xd0, 0x8b, 0xf6, 0xd0, 0x36, 0x29, 0x1d, 0x50, 0x5d, 0x21, 0xf7,
	0xe0, 0x07, 0x9d, 0xc1, 0xc5, 0xe5, 0xd5, 0xd0, 0xb4, 0xdb, 0xdd, 0x2e, 0x35, 0x2d, 0x4b, 0x6e,
	0x15, 0x48, 0x03, 0x6a, 0x83, 0xe1, 0x0b, 0x93, 0x4a, 0xe0, 0xce, 0xc9, 0x3f, 0x15, 0x50, 0xcf,
	0x50, 0x64, 0x58, 0xf4, 0x8a, 0xff, 0xce, 0x7a, 0x06, 0x1f, 0x59, 0xe9, 0xf5, 0xcc, 0x4f, 0x56,
	0xdf, 0x93, 0x77, 0xb7, 0x4f, 0xfa, 0x03, 0x6d, 0x11, 0x20, 0x1e, 0xbd, 0x9f, 0x83, 0x66, 0xb1,
	0x60, 0xd1, 0xa1, 0xe4, 0xfe, 0x92, 0xdd, 0x66, 0x93, 0xae, 0x9b, 0xf7, 0x81, 0x6c, 0x16, 0x1e,
	0x39, 0xca, 0x1b, 0xe5, 0x86, 0x9a, 0x3c, 0xb8, 0xc1, 0xbb, 0xe7, 0xcf, 0xde, 0xbc, 0x3d, 0x54,
	0xfe, 0xfe, 0xf6, 0x50, 0xf9, 0xf7, 0xdb, 0x43, 0xe5, 0x8f, 0xef, 0x0e, 0x95, 0xbf, 0xbe, 0x3b,
	0x54, 0xde, 0xbc, 0x3b, 0x54, 0x40, 0xf3, 0xc3, 0xd6, 0x75, 0x32, 0x8a, 0x85, 0xe1, 0x73, 0xc0,
	0x18, 0x5c, 0xf2, 0xc4, 0x5c, 0x2a, 0xbf, 0x16, 0xff, 0x2d, 0xb9, 0xde, 0xc3, 0x44, 0x7d, 0xfa,
	0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x39, 0x27, 0xca, 0x25, 0x57, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GuardServiceClient is the client API for GuardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GuardServiceClient interface {
	SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error)
	SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error)
	CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error)
}

type guardServiceClient struct {
	cc *grpc.ClientConn
}

func NewGuardServiceClient(cc *grpc.ClientConn) GuardServiceClient {
	return &guardServiceClient{cc}
}

func (c *guardServiceClient) SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SubmitFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SendQuestions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error) {
	out := new(FileStoreStatus)
	err := c.cc.Invoke(ctx, "/guard.GuardService/CheckFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuardServiceServer is the server API for GuardService service.
type GuardServiceServer interface {
	SubmitFileStoreMeta(context.Context, *FileStoreStatus) (*Result, error)
	SendQuestions(context.Context, *FileChallengeQuestions) (*Result, error)
	CheckFileStoreMeta(context.Context, *CheckFileStoreMetaRequest) (*FileStoreStatus, error)
}

// UnimplementedGuardServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGuardServiceServer struct {
}

func (*UnimplementedGuardServiceServer) SubmitFileStoreMeta(ctx context.Context, req *FileStoreStatus) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitFileStoreMeta not implemented")
}
func (*UnimplementedGuardServiceServer) SendQuestions(ctx context.Context, req *FileChallengeQuestions) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendQuestions not implemented")
}
func (*UnimplementedGuardServiceServer) CheckFileStoreMeta(ctx context.Context, req *CheckFileStoreMetaRequest) (*FileStoreStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckFileStoreMeta not implemented")
}

func RegisterGuardServiceServer(s *grpc.Server, srv GuardServiceServer) {
	s.RegisterService(&_GuardService_serviceDesc, srv)
}

func _GuardService_SubmitFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileStoreStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SubmitFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, req.(*FileStoreStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_SendQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileChallengeQuestions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SendQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SendQuestions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SendQuestions(ctx, req.(*FileChallengeQuestions))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_CheckFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFileStoreMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/CheckFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, req.(*CheckFileStoreMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GuardService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "guard.GuardService",
	HandlerType: (*GuardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitFileStoreMeta",
			Handler:    _GuardService_SubmitFileStoreMeta_Handler,
		},
		{
			MethodName: "SendQuestions",
			Handler:    _GuardService_SendQuestions_Handler,
		},
		{
			MethodName: "CheckFileStoreMeta",
			Handler:    _GuardService_CheckFileStoreMeta_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/guard/guard.proto",
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Change) > 0 {
		i -= len(m.Change)
		copy(dAtA[i:], m.Change)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Change)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChangeOriginator) > 0 {
		i -= len(m.ChangeOriginator)
		copy(dAtA[i:], m.ChangeOriginator)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ChangeOriginator)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChangeTime != nil {
		{
			size, err := m.ChangeTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumPayouts != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NumPayouts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PayoutSchedule != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.PayoutSchedule))
		i--
		dAtA[i] = 0x78
	}
	if m.CollateralAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CollateralAmount))
		i--
		dAtA[i] = 0x70
	}
	if m.Amount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x68
	}
	if m.Price != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x60
	}
	if len(m.EscrowAddress) > 0 {
		i -= len(m.EscrowAddress)
		copy(dAtA[i:], m.EscrowAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowAddress)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.GuardAddress) > 0 {
		i -= len(m.GuardAddress)
		copy(dAtA[i:], m.GuardAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardAddress)))
		i--
		dAtA[i] = 0x52
	}
	if m.RentEnd != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.RentEnd, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentEnd):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintGuard(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x4a
	}
	if m.RentStart != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.RentStart, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentStart):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintGuard(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x42
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardFileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardFileSize))
		i--
		dAtA[i] = 0x30
	}
	if m.ShardIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HostAddress) > 0 {
		i -= len(m.HostAddress)
		copy(dAtA[i:], m.HostAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterAddress) > 0 {
		i -= len(m.RenterAddress)
		copy(dAtA[i:], m.RenterAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x4a
	}
	if m.LastModifyTime != nil {
		n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastModifyTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastModifyTime):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintGuard(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.EscrowSignature) > 0 {
		i -= len(m.EscrowSignature)
		copy(dAtA[i:], m.EscrowSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowSignature)))
		i--
		dAtA[i] = 0x32
	}
	if m.EscrowSignedTime != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EscrowSignedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EscrowSignedTime):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintGuard(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Contract != nil {
		{
			size, err := m.Contract.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStoreMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GuardAddress) > 0 {
		i -= len(m.GuardAddress)
		copy(dAtA[i:], m.GuardAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EscrowAddress) > 0 {
		i -= len(m.EscrowAddress)
		copy(dAtA[i:], m.EscrowAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowAddress)))
		i--
		dAtA[i] = 0x62
	}
	if m.RecoverThreshold != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RecoverThreshold))
		i--
		dAtA[i] = 0x58
	}
	if m.MinimumShards != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.MinimumShards))
		i--
		dAtA[i] = 0x50
	}
	if m.ShardCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardCount))
		i--
		dAtA[i] = 0x48
	}
	if m.EscrowFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.EscrowFee))
		i--
		dAtA[i] = 0x40
	}
	if m.GuardFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.GuardFee))
		i--
		dAtA[i] = 0x38
	}
	if m.CheckFrequency != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CheckFrequency))
		i--
		dAtA[i] = 0x30
	}
	if m.RentEnd != nil {
		n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.RentEnd, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentEnd):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintGuard(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x2a
	}
	if m.RentStart != nil {
		n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.RentStart, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentStart):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintGuard(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x22
	}
	if m.FileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterAddress) > 0 {
		i -= len(m.RenterAddress)
		copy(dAtA[i:], m.RenterAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x42
	}
	if m.CurentTime != nil {
		n9, err9 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CurentTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CurentTime):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintGuard(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.GuardReceiveTime != nil {
		n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.GuardReceiveTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.GuardReceiveTime):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintGuard(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.FileStoreMeta != nil {
		{
			size, err := m.FileStoreMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExpectAnswer) > 0 {
		i -= len(m.ExpectAnswer)
		copy(dAtA[i:], m.ExpectAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ExpectAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RandomNonce) > 0 {
		i -= len(m.RandomNonce)
		copy(dAtA[i:], m.RandomNonce)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RandomNonce)))
		i--
		dAtA[i] = 0x22
	}
	if m.ChunkIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChunkIndex))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HostAddress) > 0 {
		i -= len(m.HostAddress)
		copy(dAtA[i:], m.HostAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProofOfReplicateChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofOfReplicateChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofOfReplicateChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.HostSignTime != nil {
		n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.HostSignTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.HostSignTime):])
		if err12 != nil {
			return 0, err12
		}
		i -= n12
		i = encodeVarintGuard(dAtA, i, uint64(n12))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HostAnswer) > 0 {
		i -= len(m.HostAnswer)
		copy(dAtA[i:], m.HostAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GuardAddress) > 0 {
		i -= len(m.GuardAddress)
		copy(dAtA[i:], m.GuardAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ChallengeTime != nil {
		n13, err13 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ChallengeTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ChallengeTime):])
		if err13 != nil {
			return 0, err13
		}
		i -= n13
		i = encodeVarintGuard(dAtA, i, uint64(n13))
		i--
		dAtA[i] = 0x12
	}
	if m.Question != nil {
		{
			size, err := m.Question.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardQuestions) > 0 {
		for iNdEx := len(m.ShardQuestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardQuestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PrepareTime != nil {
		n15, err15 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.PrepareTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.PrepareTime):])
		if err15 != nil {
			return 0, err15
		}
		i -= n15
		i = encodeVarintGuard(dAtA, i, uint64(n15))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Questions) > 0 {
		for iNdEx := len(m.Questions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Questions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.QuestionCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.QuestionCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PreparerAddress) > 0 {
		i -= len(m.PreparerAddress)
		copy(dAtA[i:], m.PreparerAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckFileStoreMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckFileStoreMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckFileStoreMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RequestTime != nil {
		n16, err16 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.RequestTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.RequestTime):])
		if err16 != nil {
			return 0, err16
		}
		i -= n16
		i = encodeVarintGuard(dAtA, i, uint64(n16))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RequesterAddress) > 0 {
		i -= len(m.RequesterAddress)
		copy(dAtA[i:], m.RequesterAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterAddress) > 0 {
		i -= len(m.RenterAddress)
		copy(dAtA[i:], m.RenterAddress)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResponseTime != nil {
		n17, err17 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ResponseTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ResponseTime):])
		if err17 != nil {
			return 0, err17
		}
		i -= n17
		i = encodeVarintGuard(dAtA, i, uint64(n17))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGuard(dAtA []byte, offset int, v uint64) int {
	offset -= sovGuard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeTime != nil {
		l = m.ChangeTime.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ChangeOriginator)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Change)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContractMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ShardIndex != 0 {
		n += 1 + sovGuard(uint64(m.ShardIndex))
	}
	if m.ShardFileSize != 0 {
		n += 1 + sovGuard(uint64(m.ShardFileSize))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RentStart != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentStart)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RentEnd != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentEnd)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.EscrowAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovGuard(uint64(m.Price))
	}
	if m.Amount != 0 {
		n += 1 + sovGuard(uint64(m.Amount))
	}
	if m.CollateralAmount != 0 {
		n += 1 + sovGuard(uint64(m.CollateralAmount))
	}
	if m.PayoutSchedule != 0 {
		n += 1 + sovGuard(uint64(m.PayoutSchedule))
	}
	if m.NumPayouts != 0 {
		n += 2 + sovGuard(uint64(m.NumPayouts))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Contract != nil {
		l = m.Contract.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.EscrowSignedTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EscrowSignedTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.EscrowSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.LastModifyTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastModifyTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovGuard(uint64(m.FileSize))
	}
	if m.RentStart != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentStart)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RentEnd != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.RentEnd)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.CheckFrequency != 0 {
		n += 1 + sovGuard(uint64(m.CheckFrequency))
	}
	if m.GuardFee != 0 {
		n += 1 + sovGuard(uint64(m.GuardFee))
	}
	if m.EscrowFee != 0 {
		n += 1 + sovGuard(uint64(m.EscrowFee))
	}
	if m.ShardCount != 0 {
		n += 1 + sovGuard(uint64(m.ShardCount))
	}
	if m.MinimumShards != 0 {
		n += 1 + sovGuard(uint64(m.MinimumShards))
	}
	if m.RecoverThreshold != 0 {
		n += 1 + sovGuard(uint64(m.RecoverThreshold))
	}
	l = len(m.EscrowAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileStoreMeta != nil {
		l = m.FileStoreMeta.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.GuardReceiveTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.GuardReceiveTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.CurentTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CurentTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ChunkIndex != 0 {
		n += 1 + sovGuard(uint64(m.ChunkIndex))
	}
	l = len(m.RandomNonce)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ExpectAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProofOfReplicateChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Question != nil {
		l = m.Question.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ChallengeTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ChallengeTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.HostSignTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.HostSignTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ShardQuestions) > 0 {
		for _, e := range m.ShardQuestions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.QuestionCount != 0 {
		n += 1 + sovGuard(uint64(m.QuestionCount))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.PrepareTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.PrepareTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckFileStoreMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterAddress)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RequestTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.RequestTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGuard(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ResponseTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ResponseTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGuard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGuard(x uint64) (n int) {
	return sovGuard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeTime == nil {
				m.ChangeTime = &types.Timestamp{}
			}
			if err := m.ChangeTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeOriginator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeOriginator = append(m.ChangeOriginator[:0], dAtA[iNdEx:postIndex]...)
			if m.ChangeOriginator == nil {
				m.ChangeOriginator = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Change = append(m.Change[:0], dAtA[iNdEx:postIndex]...)
			if m.Change == nil {
				m.Change = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = append(m.ContractId[:0], dAtA[iNdEx:postIndex]...)
			if m.ContractId == nil {
				m.ContractId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterAddress = append(m.RenterAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterAddress == nil {
				m.RenterAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = append(m.HostAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.HostAddress == nil {
				m.HostAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = append(m.ShardHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ShardHash == nil {
				m.ShardHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardIndex", wireType)
			}
			m.ShardIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardFileSize", wireType)
			}
			m.ShardFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = append(m.FileHash[:0], dAtA[iNdEx:postIndex]...)
			if m.FileHash == nil {
				m.FileHash = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RentStart == nil {
				m.RentStart = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RentEnd == nil {
				m.RentEnd = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardAddress = append(m.GuardAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardAddress == nil {
				m.GuardAddress = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowAddress = append(m.EscrowAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowAddress == nil {
				m.EscrowAddress = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAmount", wireType)
			}
			m.CollateralAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutSchedule", wireType)
			}
			m.PayoutSchedule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayoutSchedule |= ContractMeta_Schedule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPayouts", wireType)
			}
			m.NumPayouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPayouts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contract == nil {
				m.Contract = &ContractMeta{}
			}
			if err := m.Contract.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Contract_ContractState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EscrowSignedTime == nil {
				m.EscrowSignedTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EscrowSignedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowSignature = append(m.EscrowSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowSignature == nil {
				m.EscrowSignature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifyTime == nil {
				m.LastModifyTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastModifyTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterAddress = append(m.RenterAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterAddress == nil {
				m.RenterAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = append(m.FileHash[:0], dAtA[iNdEx:postIndex]...)
			if m.FileHash == nil {
				m.FileHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RentStart == nil {
				m.RentStart = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RentEnd == nil {
				m.RentEnd = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFrequency", wireType)
			}
			m.CheckFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckFrequency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardFee", wireType)
			}
			m.GuardFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowFee", wireType)
			}
			m.EscrowFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EscrowFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCount", wireType)
			}
			m.ShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumShards", wireType)
			}
			m.MinimumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumShards |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverThreshold", wireType)
			}
			m.RecoverThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowAddress = append(m.EscrowAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowAddress == nil {
				m.EscrowAddress = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardAddress = append(m.GuardAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardAddress == nil {
				m.GuardAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStoreMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileStoreMeta == nil {
				m.FileStoreMeta = &FileStoreMeta{}
			}
			if err := m.FileStoreMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FileStoreStatus_MetaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardReceiveTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuardReceiveTime == nil {
				m.GuardReceiveTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.GuardReceiveTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurentTime == nil {
				m.CurentTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CurentTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = append(m.ShardHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ShardHash == nil {
				m.ShardHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = append(m.HostAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.HostAddress == nil {
				m.HostAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkIndex", wireType)
			}
			m.ChunkIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandomNonce = append(m.RandomNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.RandomNonce == nil {
				m.RandomNonce = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectAnswer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectAnswer = append(m.ExpectAnswer[:0], dAtA[iNdEx:postIndex]...)
			if m.ExpectAnswer == nil {
				m.ExpectAnswer = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofOfReplicateChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Question == nil {
				m.Question = &ChallengeQuestion{}
			}
			if err := m.Question.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeTime == nil {
				m.ChallengeTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardAddress = append(m.GuardAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardAddress == nil {
				m.GuardAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAnswer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAnswer = append(m.HostAnswer[:0], dAtA[iNdEx:postIndex]...)
			if m.HostAnswer == nil {
				m.HostAnswer = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostSignTime == nil {
				m.HostSignTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.HostSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = append(m.FileHash[:0], dAtA[iNdEx:postIndex]...)
			if m.FileHash == nil {
				m.FileHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardQuestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardQuestions = append(m.ShardQuestions, &ShardChallengeQuestions{})
			if err := m.ShardQuestions[len(m.ShardQuestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = append(m.FileHash[:0], dAtA[iNdEx:postIndex]...)
			if m.FileHash == nil {
				m.FileHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = append(m.ShardHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ShardHash == nil {
				m.ShardHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerAddress = append(m.PreparerAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerAddress == nil {
				m.PreparerAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionCount", wireType)
			}
			m.QuestionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuestionCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &ChallengeQuestion{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepareTime == nil {
				m.PrepareTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckFileStoreMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = append(m.FileHash[:0], dAtA[iNdEx:postIndex]...)
			if m.FileHash == nil {
				m.FileHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterAddress = append(m.RenterAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterAddress == nil {
				m.RenterAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterAddress = append(m.RequesterAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RequesterAddress == nil {
				m.RequesterAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestTime == nil {
				m.RequestTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseTime == nil {
				m.ResponseTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ResponseTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGuard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGuard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGuard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGuard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGuard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGuard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGuard = fmt.Errorf("proto: unexpected end of group")
)
