// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protos/guard/guard.proto

package guard

import (
	context "context"
	fmt "fmt"
	proto "github.com/bittorrent/protobuf/proto"
	github_com_bittorrent_protobuf_types "github.com/bittorrent/protobuf/types"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/tron-us/protobuf/gogoproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ResponseCode int32

const (
	ResponseCode_SUCCESS                ResponseCode = 0
	ResponseCode_SIGNATURE_FORMAT_ERROR ResponseCode = 1
	ResponseCode_COMPUTE_ADDRESS_ERROR  ResponseCode = 2
	ResponseCode_OTHER_ERROR            ResponseCode = 20
)

var ResponseCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "SIGNATURE_FORMAT_ERROR",
	2:  "COMPUTE_ADDRESS_ERROR",
	20: "OTHER_ERROR",
}

var ResponseCode_value = map[string]int32{
	"SUCCESS":                0,
	"SIGNATURE_FORMAT_ERROR": 1,
	"COMPUTE_ADDRESS_ERROR":  2,
	"OTHER_ERROR":            20,
}

func (x ResponseCode) String() string {
	return proto.EnumName(ResponseCode_name, int32(x))
}

func (ResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}

type ContractMeta_Schedule int32

const (
	ContractMeta_MONTHLY   ContractMeta_Schedule = 0
	ContractMeta_QUARTERLY ContractMeta_Schedule = 1
	ContractMeta_ANNUALLY  ContractMeta_Schedule = 2
)

var ContractMeta_Schedule_name = map[int32]string{
	0: "MONTHLY",
	1: "QUARTERLY",
	2: "ANNUALLY",
}

var ContractMeta_Schedule_value = map[string]int32{
	"MONTHLY":   0,
	"QUARTERLY": 1,
	"ANNUALLY":  2,
}

func (x ContractMeta_Schedule) String() string {
	return proto.EnumName(ContractMeta_Schedule_name, int32(x))
}

func (ContractMeta_Schedule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{6, 0}
}

type Contract_ContractState int32

const (
	Contract_DRAFT             Contract_ContractState = 0
	Contract_SIGNED            Contract_ContractState = 1
	Contract_UPLOADED          Contract_ContractState = 2
	Contract_LOST              Contract_ContractState = 3
	Contract_CANCELED          Contract_ContractState = 4
	Contract_CLOSED            Contract_ContractState = 5
	Contract_RENEWED           Contract_ContractState = 6
	Contract_OBSOLETE          Contract_ContractState = 7
	Contract_WARN              Contract_ContractState = 8
	Contract_DRAFT_WARN        Contract_ContractState = 9
	Contract_READY_CHALLENGE   Contract_ContractState = 10
	Contract_RECREATED         Contract_ContractState = 11
	Contract_REQUEST_CHALLENGE Contract_ContractState = 12
)

var Contract_ContractState_name = map[int32]string{
	0:  "DRAFT",
	1:  "SIGNED",
	2:  "UPLOADED",
	3:  "LOST",
	4:  "CANCELED",
	5:  "CLOSED",
	6:  "RENEWED",
	7:  "OBSOLETE",
	8:  "WARN",
	9:  "DRAFT_WARN",
	10: "READY_CHALLENGE",
	11: "RECREATED",
	12: "REQUEST_CHALLENGE",
}

var Contract_ContractState_value = map[string]int32{
	"DRAFT":             0,
	"SIGNED":            1,
	"UPLOADED":          2,
	"LOST":              3,
	"CANCELED":          4,
	"CLOSED":            5,
	"RENEWED":           6,
	"OBSOLETE":          7,
	"WARN":              8,
	"DRAFT_WARN":        9,
	"READY_CHALLENGE":   10,
	"RECREATED":         11,
	"REQUEST_CHALLENGE": 12,
}

func (x Contract_ContractState) String() string {
	return proto.EnumName(Contract_ContractState_name, int32(x))
}

func (Contract_ContractState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{7, 0}
}

type FileStoreStatus_MetaState int32

const (
	FileStoreStatus_DRAFT        FileStoreStatus_MetaState = 0
	FileStoreStatus_UPLOADING    FileStoreStatus_MetaState = 1
	FileStoreStatus_RUNNING      FileStoreStatus_MetaState = 2
	FileStoreStatus_PARTIAL_LOST FileStoreStatus_MetaState = 3
	FileStoreStatus_LOST         FileStoreStatus_MetaState = 4
	FileStoreStatus_DONE         FileStoreStatus_MetaState = 5
	FileStoreStatus_CANCELED     FileStoreStatus_MetaState = 6
	FileStoreStatus_RECREATED    FileStoreStatus_MetaState = 7
)

var FileStoreStatus_MetaState_name = map[int32]string{
	0: "DRAFT",
	1: "UPLOADING",
	2: "RUNNING",
	3: "PARTIAL_LOST",
	4: "LOST",
	5: "DONE",
	6: "CANCELED",
	7: "RECREATED",
}

var FileStoreStatus_MetaState_value = map[string]int32{
	"DRAFT":        0,
	"UPLOADING":    1,
	"RUNNING":      2,
	"PARTIAL_LOST": 3,
	"LOST":         4,
	"DONE":         5,
	"CANCELED":     6,
	"RECREATED":    7,
}

func (x FileStoreStatus_MetaState) String() string {
	return proto.EnumName(FileStoreStatus_MetaState_name, int32(x))
}

func (FileStoreStatus_MetaState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{10, 0}
}

type FileStoreStatus_RentalState int32

const (
	FileStoreStatus_NEW         FileStoreStatus_RentalState = 0
	FileStoreStatus_PARTIAL_NEW FileStoreStatus_RentalState = 1
	FileStoreStatus_EXPIRED     FileStoreStatus_RentalState = 2
	FileStoreStatus_RENEW       FileStoreStatus_RentalState = 3
	FileStoreStatus_RECREATE    FileStoreStatus_RentalState = 4
)

var FileStoreStatus_RentalState_name = map[int32]string{
	0: "NEW",
	1: "PARTIAL_NEW",
	2: "EXPIRED",
	3: "RENEW",
	4: "RECREATE",
}

var FileStoreStatus_RentalState_value = map[string]int32{
	"NEW":         0,
	"PARTIAL_NEW": 1,
	"EXPIRED":     2,
	"RENEW":       3,
	"RECREATE":    4,
}

func (x FileStoreStatus_RentalState) String() string {
	return proto.EnumName(FileStoreStatus_RentalState_name, int32(x))
}

func (FileStoreStatus_RentalState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{10, 1}
}

type ListHostContractsRequest_SelectState int32

const (
	ListHostContractsRequest_ALL    ListHostContractsRequest_SelectState = 0
	ListHostContractsRequest_ACTIVE ListHostContractsRequest_SelectState = 1
	ListHostContractsRequest_CLOSED ListHostContractsRequest_SelectState = 2
)

var ListHostContractsRequest_SelectState_name = map[int32]string{
	0: "ALL",
	1: "ACTIVE",
	2: "CLOSED",
}

var ListHostContractsRequest_SelectState_value = map[string]int32{
	"ALL":    0,
	"ACTIVE": 1,
	"CLOSED": 2,
}

func (x ListHostContractsRequest_SelectState) String() string {
	return proto.EnumName(ListHostContractsRequest_SelectState_name, int32(x))
}

func (ListHostContractsRequest_SelectState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{17, 0}
}

type RepairContractResponse_ContractResponseStatus int32

const (
	RepairContractResponse_BOTH_SIGNED RepairContractResponse_ContractResponseStatus = 0
	RepairContractResponse_WAIT_LIST   RepairContractResponse_ContractResponseStatus = 1
	RepairContractResponse_REJECTED    RepairContractResponse_ContractResponseStatus = 2
)

var RepairContractResponse_ContractResponseStatus_name = map[int32]string{
	0: "BOTH_SIGNED",
	1: "WAIT_LIST",
	2: "REJECTED",
}

var RepairContractResponse_ContractResponseStatus_value = map[string]int32{
	"BOTH_SIGNED": 0,
	"WAIT_LIST":   1,
	"REJECTED":    2,
}

func (x RepairContractResponse_ContractResponseStatus) String() string {
	return proto.EnumName(RepairContractResponse_ContractResponseStatus_name, int32(x))
}

func (RepairContractResponse_ContractResponseStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{25, 0}
}

type ResponseRepairContracts_RepairStat int32

const (
	ResponseRepairContracts_CONTRACT_READY    ResponseRepairContracts_RepairStat = 0
	ResponseRepairContracts_DOWNLOAD_NOT_DONE ResponseRepairContracts_RepairStat = 1
	ResponseRepairContracts_REQUEST_AGAIN     ResponseRepairContracts_RepairStat = 2
	ResponseRepairContracts_CONTRACT_CLOSED   ResponseRepairContracts_RepairStat = 3
)

var ResponseRepairContracts_RepairStat_name = map[int32]string{
	0: "CONTRACT_READY",
	1: "DOWNLOAD_NOT_DONE",
	2: "REQUEST_AGAIN",
	3: "CONTRACT_CLOSED",
}

var ResponseRepairContracts_RepairStat_value = map[string]int32{
	"CONTRACT_READY":    0,
	"DOWNLOAD_NOT_DONE": 1,
	"REQUEST_AGAIN":     2,
	"CONTRACT_CLOSED":   3,
}

func (x ResponseRepairContracts_RepairStat) String() string {
	return proto.EnumName(ResponseRepairContracts_RepairStat_name, int32(x))
}

func (ResponseRepairContracts_RepairStat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{27, 0}
}

type CancelContractRequest_CancelReason int32

const (
	CancelContractRequest_HOST_REQUEST   CancelContractRequest_CancelReason = 0
	CancelContractRequest_DOWNLOAD_FAIL  CancelContractRequest_CancelReason = 1
	CancelContractRequest_RENTER_REQUEST CancelContractRequest_CancelReason = 2
	CancelContractRequest_OTHER          CancelContractRequest_CancelReason = 3
)

var CancelContractRequest_CancelReason_name = map[int32]string{
	0: "HOST_REQUEST",
	1: "DOWNLOAD_FAIL",
	2: "RENTER_REQUEST",
	3: "OTHER",
}

var CancelContractRequest_CancelReason_value = map[string]int32{
	"HOST_REQUEST":   0,
	"DOWNLOAD_FAIL":  1,
	"RENTER_REQUEST": 2,
	"OTHER":          3,
}

func (x CancelContractRequest_CancelReason) String() string {
	return proto.EnumName(CancelContractRequest_CancelReason_name, int32(x))
}

func (CancelContractRequest_CancelReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{28, 0}
}

type AdminQuery struct {
	RequesterPid         string    `protobuf:"bytes,1,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	QueryDate            time.Time `protobuf:"bytes,2,opt,name=query_date,json=queryDate,proto3,stdtime" json:"query_date" pg:"query_date"`
	QueryCount           int32     `protobuf:"varint,3,opt,name=query_count,json=queryCount,proto3" json:"query_count,omitempty" pg:"query_count"`
	RequestTime          time.Time `protobuf:"bytes,4,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time" pg:"request_time"`
	Signature            []byte    `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *AdminQuery) Reset()         { *m = AdminQuery{} }
func (m *AdminQuery) String() string { return proto.CompactTextString(m) }
func (*AdminQuery) ProtoMessage()    {}
func (*AdminQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}
func (m *AdminQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminQuery.Merge(m, src)
}
func (m *AdminQuery) XXX_Size() int {
	return m.Size()
}
func (m *AdminQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminQuery.DiscardUnknown(m)
}

var xxx_messageInfo_AdminQuery proto.InternalMessageInfo

func (m *AdminQuery) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *AdminQuery) GetQueryDate() time.Time {
	if m != nil {
		return m.QueryDate
	}
	return time.Time{}
}

func (m *AdminQuery) GetQueryCount() int32 {
	if m != nil {
		return m.QueryCount
	}
	return 0
}

func (m *AdminQuery) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *AdminQuery) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*AdminQuery) XXX_MessageName() string {
	return "guard.AdminQuery"
}

type DailySummary struct {
	QueryDate                time.Time `protobuf:"bytes,1,opt,name=query_date,json=queryDate,proto3,stdtime" json:"query_date" pg:"query_date"`
	ResponseTime             time.Time `protobuf:"bytes,2,opt,name=response_time,json=responseTime,proto3,stdtime" json:"response_time" pg:"response_time"`
	PreparerPid              string    `protobuf:"bytes,3,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	Signature                []byte    `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	WorkingStorageSize       int64     `protobuf:"varint,5,opt,name=working_storage_size,json=workingStorageSize,proto3" json:"working_storage_size,omitempty" pg:"working_storage_size"`
	NewContracts             int64     `protobuf:"varint,6,opt,name=new_contracts,json=newContracts,proto3" json:"new_contracts,omitempty" pg:"new_contracts"`
	NewContractsHost         int64     `protobuf:"varint,7,opt,name=new_contracts_host,json=newContractsHost,proto3" json:"new_contracts_host,omitempty" pg:"new_contracts_host"`
	NewContractsRenter       int64     `protobuf:"varint,8,opt,name=new_contracts_renter,json=newContractsRenter,proto3" json:"new_contracts_renter,omitempty" pg:"new_contracts_renter"`
	NewContractsAveragePrice int64     `protobuf:"varint,9,opt,name=new_contracts_average_price,json=newContractsAveragePrice,proto3" json:"new_contracts_average_price,omitempty" pg:"new_contracts_average_price"`
	NewFiles                 int64     `protobuf:"varint,10,opt,name=new_files,json=newFiles,proto3" json:"new_files,omitempty" pg:"new_files"`
	NewShardsSize            int64     `protobuf:"varint,11,opt,name=new_shards_size,json=newShardsSize,proto3" json:"new_shards_size,omitempty" pg:"new_shards_size"`
	XXX_NoUnkeyedLiteral     struct{}  `json:"-" pg:"-"`
	XXX_unrecognized         []byte    `json:"-" pg:"-"`
	XXX_sizecache            int32     `json:"-" pg:"-"`
}

func (m *DailySummary) Reset()         { *m = DailySummary{} }
func (m *DailySummary) String() string { return proto.CompactTextString(m) }
func (*DailySummary) ProtoMessage()    {}
func (*DailySummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{1}
}
func (m *DailySummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailySummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailySummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DailySummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailySummary.Merge(m, src)
}
func (m *DailySummary) XXX_Size() int {
	return m.Size()
}
func (m *DailySummary) XXX_DiscardUnknown() {
	xxx_messageInfo_DailySummary.DiscardUnknown(m)
}

var xxx_messageInfo_DailySummary proto.InternalMessageInfo

func (m *DailySummary) GetQueryDate() time.Time {
	if m != nil {
		return m.QueryDate
	}
	return time.Time{}
}

func (m *DailySummary) GetResponseTime() time.Time {
	if m != nil {
		return m.ResponseTime
	}
	return time.Time{}
}

func (m *DailySummary) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *DailySummary) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DailySummary) GetWorkingStorageSize() int64 {
	if m != nil {
		return m.WorkingStorageSize
	}
	return 0
}

func (m *DailySummary) GetNewContracts() int64 {
	if m != nil {
		return m.NewContracts
	}
	return 0
}

func (m *DailySummary) GetNewContractsHost() int64 {
	if m != nil {
		return m.NewContractsHost
	}
	return 0
}

func (m *DailySummary) GetNewContractsRenter() int64 {
	if m != nil {
		return m.NewContractsRenter
	}
	return 0
}

func (m *DailySummary) GetNewContractsAveragePrice() int64 {
	if m != nil {
		return m.NewContractsAveragePrice
	}
	return 0
}

func (m *DailySummary) GetNewFiles() int64 {
	if m != nil {
		return m.NewFiles
	}
	return 0
}

func (m *DailySummary) GetNewShardsSize() int64 {
	if m != nil {
		return m.NewShardsSize
	}
	return 0
}

func (*DailySummary) XXX_MessageName() string {
	return "guard.DailySummary"
}

type HostSummary struct {
	QueryDate            time.Time     `protobuf:"bytes,1,opt,name=query_date,json=queryDate,proto3,stdtime" json:"query_date" pg:"query_date"`
	ResponseTime         time.Time     `protobuf:"bytes,2,opt,name=response_time,json=responseTime,proto3,stdtime" json:"response_time" pg:"response_time"`
	PreparerPid          string        `protobuf:"bytes,3,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	Signature            []byte        `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	RecordCount          int32         `protobuf:"varint,5,opt,name=record_count,json=recordCount,proto3" json:"record_count,omitempty" pg:"record_count"`
	Status               []*HostStatus `protobuf:"bytes,6,rep,name=status,proto3" json:"status,omitempty" pg:"status"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-" pg:"-"`
	XXX_unrecognized     []byte        `json:"-" pg:"-"`
	XXX_sizecache        int32         `json:"-" pg:"-"`
}

func (m *HostSummary) Reset()         { *m = HostSummary{} }
func (m *HostSummary) String() string { return proto.CompactTextString(m) }
func (*HostSummary) ProtoMessage()    {}
func (*HostSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{2}
}
func (m *HostSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostSummary.Merge(m, src)
}
func (m *HostSummary) XXX_Size() int {
	return m.Size()
}
func (m *HostSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_HostSummary.DiscardUnknown(m)
}

var xxx_messageInfo_HostSummary proto.InternalMessageInfo

func (m *HostSummary) GetQueryDate() time.Time {
	if m != nil {
		return m.QueryDate
	}
	return time.Time{}
}

func (m *HostSummary) GetResponseTime() time.Time {
	if m != nil {
		return m.ResponseTime
	}
	return time.Time{}
}

func (m *HostSummary) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *HostSummary) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *HostSummary) GetRecordCount() int32 {
	if m != nil {
		return m.RecordCount
	}
	return 0
}

func (m *HostSummary) GetStatus() []*HostStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (*HostSummary) XXX_MessageName() string {
	return "guard.HostSummary"
}

type TotalStateSummary struct {
	QueryDate            time.Time `protobuf:"bytes,1,opt,name=query_date,json=queryDate,proto3,stdtime" json:"query_date" pg:"query_date"`
	ResponseTime         time.Time `protobuf:"bytes,2,opt,name=response_time,json=responseTime,proto3,stdtime" json:"response_time" pg:"response_time"`
	PreparerPid          string    `protobuf:"bytes,3,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	Signature            []byte    `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	ValidContractCount   int64     `protobuf:"varint,5,opt,name=valid_contract_count,json=validContractCount,proto3" json:"valid_contract_count,omitempty" pg:"valid_contract_count"`
	ExistedShardSize     int64     `protobuf:"varint,6,opt,name=existed_shard_size,json=existedShardSize,proto3" json:"existed_shard_size,omitempty" pg:"existed_shard_size"`
	InvalidContractCount int64     `protobuf:"varint,7,opt,name=invalid_contract_count,json=invalidContractCount,proto3" json:"invalid_contract_count,omitempty" pg:"invalid_contract_count"`
	LostShardSize        int64     `protobuf:"varint,8,opt,name=lost_shard_size,json=lostShardSize,proto3" json:"lost_shard_size,omitempty" pg:"lost_shard_size"`
	TotalHostReward      int64     `protobuf:"varint,9,opt,name=total_host_reward,json=totalHostReward,proto3" json:"total_host_reward,omitempty" pg:"total_host_reward"`
	TotalWbttReward      int64     `protobuf:"varint,10,opt,name=total_wbtt_reward,json=totalWbttReward,proto3" json:"total_wbtt_reward,omitempty" pg:"total_wbtt_reward"`
	TotalTrxReward       int64     `protobuf:"varint,11,opt,name=total_trx_reward,json=totalTrxReward,proto3" json:"total_trx_reward,omitempty" pg:"total_trx_reward"`
	TotalUsddReward      int64     `protobuf:"varint,12,opt,name=total_usdd_reward,json=totalUsddReward,proto3" json:"total_usdd_reward,omitempty" pg:"total_usdd_reward"`
	TotalUsdtReward      int64     `protobuf:"varint,13,opt,name=total_usdt_reward,json=totalUsdtReward,proto3" json:"total_usdt_reward,omitempty" pg:"total_usdt_reward"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *TotalStateSummary) Reset()         { *m = TotalStateSummary{} }
func (m *TotalStateSummary) String() string { return proto.CompactTextString(m) }
func (*TotalStateSummary) ProtoMessage()    {}
func (*TotalStateSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{3}
}
func (m *TotalStateSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalStateSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalStateSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalStateSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalStateSummary.Merge(m, src)
}
func (m *TotalStateSummary) XXX_Size() int {
	return m.Size()
}
func (m *TotalStateSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalStateSummary.DiscardUnknown(m)
}

var xxx_messageInfo_TotalStateSummary proto.InternalMessageInfo

func (m *TotalStateSummary) GetQueryDate() time.Time {
	if m != nil {
		return m.QueryDate
	}
	return time.Time{}
}

func (m *TotalStateSummary) GetResponseTime() time.Time {
	if m != nil {
		return m.ResponseTime
	}
	return time.Time{}
}

func (m *TotalStateSummary) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *TotalStateSummary) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *TotalStateSummary) GetValidContractCount() int64 {
	if m != nil {
		return m.ValidContractCount
	}
	return 0
}

func (m *TotalStateSummary) GetExistedShardSize() int64 {
	if m != nil {
		return m.ExistedShardSize
	}
	return 0
}

func (m *TotalStateSummary) GetInvalidContractCount() int64 {
	if m != nil {
		return m.InvalidContractCount
	}
	return 0
}

func (m *TotalStateSummary) GetLostShardSize() int64 {
	if m != nil {
		return m.LostShardSize
	}
	return 0
}

func (m *TotalStateSummary) GetTotalHostReward() int64 {
	if m != nil {
		return m.TotalHostReward
	}
	return 0
}

func (m *TotalStateSummary) GetTotalWbttReward() int64 {
	if m != nil {
		return m.TotalWbttReward
	}
	return 0
}

func (m *TotalStateSummary) GetTotalTrxReward() int64 {
	if m != nil {
		return m.TotalTrxReward
	}
	return 0
}

func (m *TotalStateSummary) GetTotalUsddReward() int64 {
	if m != nil {
		return m.TotalUsddReward
	}
	return 0
}

func (m *TotalStateSummary) GetTotalUsdtReward() int64 {
	if m != nil {
		return m.TotalUsdtReward
	}
	return 0
}

func (*TotalStateSummary) XXX_MessageName() string {
	return "guard.TotalStateSummary"
}

type HostStatus struct {
	HostPid              string   `protobuf:"bytes,1,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	FileSize             int64    `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty" pg:"file_size"`
	WorkAmount           int64    `protobuf:"varint,3,opt,name=work_amount,json=workAmount,proto3" json:"work_amount,omitempty" pg:"work_amount"`
	RewardBtt            int64    `protobuf:"varint,4,opt,name=reward_btt,json=rewardBtt,proto3" json:"reward_btt,omitempty" pg:"reward_btt"`
	SuspectCheat         bool     `protobuf:"varint,5,opt,name=suspect_cheat,json=suspectCheat,proto3" json:"suspect_cheat,omitempty" pg:"suspect_cheat"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *HostStatus) Reset()         { *m = HostStatus{} }
func (m *HostStatus) String() string { return proto.CompactTextString(m) }
func (*HostStatus) ProtoMessage()    {}
func (*HostStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{4}
}
func (m *HostStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostStatus.Merge(m, src)
}
func (m *HostStatus) XXX_Size() int {
	return m.Size()
}
func (m *HostStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_HostStatus.DiscardUnknown(m)
}

var xxx_messageInfo_HostStatus proto.InternalMessageInfo

func (m *HostStatus) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *HostStatus) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *HostStatus) GetWorkAmount() int64 {
	if m != nil {
		return m.WorkAmount
	}
	return 0
}

func (m *HostStatus) GetRewardBtt() int64 {
	if m != nil {
		return m.RewardBtt
	}
	return 0
}

func (m *HostStatus) GetSuspectCheat() bool {
	if m != nil {
		return m.SuspectCheat
	}
	return false
}

func (*HostStatus) XXX_MessageName() string {
	return "guard.HostStatus"
}

type Log struct {
	ChangeTime           time.Time `protobuf:"bytes,1,opt,name=change_time,json=changeTime,proto3,stdtime" json:"change_time" pg:"change_time"`
	OriginatorPid        string    `protobuf:"bytes,2,opt,name=originator_pid,json=originatorPid,proto3" json:"originator_pid,omitempty" pg:"originator_pid"`
	Change               string    `protobuf:"bytes,3,opt,name=change,proto3" json:"change,omitempty" pg:"change"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{5}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

func (m *Log) GetChangeTime() time.Time {
	if m != nil {
		return m.ChangeTime
	}
	return time.Time{}
}

func (m *Log) GetOriginatorPid() string {
	if m != nil {
		return m.OriginatorPid
	}
	return ""
}

func (m *Log) GetChange() string {
	if m != nil {
		return m.Change
	}
	return ""
}

func (*Log) XXX_MessageName() string {
	return "guard.Log"
}

// the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
// contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
// ContractMeta is the information which will not be changed after proposal
// Contract technically is the contract execution record, it contains the contractMeta and state information
type ContractMeta struct {
	// Contract proposed by renter, will not be changed after renter proposed
	ContractId           string                `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty" pg:"contract_id"`
	RenterPid            string                `protobuf:"bytes,2,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	HostPid              string                `protobuf:"bytes,3,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ShardHash            string                `protobuf:"bytes,4,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	ShardIndex           int32                 `protobuf:"varint,5,opt,name=shard_index,json=shardIndex,proto3" json:"shard_index,omitempty" pg:"shard_index"`
	ShardFileSize        int64                 `protobuf:"varint,6,opt,name=shard_file_size,json=shardFileSize,proto3" json:"shard_file_size,omitempty" pg:"shard_file_size"`
	FileHash             string                `protobuf:"bytes,7,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RentStart            time.Time             `protobuf:"bytes,8,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start" pg:"rent_start"`
	RentEnd              time.Time             `protobuf:"bytes,9,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end" pg:"rent_end"`
	GuardPid             string                `protobuf:"bytes,10,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	EscrowPid            string                `protobuf:"bytes,11,opt,name=escrow_pid,json=escrowPid,proto3" json:"escrow_pid,omitempty" pg:"escrow_pid"`
	Price                int64                 `protobuf:"varint,12,opt,name=price,proto3" json:"price,omitempty" pg:"price"`
	Amount               int64                 `protobuf:"varint,13,opt,name=amount,proto3" json:"amount,omitempty" pg:"amount"`
	CollateralAmount     int64                 `protobuf:"varint,14,opt,name=collateral_amount,json=collateralAmount,proto3" json:"collateral_amount,omitempty" pg:"collateral_amount"`
	PayoutSchedule       ContractMeta_Schedule `protobuf:"varint,15,opt,name=payout_schedule,json=payoutSchedule,proto3,enum=guard.ContractMeta_Schedule" json:"payout_schedule,omitempty" pg:"payout_schedule"`
	NumPayouts           int32                 `protobuf:"varint,16,opt,name=num_payouts,json=numPayouts,proto3" json:"num_payouts,omitempty" pg:"num_payouts"`
	ContingentAmount     int64                 `protobuf:"varint,17,opt,name=contingent_amount,json=contingentAmount,proto3" json:"contingent_amount,omitempty" pg:"contingent_amount"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-" pg:"-"`
	XXX_unrecognized     []byte                `json:"-" pg:"-"`
	XXX_sizecache        int32                 `json:"-" pg:"-"`
}

func (m *ContractMeta) Reset()         { *m = ContractMeta{} }
func (m *ContractMeta) String() string { return proto.CompactTextString(m) }
func (*ContractMeta) ProtoMessage()    {}
func (*ContractMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{6}
}
func (m *ContractMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractMeta.Merge(m, src)
}
func (m *ContractMeta) XXX_Size() int {
	return m.Size()
}
func (m *ContractMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ContractMeta proto.InternalMessageInfo

func (m *ContractMeta) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *ContractMeta) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ContractMeta) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ContractMeta) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ContractMeta) GetShardIndex() int32 {
	if m != nil {
		return m.ShardIndex
	}
	return 0
}

func (m *ContractMeta) GetShardFileSize() int64 {
	if m != nil {
		return m.ShardFileSize
	}
	return 0
}

func (m *ContractMeta) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ContractMeta) GetRentStart() time.Time {
	if m != nil {
		return m.RentStart
	}
	return time.Time{}
}

func (m *ContractMeta) GetRentEnd() time.Time {
	if m != nil {
		return m.RentEnd
	}
	return time.Time{}
}

func (m *ContractMeta) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ContractMeta) GetEscrowPid() string {
	if m != nil {
		return m.EscrowPid
	}
	return ""
}

func (m *ContractMeta) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ContractMeta) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ContractMeta) GetCollateralAmount() int64 {
	if m != nil {
		return m.CollateralAmount
	}
	return 0
}

func (m *ContractMeta) GetPayoutSchedule() ContractMeta_Schedule {
	if m != nil {
		return m.PayoutSchedule
	}
	return ContractMeta_MONTHLY
}

func (m *ContractMeta) GetNumPayouts() int32 {
	if m != nil {
		return m.NumPayouts
	}
	return 0
}

func (m *ContractMeta) GetContingentAmount() int64 {
	if m != nil {
		return m.ContingentAmount
	}
	return 0
}

func (*ContractMeta) XXX_MessageName() string {
	return "guard.ContractMeta"
}

type Contract struct {
	//the contract executor record, changed frequently after proposal
	ContractMeta             `protobuf:"bytes,1,opt,name=contract,proto3,embedded=contract" json:"contract" pg:"contract"`
	State                    Contract_ContractState `protobuf:"varint,2,opt,name=state,proto3,enum=guard.Contract_ContractState" json:"state,omitempty" pg:"state"`
	RenterSignature          []byte                 `protobuf:"bytes,3,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty" pg:"renter_signature"`
	HostSignature            []byte                 `protobuf:"bytes,4,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty" pg:"host_signature"`
	EscrowSignedTime         time.Time              `protobuf:"bytes,5,opt,name=escrow_signed_time,json=escrowSignedTime,proto3,stdtime" json:"escrow_signed_time" pg:"escrow_signed_time"`
	EscrowSignature          []byte                 `protobuf:"bytes,6,opt,name=escrow_signature,json=escrowSignature,proto3" json:"escrow_signature,omitempty" pg:"escrow_signature"`
	ChangeLog                []*Log                 `protobuf:"bytes,7,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty" pg:"-"`
	LastModifyTime           time.Time              `protobuf:"bytes,8,opt,name=last_modify_time,json=lastModifyTime,proto3,stdtime" json:"last_modify_time" pg:"last_modify_time"`
	GuardSignature           []byte                 `protobuf:"bytes,9,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	PreparerPid              string                 `protobuf:"bytes,10,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	PreparerSignature        []byte                 `protobuf:"bytes,11,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	LastSuccessChallengeTime time.Time              `protobuf:"bytes,12,opt,name=last_success_challenge_time,json=lastSuccessChallengeTime,proto3,stdtime" json:"last_success_challenge_time" pg:"last_success_challenge_time"`
	LastChallengeTime        time.Time              `protobuf:"bytes,13,opt,name=last_challenge_time,json=lastChallengeTime,proto3,stdtime" json:"last_challenge_time" pg:"last_challenge_time"`
	ChallengeTimes           int32                  `protobuf:"varint,14,opt,name=challenge_times,json=challengeTimes,proto3" json:"challenge_times,omitempty" pg:"challenge_times"`
	ChallengeWarnTimes       int32                  `protobuf:"varint,15,opt,name=challenge_warn_times,json=challengeWarnTimes,proto3" json:"challenge_warn_times,omitempty" pg:"challenge_warn_times"`
	ChallengeSuccessTimes    int32                  `protobuf:"varint,16,opt,name=challenge_success_times,json=challengeSuccessTimes,proto3" json:"challenge_success_times,omitempty" pg:"challenge_success_times"`
	FirstChallengeSuccess    time.Time              `protobuf:"bytes,17,opt,name=first_challenge_success,json=firstChallengeSuccess,proto3,stdtime" json:"first_challenge_success" pg:"first_challenge_success"`
	Token                    string                 `protobuf:"bytes,18,opt,name=token,proto3" json:"token,omitempty" pg:"token"`
	XXX_NoUnkeyedLiteral     struct{}               `json:"-" pg:"-"`
	XXX_unrecognized         []byte                 `json:"-" pg:"-"`
	XXX_sizecache            int32                  `json:"-" pg:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{7}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetState() Contract_ContractState {
	if m != nil {
		return m.State
	}
	return Contract_DRAFT
}

func (m *Contract) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *Contract) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (m *Contract) GetEscrowSignedTime() time.Time {
	if m != nil {
		return m.EscrowSignedTime
	}
	return time.Time{}
}

func (m *Contract) GetEscrowSignature() []byte {
	if m != nil {
		return m.EscrowSignature
	}
	return nil
}

func (m *Contract) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *Contract) GetLastModifyTime() time.Time {
	if m != nil {
		return m.LastModifyTime
	}
	return time.Time{}
}

func (m *Contract) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *Contract) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *Contract) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (m *Contract) GetLastSuccessChallengeTime() time.Time {
	if m != nil {
		return m.LastSuccessChallengeTime
	}
	return time.Time{}
}

func (m *Contract) GetLastChallengeTime() time.Time {
	if m != nil {
		return m.LastChallengeTime
	}
	return time.Time{}
}

func (m *Contract) GetChallengeTimes() int32 {
	if m != nil {
		return m.ChallengeTimes
	}
	return 0
}

func (m *Contract) GetChallengeWarnTimes() int32 {
	if m != nil {
		return m.ChallengeWarnTimes
	}
	return 0
}

func (m *Contract) GetChallengeSuccessTimes() int32 {
	if m != nil {
		return m.ChallengeSuccessTimes
	}
	return 0
}

func (m *Contract) GetFirstChallengeSuccess() time.Time {
	if m != nil {
		return m.FirstChallengeSuccess
	}
	return time.Time{}
}

func (m *Contract) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (*Contract) XXX_MessageName() string {
	return "guard.Contract"
}

type FileStoreListResponse struct {
	Request              *ListRenterFileInfoRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty" pg:"request"`
	CurrentTime          time.Time                  `protobuf:"bytes,2,opt,name=current_time,json=currentTime,proto3,stdtime" json:"current_time" pg:"current_time"`
	FileStoreMeta        []*FileStoreMeta           `protobuf:"bytes,3,rep,name=file_store_meta,json=fileStoreMeta,proto3" json:"file_store_meta,omitempty" pg:"file_store_meta"`
	Count                int32                      `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty" pg:"count"`
	Signature            []byte                     `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" pg:"-"`
	XXX_unrecognized     []byte                     `json:"-" pg:"-"`
	XXX_sizecache        int32                      `json:"-" pg:"-"`
}

func (m *FileStoreListResponse) Reset()         { *m = FileStoreListResponse{} }
func (m *FileStoreListResponse) String() string { return proto.CompactTextString(m) }
func (*FileStoreListResponse) ProtoMessage()    {}
func (*FileStoreListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{8}
}
func (m *FileStoreListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreListResponse.Merge(m, src)
}
func (m *FileStoreListResponse) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreListResponse proto.InternalMessageInfo

func (m *FileStoreListResponse) GetRequest() *ListRenterFileInfoRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *FileStoreListResponse) GetCurrentTime() time.Time {
	if m != nil {
		return m.CurrentTime
	}
	return time.Time{}
}

func (m *FileStoreListResponse) GetFileStoreMeta() []*FileStoreMeta {
	if m != nil {
		return m.FileStoreMeta
	}
	return nil
}

func (m *FileStoreListResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *FileStoreListResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*FileStoreListResponse) XXX_MessageName() string {
	return "guard.FileStoreListResponse"
}

type FileStoreMeta struct {
	// file store meta prepared by renter, will not changed after proposal
	RenterPid                  string    `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash                   string    `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	FileSize                   int64     `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty" pg:"file_size"`
	RentStart                  time.Time `protobuf:"bytes,4,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start" pg:"rent_start"`
	RentEnd                    time.Time `protobuf:"bytes,5,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end" pg:"rent_end"`
	CheckFrequency             int32     `protobuf:"varint,6,opt,name=check_frequency,json=checkFrequency,proto3" json:"check_frequency,omitempty" pg:"check_frequency"`
	GuardFee                   int64     `protobuf:"varint,7,opt,name=guard_fee,json=guardFee,proto3" json:"guard_fee,omitempty" pg:"guard_fee"`
	EscrowFee                  int64     `protobuf:"varint,8,opt,name=escrow_fee,json=escrowFee,proto3" json:"escrow_fee,omitempty" pg:"escrow_fee"`
	ShardCount                 int32     `protobuf:"varint,9,opt,name=shard_count,json=shardCount,proto3" json:"shard_count,omitempty" pg:"shard_count"`
	MinimumShards              int32     `protobuf:"varint,10,opt,name=minimum_shards,json=minimumShards,proto3" json:"minimum_shards,omitempty" pg:"minimum_shards"`
	RecoverThreshold           int32     `protobuf:"varint,11,opt,name=recover_threshold,json=recoverThreshold,proto3" json:"recover_threshold,omitempty" pg:"recover_threshold"`
	EscrowPid                  string    `protobuf:"bytes,12,opt,name=escrow_pid,json=escrowPid,proto3" json:"escrow_pid,omitempty" pg:"escrow_pid"`
	GuardPid                   string    `protobuf:"bytes,13,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	WarnChallengeTimesLimit    int32     `protobuf:"varint,14,opt,name=warn_challenge_times_limit,json=warnChallengeTimesLimit,proto3" json:"warn_challenge_times_limit,omitempty" pg:"warn_challenge_times_limit"`
	SuccessChallengeTimesLimit int32     `protobuf:"varint,15,opt,name=success_challenge_times_limit,json=successChallengeTimesLimit,proto3" json:"success_challenge_times_limit,omitempty" pg:"success_challenge_times_limit"`
	CheckFrequencyWarn         int32     `protobuf:"varint,16,opt,name=check_frequency_warn,json=checkFrequencyWarn,proto3" json:"check_frequency_warn,omitempty" pg:"check_frequency_warn"`
	Token                      string    `protobuf:"bytes,17,opt,name=token,proto3" json:"token,omitempty" pg:"token"`
	XXX_NoUnkeyedLiteral       struct{}  `json:"-" pg:"-"`
	XXX_unrecognized           []byte    `json:"-" pg:"-"`
	XXX_sizecache              int32     `json:"-" pg:"-"`
}

func (m *FileStoreMeta) Reset()         { *m = FileStoreMeta{} }
func (m *FileStoreMeta) String() string { return proto.CompactTextString(m) }
func (*FileStoreMeta) ProtoMessage()    {}
func (*FileStoreMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{9}
}
func (m *FileStoreMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreMeta.Merge(m, src)
}
func (m *FileStoreMeta) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreMeta proto.InternalMessageInfo

func (m *FileStoreMeta) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *FileStoreMeta) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *FileStoreMeta) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *FileStoreMeta) GetRentStart() time.Time {
	if m != nil {
		return m.RentStart
	}
	return time.Time{}
}

func (m *FileStoreMeta) GetRentEnd() time.Time {
	if m != nil {
		return m.RentEnd
	}
	return time.Time{}
}

func (m *FileStoreMeta) GetCheckFrequency() int32 {
	if m != nil {
		return m.CheckFrequency
	}
	return 0
}

func (m *FileStoreMeta) GetGuardFee() int64 {
	if m != nil {
		return m.GuardFee
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowFee() int64 {
	if m != nil {
		return m.EscrowFee
	}
	return 0
}

func (m *FileStoreMeta) GetShardCount() int32 {
	if m != nil {
		return m.ShardCount
	}
	return 0
}

func (m *FileStoreMeta) GetMinimumShards() int32 {
	if m != nil {
		return m.MinimumShards
	}
	return 0
}

func (m *FileStoreMeta) GetRecoverThreshold() int32 {
	if m != nil {
		return m.RecoverThreshold
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowPid() string {
	if m != nil {
		return m.EscrowPid
	}
	return ""
}

func (m *FileStoreMeta) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *FileStoreMeta) GetWarnChallengeTimesLimit() int32 {
	if m != nil {
		return m.WarnChallengeTimesLimit
	}
	return 0
}

func (m *FileStoreMeta) GetSuccessChallengeTimesLimit() int32 {
	if m != nil {
		return m.SuccessChallengeTimesLimit
	}
	return 0
}

func (m *FileStoreMeta) GetCheckFrequencyWarn() int32 {
	if m != nil {
		return m.CheckFrequencyWarn
	}
	return 0
}

func (m *FileStoreMeta) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (*FileStoreMeta) XXX_MessageName() string {
	return "guard.FileStoreMeta"
}

type FileStoreStatus struct {
	FileStoreMeta        `protobuf:"bytes,1,opt,name=file_store_meta,json=fileStoreMeta,proto3,embedded=file_store_meta" json:"file_store_meta" pg:"file_store_meta"`
	State                FileStoreStatus_MetaState   `protobuf:"varint,2,opt,name=state,proto3,enum=guard.FileStoreStatus_MetaState" json:"state,omitempty" pg:"state"`
	Contracts            []*Contract                 `protobuf:"bytes,3,rep,name=contracts,proto3" json:"contracts,omitempty" pg:"-"`
	RenterSignature      []byte                      `protobuf:"bytes,4,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty" pg:"renter_signature"`
	GuardReceiveTime     time.Time                   `protobuf:"bytes,5,opt,name=guard_receive_time,json=guardReceiveTime,proto3,stdtime" json:"guard_receive_time" pg:"guard_receive_time"`
	ChangeLog            []*Log                      `protobuf:"bytes,6,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty" pg:"-"`
	CurrentTime          time.Time                   `protobuf:"bytes,7,opt,name=current_time,json=currentTime,proto3,stdtime" json:"current_time" pg:"current_time"`
	GuardSignature       []byte                      `protobuf:"bytes,8,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	RentalState          FileStoreStatus_RentalState `protobuf:"varint,9,opt,name=rental_state,json=rentalState,proto3,enum=guard.FileStoreStatus_RentalState" json:"rental_state,omitempty" pg:"rental_state"`
	PreparerPid          string                      `protobuf:"bytes,10,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	PreparerSignature    []byte                      `protobuf:"bytes,11,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-" pg:"-"`
	XXX_unrecognized     []byte                      `json:"-" pg:"-"`
	XXX_sizecache        int32                       `json:"-" pg:"-"`
}

func (m *FileStoreStatus) Reset()         { *m = FileStoreStatus{} }
func (m *FileStoreStatus) String() string { return proto.CompactTextString(m) }
func (*FileStoreStatus) ProtoMessage()    {}
func (*FileStoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{10}
}
func (m *FileStoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreStatus.Merge(m, src)
}
func (m *FileStoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreStatus proto.InternalMessageInfo

func (m *FileStoreStatus) GetState() FileStoreStatus_MetaState {
	if m != nil {
		return m.State
	}
	return FileStoreStatus_DRAFT
}

func (m *FileStoreStatus) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func (m *FileStoreStatus) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *FileStoreStatus) GetGuardReceiveTime() time.Time {
	if m != nil {
		return m.GuardReceiveTime
	}
	return time.Time{}
}

func (m *FileStoreStatus) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *FileStoreStatus) GetCurrentTime() time.Time {
	if m != nil {
		return m.CurrentTime
	}
	return time.Time{}
}

func (m *FileStoreStatus) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *FileStoreStatus) GetRentalState() FileStoreStatus_RentalState {
	if m != nil {
		return m.RentalState
	}
	return FileStoreStatus_NEW
}

func (m *FileStoreStatus) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *FileStoreStatus) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (*FileStoreStatus) XXX_MessageName() string {
	return "guard.FileStoreStatus"
}

type ChallengeQuestion struct {
	ShardHash            string   `protobuf:"bytes,1,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	HostPid              string   `protobuf:"bytes,2,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ChunkIndex           int32    `protobuf:"varint,3,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty" pg:"chunk_index"`
	Nonce                string   `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty" pg:"nonce"`
	ExpectAnswer         string   `protobuf:"bytes,5,opt,name=expect_answer,json=expectAnswer,proto3" json:"expect_answer,omitempty" pg:"expect_answer"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *ChallengeQuestion) Reset()         { *m = ChallengeQuestion{} }
func (m *ChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*ChallengeQuestion) ProtoMessage()    {}
func (*ChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{11}
}
func (m *ChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeQuestion.Merge(m, src)
}
func (m *ChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeQuestion proto.InternalMessageInfo

func (m *ChallengeQuestion) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ChallengeQuestion) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ChallengeQuestion) GetChunkIndex() int32 {
	if m != nil {
		return m.ChunkIndex
	}
	return 0
}

func (m *ChallengeQuestion) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *ChallengeQuestion) GetExpectAnswer() string {
	if m != nil {
		return m.ExpectAnswer
	}
	return ""
}

func (*ChallengeQuestion) XXX_MessageName() string {
	return "guard.ChallengeQuestion"
}

type ProofOfReplicateChallenge struct {
	ChallengeQuestion    `protobuf:"bytes,1,opt,name=question,proto3,embedded=question" json:"question" pg:"question"`
	ChallengeTime        time.Time `protobuf:"bytes,2,opt,name=challenge_time,json=challengeTime,proto3,stdtime" json:"challenge_time" pg:"challenge_time"`
	GuardPid             string    `protobuf:"bytes,3,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	GuardSignature       []byte    `protobuf:"bytes,4,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	HostAnswer           string    `protobuf:"bytes,5,opt,name=host_answer,json=hostAnswer,proto3" json:"host_answer,omitempty" pg:"host_answer"`
	HostSignTime         time.Time `protobuf:"bytes,6,opt,name=host_sign_time,json=hostSignTime,proto3,stdtime" json:"host_sign_time" pg:"host_sign_time"`
	HostSignature        []byte    `protobuf:"bytes,7,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty" pg:"host_signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *ProofOfReplicateChallenge) Reset()         { *m = ProofOfReplicateChallenge{} }
func (m *ProofOfReplicateChallenge) String() string { return proto.CompactTextString(m) }
func (*ProofOfReplicateChallenge) ProtoMessage()    {}
func (*ProofOfReplicateChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{12}
}
func (m *ProofOfReplicateChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofOfReplicateChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofOfReplicateChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofOfReplicateChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofOfReplicateChallenge.Merge(m, src)
}
func (m *ProofOfReplicateChallenge) XXX_Size() int {
	return m.Size()
}
func (m *ProofOfReplicateChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofOfReplicateChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_ProofOfReplicateChallenge proto.InternalMessageInfo

func (m *ProofOfReplicateChallenge) GetChallengeTime() time.Time {
	if m != nil {
		return m.ChallengeTime
	}
	return time.Time{}
}

func (m *ProofOfReplicateChallenge) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ProofOfReplicateChallenge) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetHostAnswer() string {
	if m != nil {
		return m.HostAnswer
	}
	return ""
}

func (m *ProofOfReplicateChallenge) GetHostSignTime() time.Time {
	if m != nil {
		return m.HostSignTime
	}
	return time.Time{}
}

func (m *ProofOfReplicateChallenge) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (*ProofOfReplicateChallenge) XXX_MessageName() string {
	return "guard.ProofOfReplicateChallenge"
}

type FileChallengeQuestions struct {
	FileHash             string                     `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardQuestions       []*ShardChallengeQuestions `protobuf:"bytes,2,rep,name=shard_questions,json=shardQuestions,proto3" json:"shard_questions,omitempty" pg:"shard_questions"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" pg:"-"`
	XXX_unrecognized     []byte                     `json:"-" pg:"-"`
	XXX_sizecache        int32                      `json:"-" pg:"-"`
}

func (m *FileChallengeQuestions) Reset()         { *m = FileChallengeQuestions{} }
func (m *FileChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*FileChallengeQuestions) ProtoMessage()    {}
func (*FileChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{13}
}
func (m *FileChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChallengeQuestions.Merge(m, src)
}
func (m *FileChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *FileChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_FileChallengeQuestions proto.InternalMessageInfo

func (m *FileChallengeQuestions) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *FileChallengeQuestions) GetShardQuestions() []*ShardChallengeQuestions {
	if m != nil {
		return m.ShardQuestions
	}
	return nil
}

func (*FileChallengeQuestions) XXX_MessageName() string {
	return "guard.FileChallengeQuestions"
}

type ShardChallengeQuestions struct {
	FileHash             string               `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string               `protobuf:"bytes,2,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	PreparerPid          string               `protobuf:"bytes,3,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	QuestionCount        int32                `protobuf:"varint,4,opt,name=question_count,json=questionCount,proto3" json:"question_count,omitempty" pg:"question_count"`
	Questions            []*ChallengeQuestion `protobuf:"bytes,5,rep,name=questions,proto3" json:"questions,omitempty" pg:"questions"`
	PrepareTime          time.Time            `protobuf:"bytes,6,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	PreparerSignature    []byte               `protobuf:"bytes,7,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-" pg:"-"`
	XXX_unrecognized     []byte               `json:"-" pg:"-"`
	XXX_sizecache        int32                `json:"-" pg:"-"`
}

func (m *ShardChallengeQuestions) Reset()         { *m = ShardChallengeQuestions{} }
func (m *ShardChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*ShardChallengeQuestions) ProtoMessage()    {}
func (*ShardChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{14}
}
func (m *ShardChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardChallengeQuestions.Merge(m, src)
}
func (m *ShardChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *ShardChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_ShardChallengeQuestions proto.InternalMessageInfo

func (m *ShardChallengeQuestions) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ShardChallengeQuestions) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ShardChallengeQuestions) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *ShardChallengeQuestions) GetQuestionCount() int32 {
	if m != nil {
		return m.QuestionCount
	}
	return 0
}

func (m *ShardChallengeQuestions) GetQuestions() []*ChallengeQuestion {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *ShardChallengeQuestions) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *ShardChallengeQuestions) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (*ShardChallengeQuestions) XXX_MessageName() string {
	return "guard.ShardChallengeQuestions"
}

type CheckFileStoreMetaRequest struct {
	FileHash             string    `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RenterPid            string    `protobuf:"bytes,2,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	RequesterPid         string    `protobuf:"bytes,3,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestTime          time.Time `protobuf:"bytes,4,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time" pg:"request_time"`
	Signature            []byte    `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *CheckFileStoreMetaRequest) Reset()         { *m = CheckFileStoreMetaRequest{} }
func (m *CheckFileStoreMetaRequest) String() string { return proto.CompactTextString(m) }
func (*CheckFileStoreMetaRequest) ProtoMessage()    {}
func (*CheckFileStoreMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{15}
}
func (m *CheckFileStoreMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckFileStoreMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckFileStoreMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckFileStoreMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckFileStoreMetaRequest.Merge(m, src)
}
func (m *CheckFileStoreMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckFileStoreMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckFileStoreMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckFileStoreMetaRequest proto.InternalMessageInfo

func (m *CheckFileStoreMetaRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *CheckFileStoreMetaRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*CheckFileStoreMetaRequest) XXX_MessageName() string {
	return "guard.CheckFileStoreMetaRequest"
}

type ListRenterFileInfoRequest struct {
	RenterPid            string     `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	RequesterPid         string     `protobuf:"bytes,2,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestPageSize      int32      `protobuf:"varint,3,opt,name=request_page_size,json=requestPageSize,proto3" json:"request_page_size,omitempty" pg:"request_page_size"`
	RequestPageIndex     int32      `protobuf:"varint,4,opt,name=request_page_index,json=requestPageIndex,proto3" json:"request_page_index,omitempty" pg:"request_page_index"`
	RequestTime          *time.Time `protobuf:"bytes,5,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time,omitempty" pg:"request_time"`
	LastModifyTime       *time.Time `protobuf:"bytes,6,opt,name=last_modify_time,json=lastModifyTime,proto3,stdtime" json:"last_modify_time,omitempty" pg:"last_modify_time"`
	Signature            []byte     `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-" pg:"-"`
	XXX_unrecognized     []byte     `json:"-" pg:"-"`
	XXX_sizecache        int32      `json:"-" pg:"-"`
}

func (m *ListRenterFileInfoRequest) Reset()         { *m = ListRenterFileInfoRequest{} }
func (m *ListRenterFileInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ListRenterFileInfoRequest) ProtoMessage()    {}
func (*ListRenterFileInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{16}
}
func (m *ListRenterFileInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRenterFileInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRenterFileInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRenterFileInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRenterFileInfoRequest.Merge(m, src)
}
func (m *ListRenterFileInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRenterFileInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRenterFileInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRenterFileInfoRequest proto.InternalMessageInfo

func (m *ListRenterFileInfoRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ListRenterFileInfoRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *ListRenterFileInfoRequest) GetRequestPageSize() int32 {
	if m != nil {
		return m.RequestPageSize
	}
	return 0
}

func (m *ListRenterFileInfoRequest) GetRequestPageIndex() int32 {
	if m != nil {
		return m.RequestPageIndex
	}
	return 0
}

func (m *ListRenterFileInfoRequest) GetRequestTime() *time.Time {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *ListRenterFileInfoRequest) GetLastModifyTime() *time.Time {
	if m != nil {
		return m.LastModifyTime
	}
	return nil
}

func (m *ListRenterFileInfoRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ListRenterFileInfoRequest) XXX_MessageName() string {
	return "guard.ListRenterFileInfoRequest"
}

type ListHostContractsRequest struct {
	HostPid              string                               `protobuf:"bytes,1,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	RequesterPid         string                               `protobuf:"bytes,2,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestPageSize      int32                                `protobuf:"varint,3,opt,name=request_page_size,json=requestPageSize,proto3" json:"request_page_size,omitempty" pg:"request_page_size"`
	RequestPageIndex     int32                                `protobuf:"varint,4,opt,name=request_page_index,json=requestPageIndex,proto3" json:"request_page_index,omitempty" pg:"request_page_index"`
	LastModifyTimeSince  *time.Time                           `protobuf:"bytes,5,opt,name=last_modify_time_since,json=lastModifyTimeSince,proto3,stdtime" json:"last_modify_time_since,omitempty" pg:"last_modify_time_since"`
	LastModifyTimeTo     *time.Time                           `protobuf:"bytes,6,opt,name=last_modify_time_to,json=lastModifyTimeTo,proto3,stdtime" json:"last_modify_time_to,omitempty" pg:"last_modify_time_to"`
	State                ListHostContractsRequest_SelectState `protobuf:"varint,7,opt,name=state,proto3,enum=guard.ListHostContractsRequest_SelectState" json:"state,omitempty" pg:"state"`
	RequestTime          *time.Time                           `protobuf:"bytes,8,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time,omitempty" pg:"request_time"`
	Signature            []byte                               `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-" pg:"-"`
	XXX_unrecognized     []byte                               `json:"-" pg:"-"`
	XXX_sizecache        int32                                `json:"-" pg:"-"`
}

func (m *ListHostContractsRequest) Reset()         { *m = ListHostContractsRequest{} }
func (m *ListHostContractsRequest) String() string { return proto.CompactTextString(m) }
func (*ListHostContractsRequest) ProtoMessage()    {}
func (*ListHostContractsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{17}
}
func (m *ListHostContractsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHostContractsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHostContractsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHostContractsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHostContractsRequest.Merge(m, src)
}
func (m *ListHostContractsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListHostContractsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHostContractsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListHostContractsRequest proto.InternalMessageInfo

func (m *ListHostContractsRequest) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ListHostContractsRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *ListHostContractsRequest) GetRequestPageSize() int32 {
	if m != nil {
		return m.RequestPageSize
	}
	return 0
}

func (m *ListHostContractsRequest) GetRequestPageIndex() int32 {
	if m != nil {
		return m.RequestPageIndex
	}
	return 0
}

func (m *ListHostContractsRequest) GetLastModifyTimeSince() *time.Time {
	if m != nil {
		return m.LastModifyTimeSince
	}
	return nil
}

func (m *ListHostContractsRequest) GetLastModifyTimeTo() *time.Time {
	if m != nil {
		return m.LastModifyTimeTo
	}
	return nil
}

func (m *ListHostContractsRequest) GetState() ListHostContractsRequest_SelectState {
	if m != nil {
		return m.State
	}
	return ListHostContractsRequest_ALL
}

func (m *ListHostContractsRequest) GetRequestTime() *time.Time {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *ListHostContractsRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ListHostContractsRequest) XXX_MessageName() string {
	return "guard.ListHostContractsRequest"
}

type ContractsList struct {
	Request              *ListHostContractsRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty" pg:"request"`
	GenerateTime         time.Time                 `protobuf:"bytes,2,opt,name=generate_time,json=generateTime,proto3,stdtime" json:"generate_time" pg:"generate_time"`
	Contracts            []*Contract               `protobuf:"bytes,3,rep,name=contracts,proto3" json:"contracts,omitempty" pg:"contracts"`
	Count                int32                     `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty" pg:"count"`
	Signature            []byte                    `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-" pg:"-"`
	XXX_unrecognized     []byte                    `json:"-" pg:"-"`
	XXX_sizecache        int32                     `json:"-" pg:"-"`
}

func (m *ContractsList) Reset()         { *m = ContractsList{} }
func (m *ContractsList) String() string { return proto.CompactTextString(m) }
func (*ContractsList) ProtoMessage()    {}
func (*ContractsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{18}
}
func (m *ContractsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractsList.Merge(m, src)
}
func (m *ContractsList) XXX_Size() int {
	return m.Size()
}
func (m *ContractsList) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractsList.DiscardUnknown(m)
}

var xxx_messageInfo_ContractsList proto.InternalMessageInfo

func (m *ContractsList) GetRequest() *ListHostContractsRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ContractsList) GetGenerateTime() time.Time {
	if m != nil {
		return m.GenerateTime
	}
	return time.Time{}
}

func (m *ContractsList) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func (m *ContractsList) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ContractsList) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ContractsList) XXX_MessageName() string {
	return "guard.ContractsList"
}

type ReadyForChallengeRequest struct {
	RenterPid            string    `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash             string    `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string    `protobuf:"bytes,3,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	ContractId           string    `protobuf:"bytes,4,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty" pg:"contract_id"`
	HostPid              string    `protobuf:"bytes,5,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	PrepareTime          time.Time `protobuf:"bytes,6,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	Signature            []byte    `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	IsRepair             bool      `protobuf:"varint,8,opt,name=is_repair,json=isRepair,proto3" json:"is_repair,omitempty" pg:"is_repair"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *ReadyForChallengeRequest) Reset()         { *m = ReadyForChallengeRequest{} }
func (m *ReadyForChallengeRequest) String() string { return proto.CompactTextString(m) }
func (*ReadyForChallengeRequest) ProtoMessage()    {}
func (*ReadyForChallengeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{19}
}
func (m *ReadyForChallengeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadyForChallengeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadyForChallengeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadyForChallengeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadyForChallengeRequest.Merge(m, src)
}
func (m *ReadyForChallengeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadyForChallengeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadyForChallengeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadyForChallengeRequest proto.InternalMessageInfo

func (m *ReadyForChallengeRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *ReadyForChallengeRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ReadyForChallengeRequest) GetIsRepair() bool {
	if m != nil {
		return m.IsRepair
	}
	return false
}

func (*ReadyForChallengeRequest) XXX_MessageName() string {
	return "guard.ReadyForChallengeRequest"
}

type RequestChallengeQuestion struct {
	Question             *ChallengeQuestion `protobuf:"bytes,1,opt,name=question,proto3" json:"question,omitempty" pg:"question"`
	PrepareTime          time.Time          `protobuf:"bytes,2,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	Signature            []byte             `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	IsRepair             bool               `protobuf:"varint,4,opt,name=is_repair,json=isRepair,proto3" json:"is_repair,omitempty" pg:"is_repair"`
	FileHash             string             `protobuf:"bytes,5,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-" pg:"-"`
	XXX_unrecognized     []byte             `json:"-" pg:"-"`
	XXX_sizecache        int32              `json:"-" pg:"-"`
}

func (m *RequestChallengeQuestion) Reset()         { *m = RequestChallengeQuestion{} }
func (m *RequestChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*RequestChallengeQuestion) ProtoMessage()    {}
func (*RequestChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{20}
}
func (m *RequestChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestChallengeQuestion.Merge(m, src)
}
func (m *RequestChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *RequestChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_RequestChallengeQuestion proto.InternalMessageInfo

func (m *RequestChallengeQuestion) GetQuestion() *ChallengeQuestion {
	if m != nil {
		return m.Question
	}
	return nil
}

func (m *RequestChallengeQuestion) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *RequestChallengeQuestion) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *RequestChallengeQuestion) GetIsRepair() bool {
	if m != nil {
		return m.IsRepair
	}
	return false
}

func (m *RequestChallengeQuestion) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (*RequestChallengeQuestion) XXX_MessageName() string {
	return "guard.RequestChallengeQuestion"
}

type ResponseChallengeQuestion struct {
	Answer               *ChallengeQuestion `protobuf:"bytes,1,opt,name=answer,proto3" json:"answer,omitempty" pg:"answer"`
	HostPid              string             `protobuf:"bytes,2,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ResolveTime          time.Time          `protobuf:"bytes,3,opt,name=resolve_time,json=resolveTime,proto3,stdtime" json:"resolve_time" pg:"resolve_time"`
	Signature            []byte             `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	IsRepair             bool               `protobuf:"varint,5,opt,name=is_repair,json=isRepair,proto3" json:"is_repair,omitempty" pg:"is_repair"`
	FileHash             string             `protobuf:"bytes,6,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-" pg:"-"`
	XXX_unrecognized     []byte             `json:"-" pg:"-"`
	XXX_sizecache        int32              `json:"-" pg:"-"`
}

func (m *ResponseChallengeQuestion) Reset()         { *m = ResponseChallengeQuestion{} }
func (m *ResponseChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*ResponseChallengeQuestion) ProtoMessage()    {}
func (*ResponseChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{21}
}
func (m *ResponseChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseChallengeQuestion.Merge(m, src)
}
func (m *ResponseChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *ResponseChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseChallengeQuestion proto.InternalMessageInfo

func (m *ResponseChallengeQuestion) GetAnswer() *ChallengeQuestion {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *ResponseChallengeQuestion) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ResponseChallengeQuestion) GetResolveTime() time.Time {
	if m != nil {
		return m.ResolveTime
	}
	return time.Time{}
}

func (m *ResponseChallengeQuestion) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ResponseChallengeQuestion) GetIsRepair() bool {
	if m != nil {
		return m.IsRepair
	}
	return false
}

func (m *ResponseChallengeQuestion) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (*ResponseChallengeQuestion) XXX_MessageName() string {
	return "guard.ResponseChallengeQuestion"
}

type ForceRepairRequest struct {
	RenterPid            string   `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash             string   `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	AuthPid              string   `protobuf:"bytes,3,opt,name=auth_pid,json=authPid,proto3" json:"auth_pid,omitempty" pg:"auth_pid"`
	Signature            []byte   `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *ForceRepairRequest) Reset()         { *m = ForceRepairRequest{} }
func (m *ForceRepairRequest) String() string { return proto.CompactTextString(m) }
func (*ForceRepairRequest) ProtoMessage()    {}
func (*ForceRepairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{22}
}
func (m *ForceRepairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForceRepairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForceRepairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForceRepairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForceRepairRequest.Merge(m, src)
}
func (m *ForceRepairRequest) XXX_Size() int {
	return m.Size()
}
func (m *ForceRepairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ForceRepairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ForceRepairRequest proto.InternalMessageInfo

func (m *ForceRepairRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ForceRepairRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ForceRepairRequest) GetAuthPid() string {
	if m != nil {
		return m.AuthPid
	}
	return ""
}

func (m *ForceRepairRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ForceRepairRequest) XXX_MessageName() string {
	return "guard.ForceRepairRequest"
}

type Result struct {
	Code                 ResponseCode `protobuf:"varint,1,opt,name=code,proto3,enum=guard.ResponseCode" json:"code,omitempty" pg:"code"`
	Message              string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty" pg:"message"`
	ResponseTime         time.Time    `protobuf:"bytes,3,opt,name=response_time,json=responseTime,proto3,stdtime" json:"response_time" pg:"response_time"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-" pg:"-"`
	XXX_unrecognized     []byte       `json:"-" pg:"-"`
	XXX_sizecache        int32        `json:"-" pg:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{23}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetCode() ResponseCode {
	if m != nil {
		return m.Code
	}
	return ResponseCode_SUCCESS
}

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Result) GetResponseTime() time.Time {
	if m != nil {
		return m.ResponseTime
	}
	return time.Time{}
}

func (*Result) XXX_MessageName() string {
	return "guard.Result"
}

type RepairContract struct {
	FileHash             string    `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	LostShardHash        []string  `protobuf:"bytes,2,rep,name=lost_shard_hash,json=lostShardHash,proto3" json:"lost_shard_hash,omitempty" pg:"lost_shard_hash"`
	FileSize             int64     `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty" pg:"file_size"`
	DownloadRewardAmount int64     `protobuf:"varint,4,opt,name=download_reward_amount,json=downloadRewardAmount,proto3" json:"download_reward_amount,omitempty" pg:"download_reward_amount"`
	RepairRewardAmount   int64     `protobuf:"varint,5,opt,name=repair_reward_amount,json=repairRewardAmount,proto3" json:"repair_reward_amount,omitempty" pg:"repair_reward_amount"`
	RepairPid            string    `protobuf:"bytes,6,opt,name=repair_pid,json=repairPid,proto3" json:"repair_pid,omitempty" pg:"repair_pid"`
	RepairSignTime       time.Time `protobuf:"bytes,7,opt,name=repair_sign_time,json=repairSignTime,proto3,stdtime" json:"repair_sign_time" pg:"repair_sign_time"`
	RepairSignature      []byte    `protobuf:"bytes,8,opt,name=repair_signature,json=repairSignature,proto3" json:"repair_signature,omitempty" pg:"repair_signature"`
	DownloadContractId   string    `protobuf:"bytes,9,opt,name=download_contract_id,json=downloadContractId,proto3" json:"download_contract_id,omitempty" pg:"download_contract_id"`
	RepairContractId     string    `protobuf:"bytes,10,opt,name=repair_contract_id,json=repairContractId,proto3" json:"repair_contract_id,omitempty" pg:"repair_contract_id"`
	GuardSignTime        time.Time `protobuf:"bytes,11,opt,name=guard_sign_time,json=guardSignTime,proto3,stdtime" json:"guard_sign_time" pg:"guard_sign_time"`
	GuardSignature       []byte    `protobuf:"bytes,12,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *RepairContract) Reset()         { *m = RepairContract{} }
func (m *RepairContract) String() string { return proto.CompactTextString(m) }
func (*RepairContract) ProtoMessage()    {}
func (*RepairContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{24}
}
func (m *RepairContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepairContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepairContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepairContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepairContract.Merge(m, src)
}
func (m *RepairContract) XXX_Size() int {
	return m.Size()
}
func (m *RepairContract) XXX_DiscardUnknown() {
	xxx_messageInfo_RepairContract.DiscardUnknown(m)
}

var xxx_messageInfo_RepairContract proto.InternalMessageInfo

func (m *RepairContract) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *RepairContract) GetLostShardHash() []string {
	if m != nil {
		return m.LostShardHash
	}
	return nil
}

func (m *RepairContract) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *RepairContract) GetDownloadRewardAmount() int64 {
	if m != nil {
		return m.DownloadRewardAmount
	}
	return 0
}

func (m *RepairContract) GetRepairRewardAmount() int64 {
	if m != nil {
		return m.RepairRewardAmount
	}
	return 0
}

func (m *RepairContract) GetRepairPid() string {
	if m != nil {
		return m.RepairPid
	}
	return ""
}

func (m *RepairContract) GetRepairSignTime() time.Time {
	if m != nil {
		return m.RepairSignTime
	}
	return time.Time{}
}

func (m *RepairContract) GetRepairSignature() []byte {
	if m != nil {
		return m.RepairSignature
	}
	return nil
}

func (m *RepairContract) GetDownloadContractId() string {
	if m != nil {
		return m.DownloadContractId
	}
	return ""
}

func (m *RepairContract) GetRepairContractId() string {
	if m != nil {
		return m.RepairContractId
	}
	return ""
}

func (m *RepairContract) GetGuardSignTime() time.Time {
	if m != nil {
		return m.GuardSignTime
	}
	return time.Time{}
}

func (m *RepairContract) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (*RepairContract) XXX_MessageName() string {
	return "guard.RepairContract"
}

type RepairContractResponse struct {
	Contract             *RepairContract                               `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty" pg:"contract"`
	Status               RepairContractResponse_ContractResponseStatus `protobuf:"varint,2,opt,name=status,proto3,enum=guard.RepairContractResponse_ContractResponseStatus" json:"status,omitempty" pg:"status"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-" pg:"-"`
	XXX_unrecognized     []byte                                        `json:"-" pg:"-"`
	XXX_sizecache        int32                                         `json:"-" pg:"-"`
}

func (m *RepairContractResponse) Reset()         { *m = RepairContractResponse{} }
func (m *RepairContractResponse) String() string { return proto.CompactTextString(m) }
func (*RepairContractResponse) ProtoMessage()    {}
func (*RepairContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{25}
}
func (m *RepairContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepairContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepairContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepairContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepairContractResponse.Merge(m, src)
}
func (m *RepairContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *RepairContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RepairContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RepairContractResponse proto.InternalMessageInfo

func (m *RepairContractResponse) GetContract() *RepairContract {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *RepairContractResponse) GetStatus() RepairContractResponse_ContractResponseStatus {
	if m != nil {
		return m.Status
	}
	return RepairContractResponse_BOTH_SIGNED
}

func (*RepairContractResponse) XXX_MessageName() string {
	return "guard.RepairContractResponse"
}

type RequestRepairContracts struct {
	FileHash             string    `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RepairNode           string    `protobuf:"bytes,2,opt,name=repair_node,json=repairNode,proto3" json:"repair_node,omitempty" pg:"repair_node"`
	RepairSignTime       time.Time `protobuf:"bytes,3,opt,name=repair_sign_time,json=repairSignTime,proto3,stdtime" json:"repair_sign_time" pg:"repair_sign_time"`
	RepairSignature      []byte    `protobuf:"bytes,4,opt,name=repair_signature,json=repairSignature,proto3" json:"repair_signature,omitempty" pg:"repair_signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *RequestRepairContracts) Reset()         { *m = RequestRepairContracts{} }
func (m *RequestRepairContracts) String() string { return proto.CompactTextString(m) }
func (*RequestRepairContracts) ProtoMessage()    {}
func (*RequestRepairContracts) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{26}
}
func (m *RequestRepairContracts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestRepairContracts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestRepairContracts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestRepairContracts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestRepairContracts.Merge(m, src)
}
func (m *RequestRepairContracts) XXX_Size() int {
	return m.Size()
}
func (m *RequestRepairContracts) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestRepairContracts.DiscardUnknown(m)
}

var xxx_messageInfo_RequestRepairContracts proto.InternalMessageInfo

func (m *RequestRepairContracts) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *RequestRepairContracts) GetRepairNode() string {
	if m != nil {
		return m.RepairNode
	}
	return ""
}

func (m *RequestRepairContracts) GetRepairSignTime() time.Time {
	if m != nil {
		return m.RepairSignTime
	}
	return time.Time{}
}

func (m *RequestRepairContracts) GetRepairSignature() []byte {
	if m != nil {
		return m.RepairSignature
	}
	return nil
}

func (*RequestRepairContracts) XXX_MessageName() string {
	return "guard.RequestRepairContracts"
}

type ResponseRepairContracts struct {
	FileHash             string                             `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RepairNode           string                             `protobuf:"bytes,2,opt,name=repair_node,json=repairNode,proto3" json:"repair_node,omitempty" pg:"repair_node"`
	State                ResponseRepairContracts_RepairStat `protobuf:"varint,3,opt,name=state,proto3,enum=guard.ResponseRepairContracts_RepairStat" json:"state,omitempty" pg:"state"`
	Status               *FileStoreStatus                   `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty" pg:"status"`
	GuardPid             string                             `protobuf:"bytes,5,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	SignTime             time.Time                          `protobuf:"bytes,6,opt,name=sign_time,json=signTime,proto3,stdtime" json:"sign_time" pg:"sign_time"`
	GuardSignature       []byte                             `protobuf:"bytes,7,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-" pg:"-"`
	XXX_unrecognized     []byte                             `json:"-" pg:"-"`
	XXX_sizecache        int32                              `json:"-" pg:"-"`
}

func (m *ResponseRepairContracts) Reset()         { *m = ResponseRepairContracts{} }
func (m *ResponseRepairContracts) String() string { return proto.CompactTextString(m) }
func (*ResponseRepairContracts) ProtoMessage()    {}
func (*ResponseRepairContracts) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{27}
}
func (m *ResponseRepairContracts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseRepairContracts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseRepairContracts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseRepairContracts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseRepairContracts.Merge(m, src)
}
func (m *ResponseRepairContracts) XXX_Size() int {
	return m.Size()
}
func (m *ResponseRepairContracts) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseRepairContracts.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseRepairContracts proto.InternalMessageInfo

func (m *ResponseRepairContracts) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ResponseRepairContracts) GetRepairNode() string {
	if m != nil {
		return m.RepairNode
	}
	return ""
}

func (m *ResponseRepairContracts) GetState() ResponseRepairContracts_RepairStat {
	if m != nil {
		return m.State
	}
	return ResponseRepairContracts_CONTRACT_READY
}

func (m *ResponseRepairContracts) GetStatus() *FileStoreStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ResponseRepairContracts) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ResponseRepairContracts) GetSignTime() time.Time {
	if m != nil {
		return m.SignTime
	}
	return time.Time{}
}

func (m *ResponseRepairContracts) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (*ResponseRepairContracts) XXX_MessageName() string {
	return "guard.ResponseRepairContracts"
}

type CancelContractRequest struct {
	FileHash             string                             `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string                             `protobuf:"bytes,2,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	ContractId           string                             `protobuf:"bytes,3,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty" pg:"contract_id"`
	RenterPid            string                             `protobuf:"bytes,4,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	HostPid              string                             `protobuf:"bytes,5,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	Reason               CancelContractRequest_CancelReason `protobuf:"varint,6,opt,name=reason,proto3,enum=guard.CancelContractRequest_CancelReason" json:"reason,omitempty" pg:"reason"`
	SignTime             time.Time                          `protobuf:"bytes,7,opt,name=sign_time,json=signTime,proto3,stdtime" json:"sign_time" pg:"sign_time"`
	Signature            []byte                             `protobuf:"bytes,8,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-" pg:"-"`
	XXX_unrecognized     []byte                             `json:"-" pg:"-"`
	XXX_sizecache        int32                              `json:"-" pg:"-"`
}

func (m *CancelContractRequest) Reset()         { *m = CancelContractRequest{} }
func (m *CancelContractRequest) String() string { return proto.CompactTextString(m) }
func (*CancelContractRequest) ProtoMessage()    {}
func (*CancelContractRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{28}
}
func (m *CancelContractRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelContractRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelContractRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelContractRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelContractRequest.Merge(m, src)
}
func (m *CancelContractRequest) XXX_Size() int {
	return m.Size()
}
func (m *CancelContractRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelContractRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelContractRequest proto.InternalMessageInfo

func (m *CancelContractRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *CancelContractRequest) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *CancelContractRequest) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *CancelContractRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *CancelContractRequest) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *CancelContractRequest) GetReason() CancelContractRequest_CancelReason {
	if m != nil {
		return m.Reason
	}
	return CancelContractRequest_HOST_REQUEST
}

func (m *CancelContractRequest) GetSignTime() time.Time {
	if m != nil {
		return m.SignTime
	}
	return time.Time{}
}

func (m *CancelContractRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*CancelContractRequest) XXX_MessageName() string {
	return "guard.CancelContractRequest"
}

type ChallengeJobRequest struct {
	NodePid              string    `protobuf:"bytes,1,opt,name=node_pid,json=nodePid,proto3" json:"node_pid,omitempty" pg:"node_pid"`
	RequestTime          time.Time `protobuf:"bytes,2,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time" pg:"request_time"`
	Signature            []byte    `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *ChallengeJobRequest) Reset()         { *m = ChallengeJobRequest{} }
func (m *ChallengeJobRequest) String() string { return proto.CompactTextString(m) }
func (*ChallengeJobRequest) ProtoMessage()    {}
func (*ChallengeJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{29}
}
func (m *ChallengeJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeJobRequest.Merge(m, src)
}
func (m *ChallengeJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeJobRequest proto.InternalMessageInfo

func (m *ChallengeJobRequest) GetNodePid() string {
	if m != nil {
		return m.NodePid
	}
	return ""
}

func (m *ChallengeJobRequest) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *ChallengeJobRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ChallengeJobRequest) XXX_MessageName() string {
	return "guard.ChallengeJobRequest"
}

type ChallengeJobResponse struct {
	NodePid               string    `protobuf:"bytes,1,opt,name=node_pid,json=nodePid,proto3" json:"node_pid,omitempty" pg:"node_pid"`
	IssuerPid             string    `protobuf:"bytes,2,opt,name=issuer_pid,json=issuerPid,proto3" json:"issuer_pid,omitempty" pg:"issuer_pid"`
	JobId                 string    `protobuf:"bytes,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty" pg:"job_id"`
	PackageUrl            string    `protobuf:"bytes,4,opt,name=package_url,json=packageUrl,proto3" json:"package_url,omitempty" pg:"package_url"`
	PackageQuestionsCount int32     `protobuf:"varint,5,opt,name=package_questions_count,json=packageQuestionsCount,proto3" json:"package_questions_count,omitempty" pg:"package_questions_count"`
	SendTime              time.Time `protobuf:"bytes,6,opt,name=send_time,json=sendTime,proto3,stdtime" json:"send_time" pg:"send_time"`
	JobFinishDeadline     time.Time `protobuf:"bytes,7,opt,name=job_finish_deadline,json=jobFinishDeadline,proto3,stdtime" json:"job_finish_deadline" pg:"job_finish_deadline"`
	Signature             []byte    `protobuf:"bytes,8,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral  struct{}  `json:"-" pg:"-"`
	XXX_unrecognized      []byte    `json:"-" pg:"-"`
	XXX_sizecache         int32     `json:"-" pg:"-"`
}

func (m *ChallengeJobResponse) Reset()         { *m = ChallengeJobResponse{} }
func (m *ChallengeJobResponse) String() string { return proto.CompactTextString(m) }
func (*ChallengeJobResponse) ProtoMessage()    {}
func (*ChallengeJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{30}
}
func (m *ChallengeJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeJobResponse.Merge(m, src)
}
func (m *ChallengeJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeJobResponse proto.InternalMessageInfo

func (m *ChallengeJobResponse) GetNodePid() string {
	if m != nil {
		return m.NodePid
	}
	return ""
}

func (m *ChallengeJobResponse) GetIssuerPid() string {
	if m != nil {
		return m.IssuerPid
	}
	return ""
}

func (m *ChallengeJobResponse) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *ChallengeJobResponse) GetPackageUrl() string {
	if m != nil {
		return m.PackageUrl
	}
	return ""
}

func (m *ChallengeJobResponse) GetPackageQuestionsCount() int32 {
	if m != nil {
		return m.PackageQuestionsCount
	}
	return 0
}

func (m *ChallengeJobResponse) GetSendTime() time.Time {
	if m != nil {
		return m.SendTime
	}
	return time.Time{}
}

func (m *ChallengeJobResponse) GetJobFinishDeadline() time.Time {
	if m != nil {
		return m.JobFinishDeadline
	}
	return time.Time{}
}

func (m *ChallengeJobResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ChallengeJobResponse) XXX_MessageName() string {
	return "guard.ChallengeJobResponse"
}

type ChallengeJobResult struct {
	NodePid              string                  `protobuf:"bytes,1,opt,name=node_pid,json=nodePid,proto3" json:"node_pid,omitempty" pg:"node_pid"`
	JobId                string                  `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty" pg:"job_id"`
	Result               []*ShardChallengeResult `protobuf:"bytes,3,rep,name=result,proto3" json:"result,omitempty" pg:"result"`
	SubmitTime           time.Time               `protobuf:"bytes,4,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time" pg:"submit_time"`
	Signature            []byte                  `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-" pg:"-"`
	XXX_unrecognized     []byte                  `json:"-" pg:"-"`
	XXX_sizecache        int32                   `json:"-" pg:"-"`
}

func (m *ChallengeJobResult) Reset()         { *m = ChallengeJobResult{} }
func (m *ChallengeJobResult) String() string { return proto.CompactTextString(m) }
func (*ChallengeJobResult) ProtoMessage()    {}
func (*ChallengeJobResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{31}
}
func (m *ChallengeJobResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeJobResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeJobResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeJobResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeJobResult.Merge(m, src)
}
func (m *ChallengeJobResult) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeJobResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeJobResult.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeJobResult proto.InternalMessageInfo

func (m *ChallengeJobResult) GetNodePid() string {
	if m != nil {
		return m.NodePid
	}
	return ""
}

func (m *ChallengeJobResult) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *ChallengeJobResult) GetResult() []*ShardChallengeResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ChallengeJobResult) GetSubmitTime() time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return time.Time{}
}

func (m *ChallengeJobResult) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ChallengeJobResult) XXX_MessageName() string {
	return "guard.ChallengeJobResult"
}

type ShardChallengeResult struct {
	HostPid              string   `protobuf:"bytes,1,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	FileHash             string   `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string   `protobuf:"bytes,3,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	Nonce                string   `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty" pg:"nonce"`
	Result               string   `protobuf:"bytes,5,opt,name=result,proto3" json:"result,omitempty" pg:"result"`
	IsTimeout            bool     `protobuf:"varint,6,opt,name=is_timeout,json=isTimeout,proto3" json:"is_timeout,omitempty" pg:"is_timeout"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *ShardChallengeResult) Reset()         { *m = ShardChallengeResult{} }
func (m *ShardChallengeResult) String() string { return proto.CompactTextString(m) }
func (*ShardChallengeResult) ProtoMessage()    {}
func (*ShardChallengeResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{32}
}
func (m *ShardChallengeResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardChallengeResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardChallengeResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardChallengeResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardChallengeResult.Merge(m, src)
}
func (m *ShardChallengeResult) XXX_Size() int {
	return m.Size()
}
func (m *ShardChallengeResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardChallengeResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShardChallengeResult proto.InternalMessageInfo

func (m *ShardChallengeResult) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ShardChallengeResult) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ShardChallengeResult) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ShardChallengeResult) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *ShardChallengeResult) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *ShardChallengeResult) GetIsTimeout() bool {
	if m != nil {
		return m.IsTimeout
	}
	return false
}

func (*ShardChallengeResult) XXX_MessageName() string {
	return "guard.ShardChallengeResult"
}

type DeCentralQuestions struct {
	Qs                   []*DeQuestion `protobuf:"bytes,1,rep,name=qs,proto3" json:"qs,omitempty" pg:"qs"`
	Count                int32         `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty" pg:"count"`
	Uuid                 string        `protobuf:"bytes,3,opt,name=uuid,proto3" json:"uuid,omitempty" pg:"uuid"`
	Url                  string        `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty" pg:"url"`
	EndTime              *time.Time    `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty" pg:"end_time"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-" pg:"-"`
	XXX_unrecognized     []byte        `json:"-" pg:"-"`
	XXX_sizecache        int32         `json:"-" pg:"-"`
}

func (m *DeCentralQuestions) Reset()         { *m = DeCentralQuestions{} }
func (m *DeCentralQuestions) String() string { return proto.CompactTextString(m) }
func (*DeCentralQuestions) ProtoMessage()    {}
func (*DeCentralQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{33}
}
func (m *DeCentralQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeCentralQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeCentralQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeCentralQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeCentralQuestions.Merge(m, src)
}
func (m *DeCentralQuestions) XXX_Size() int {
	return m.Size()
}
func (m *DeCentralQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_DeCentralQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_DeCentralQuestions proto.InternalMessageInfo

func (m *DeCentralQuestions) GetQs() []*DeQuestion {
	if m != nil {
		return m.Qs
	}
	return nil
}

func (m *DeCentralQuestions) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *DeCentralQuestions) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *DeCentralQuestions) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *DeCentralQuestions) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (*DeCentralQuestions) XXX_MessageName() string {
	return "guard.DeCentralQuestions"
}

type DeQuestion struct {
	ShardHash            string   `protobuf:"bytes,1,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	HostPid              string   `protobuf:"bytes,2,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ChunkIndex           int32    `protobuf:"varint,3,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty" pg:"chunk_index"`
	Nonce                string   `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty" pg:"nonce"`
	FileHash             string   `protobuf:"bytes,5,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *DeQuestion) Reset()         { *m = DeQuestion{} }
func (m *DeQuestion) String() string { return proto.CompactTextString(m) }
func (*DeQuestion) ProtoMessage()    {}
func (*DeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{34}
}
func (m *DeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeQuestion.Merge(m, src)
}
func (m *DeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *DeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_DeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_DeQuestion proto.InternalMessageInfo

func (m *DeQuestion) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *DeQuestion) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *DeQuestion) GetChunkIndex() int32 {
	if m != nil {
		return m.ChunkIndex
	}
	return 0
}

func (m *DeQuestion) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *DeQuestion) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (*DeQuestion) XXX_MessageName() string {
	return "guard.DeQuestion"
}
func init() {
	proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	golang_proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	golang_proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	golang_proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	golang_proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	proto.RegisterEnum("guard.FileStoreStatus_RentalState", FileStoreStatus_RentalState_name, FileStoreStatus_RentalState_value)
	golang_proto.RegisterEnum("guard.FileStoreStatus_RentalState", FileStoreStatus_RentalState_name, FileStoreStatus_RentalState_value)
	proto.RegisterEnum("guard.ListHostContractsRequest_SelectState", ListHostContractsRequest_SelectState_name, ListHostContractsRequest_SelectState_value)
	golang_proto.RegisterEnum("guard.ListHostContractsRequest_SelectState", ListHostContractsRequest_SelectState_name, ListHostContractsRequest_SelectState_value)
	proto.RegisterEnum("guard.RepairContractResponse_ContractResponseStatus", RepairContractResponse_ContractResponseStatus_name, RepairContractResponse_ContractResponseStatus_value)
	golang_proto.RegisterEnum("guard.RepairContractResponse_ContractResponseStatus", RepairContractResponse_ContractResponseStatus_name, RepairContractResponse_ContractResponseStatus_value)
	proto.RegisterEnum("guard.ResponseRepairContracts_RepairStat", ResponseRepairContracts_RepairStat_name, ResponseRepairContracts_RepairStat_value)
	golang_proto.RegisterEnum("guard.ResponseRepairContracts_RepairStat", ResponseRepairContracts_RepairStat_name, ResponseRepairContracts_RepairStat_value)
	proto.RegisterEnum("guard.CancelContractRequest_CancelReason", CancelContractRequest_CancelReason_name, CancelContractRequest_CancelReason_value)
	golang_proto.RegisterEnum("guard.CancelContractRequest_CancelReason", CancelContractRequest_CancelReason_name, CancelContractRequest_CancelReason_value)
	proto.RegisterType((*AdminQuery)(nil), "guard.AdminQuery")
	golang_proto.RegisterType((*AdminQuery)(nil), "guard.AdminQuery")
	proto.RegisterType((*DailySummary)(nil), "guard.DailySummary")
	golang_proto.RegisterType((*DailySummary)(nil), "guard.DailySummary")
	proto.RegisterType((*HostSummary)(nil), "guard.HostSummary")
	golang_proto.RegisterType((*HostSummary)(nil), "guard.HostSummary")
	proto.RegisterType((*TotalStateSummary)(nil), "guard.TotalStateSummary")
	golang_proto.RegisterType((*TotalStateSummary)(nil), "guard.TotalStateSummary")
	proto.RegisterType((*HostStatus)(nil), "guard.HostStatus")
	golang_proto.RegisterType((*HostStatus)(nil), "guard.HostStatus")
	proto.RegisterType((*Log)(nil), "guard.Log")
	golang_proto.RegisterType((*Log)(nil), "guard.Log")
	proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	golang_proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	proto.RegisterType((*Contract)(nil), "guard.Contract")
	golang_proto.RegisterType((*Contract)(nil), "guard.Contract")
	proto.RegisterType((*FileStoreListResponse)(nil), "guard.FileStoreListResponse")
	golang_proto.RegisterType((*FileStoreListResponse)(nil), "guard.FileStoreListResponse")
	proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	golang_proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	golang_proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	golang_proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	golang_proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	golang_proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	golang_proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	golang_proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	proto.RegisterType((*ListRenterFileInfoRequest)(nil), "guard.ListRenterFileInfoRequest")
	golang_proto.RegisterType((*ListRenterFileInfoRequest)(nil), "guard.ListRenterFileInfoRequest")
	proto.RegisterType((*ListHostContractsRequest)(nil), "guard.ListHostContractsRequest")
	golang_proto.RegisterType((*ListHostContractsRequest)(nil), "guard.ListHostContractsRequest")
	proto.RegisterType((*ContractsList)(nil), "guard.ContractsList")
	golang_proto.RegisterType((*ContractsList)(nil), "guard.ContractsList")
	proto.RegisterType((*ReadyForChallengeRequest)(nil), "guard.ReadyForChallengeRequest")
	golang_proto.RegisterType((*ReadyForChallengeRequest)(nil), "guard.ReadyForChallengeRequest")
	proto.RegisterType((*RequestChallengeQuestion)(nil), "guard.RequestChallengeQuestion")
	golang_proto.RegisterType((*RequestChallengeQuestion)(nil), "guard.RequestChallengeQuestion")
	proto.RegisterType((*ResponseChallengeQuestion)(nil), "guard.ResponseChallengeQuestion")
	golang_proto.RegisterType((*ResponseChallengeQuestion)(nil), "guard.ResponseChallengeQuestion")
	proto.RegisterType((*ForceRepairRequest)(nil), "guard.ForceRepairRequest")
	golang_proto.RegisterType((*ForceRepairRequest)(nil), "guard.ForceRepairRequest")
	proto.RegisterType((*Result)(nil), "guard.Result")
	golang_proto.RegisterType((*Result)(nil), "guard.Result")
	proto.RegisterType((*RepairContract)(nil), "guard.RepairContract")
	golang_proto.RegisterType((*RepairContract)(nil), "guard.RepairContract")
	proto.RegisterType((*RepairContractResponse)(nil), "guard.RepairContractResponse")
	golang_proto.RegisterType((*RepairContractResponse)(nil), "guard.RepairContractResponse")
	proto.RegisterType((*RequestRepairContracts)(nil), "guard.RequestRepairContracts")
	golang_proto.RegisterType((*RequestRepairContracts)(nil), "guard.RequestRepairContracts")
	proto.RegisterType((*ResponseRepairContracts)(nil), "guard.ResponseRepairContracts")
	golang_proto.RegisterType((*ResponseRepairContracts)(nil), "guard.ResponseRepairContracts")
	proto.RegisterType((*CancelContractRequest)(nil), "guard.CancelContractRequest")
	golang_proto.RegisterType((*CancelContractRequest)(nil), "guard.CancelContractRequest")
	proto.RegisterType((*ChallengeJobRequest)(nil), "guard.ChallengeJobRequest")
	golang_proto.RegisterType((*ChallengeJobRequest)(nil), "guard.ChallengeJobRequest")
	proto.RegisterType((*ChallengeJobResponse)(nil), "guard.ChallengeJobResponse")
	golang_proto.RegisterType((*ChallengeJobResponse)(nil), "guard.ChallengeJobResponse")
	proto.RegisterType((*ChallengeJobResult)(nil), "guard.ChallengeJobResult")
	golang_proto.RegisterType((*ChallengeJobResult)(nil), "guard.ChallengeJobResult")
	proto.RegisterType((*ShardChallengeResult)(nil), "guard.ShardChallengeResult")
	golang_proto.RegisterType((*ShardChallengeResult)(nil), "guard.ShardChallengeResult")
	proto.RegisterType((*DeCentralQuestions)(nil), "guard.DeCentralQuestions")
	golang_proto.RegisterType((*DeCentralQuestions)(nil), "guard.DeCentralQuestions")
	proto.RegisterType((*DeQuestion)(nil), "guard.DeQuestion")
	golang_proto.RegisterType((*DeQuestion)(nil), "guard.DeQuestion")
}

func init() { proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }
func init() { golang_proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }

var fileDescriptor_ad5b6eccdc9ebee8 = []byte{
	// 4086 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x3b, 0x4d, 0x6f, 0x1b, 0x49,
	0x76, 0x6e, 0x7e, 0x88, 0xe4, 0xe3, 0x57, 0xab, 0x2c, 0xc9, 0x94, 0x3c, 0x96, 0x3c, 0x5c, 0xcc,
	0x8e, 0x3d, 0x3b, 0xa3, 0x99, 0x78, 0x8c, 0x09, 0x36, 0xfb, 0x15, 0x9a, 0x6c, 0xd9, 0x72, 0x68,
	0x52, 0x6e, 0x52, 0x71, 0xbc, 0x08, 0xd0, 0x68, 0x91, 0x25, 0xa9, 0xc7, 0x54, 0xb7, 0xdc, 0xdd,
	0xb4, 0xec, 0x3d, 0xe4, 0x90, 0x5b, 0x10, 0x20, 0xc8, 0x29, 0x09, 0xf6, 0x07, 0x04, 0xd8, 0x20,
	0x40, 0x82, 0x00, 0xb9, 0xe4, 0x10, 0xe4, 0x38, 0x41, 0x02, 0x64, 0x73, 0x48, 0x8e, 0xfb, 0x31,
	0xf3, 0x07, 0x92, 0x53, 0xf6, 0x10, 0x04, 0x41, 0xd5, 0xab, 0xea, 0x2f, 0xb6, 0x28, 0x51, 0x31,
	0xb2, 0xc0, 0x5e, 0x04, 0xd5, 0xab, 0xf7, 0xea, 0xe3, 0x7d, 0xbf, 0x57, 0x4d, 0x68, 0x9c, 0xba,
	0x8e, 0xef, 0x78, 0x1f, 0x1f, 0x4d, 0x4d, 0x77, 0x8c, 0x7f, 0xb7, 0x39, 0x88, 0xe4, 0xf9, 0x60,
	0xe3, 0x93, 0x23, 0xcb, 0x3f, 0x9e, 0x1e, 0x6c, 0x8f, 0x9c, 0x93, 0x8f, 0x7d, 0xd7, 0xb1, 0x3f,
	0x9a, 0x7a, 0x1f, 0x73, 0x84, 0x83, 0xe9, 0xe1, 0xc7, 0x47, 0xce, 0x91, 0xc3, 0x07, 0xfc, 0x3f,
	0x24, 0xdc, 0xd8, 0x3a, 0x72, 0x9c, 0xa3, 0x09, 0x0d, 0xb1, 0x7c, 0xeb, 0x84, 0x7a, 0xbe, 0x79,
	0x72, 0x8a, 0x08, 0xcd, 0xff, 0x51, 0x00, 0x5a, 0xe3, 0x13, 0xcb, 0x7e, 0x3a, 0xa5, 0xee, 0x1b,
	0xf2, 0x35, 0xa8, 0xba, 0xf4, 0xe5, 0x94, 0x7a, 0x3e, 0x75, 0x8d, 0x53, 0x6b, 0xdc, 0x50, 0x6e,
	0x2b, 0x77, 0x4a, 0x7a, 0x25, 0x00, 0xee, 0x59, 0x63, 0xd2, 0x06, 0x78, 0xc9, 0xb0, 0x8d, 0xb1,
	0xe9, 0xd3, 0x46, 0xe6, 0xb6, 0x72, 0xa7, 0x7c, 0x6f, 0x63, 0x1b, 0x77, 0xda, 0x96, 0x3b, 0x6d,
	0x0f, 0xe5, 0x4e, 0x0f, 0x8a, 0x5f, 0xfc, 0x64, 0xeb, 0xda, 0x1f, 0xff, 0x74, 0x4b, 0xd1, 0x4b,
	0x9c, 0xae, 0x63, 0xfa, 0x94, 0x6c, 0x41, 0x19, 0x17, 0x19, 0x39, 0x53, 0xdb, 0x6f, 0x64, 0x6f,
	0x2b, 0x77, 0xf2, 0x3a, 0xae, 0xdb, 0x66, 0x10, 0xf2, 0x10, 0xe4, 0xae, 0x06, 0x3b, 0x74, 0x23,
	0xb7, 0xc0, 0x3e, 0x65, 0x41, 0xc9, 0xe6, 0xc8, 0x3b, 0x50, 0xf2, 0xac, 0x23, 0xdb, 0xf4, 0xa7,
	0x2e, 0x6d, 0xe4, 0x6f, 0x2b, 0x77, 0x2a, 0x7a, 0x08, 0x68, 0xfe, 0x30, 0x07, 0x95, 0x8e, 0x69,
	0x4d, 0xde, 0x0c, 0xa6, 0x27, 0x27, 0xa6, 0xfb, 0x26, 0x71, 0x3b, 0xe5, 0x6a, 0xb7, 0xdb, 0x65,
	0x7c, 0xf4, 0x4e, 0x1d, 0xdb, 0xa3, 0x78, 0xfa, 0x45, 0xb8, 0x54, 0x91, 0xa4, 0xfc, 0xf8, 0xef,
	0x42, 0xe5, 0xd4, 0xa5, 0xa7, 0xa6, 0x2b, 0x24, 0x92, 0xe5, 0x12, 0x29, 0x4b, 0x18, 0x13, 0x48,
	0xec, 0x86, 0xb9, 0xc4, 0x0d, 0xc9, 0x27, 0xb0, 0x72, 0xe6, 0xb8, 0x2f, 0x2c, 0xfb, 0xc8, 0xf0,
	0x7c, 0xc7, 0x35, 0x8f, 0xa8, 0xe1, 0x59, 0x3f, 0x40, 0x56, 0x64, 0x75, 0x22, 0xe6, 0x06, 0x38,
	0x35, 0xb0, 0x7e, 0x40, 0x99, 0x16, 0xd8, 0xf4, 0xcc, 0x18, 0x39, 0xb6, 0xef, 0x9a, 0x23, 0xdf,
	0x6b, 0x2c, 0x71, 0xd4, 0x8a, 0x4d, 0xcf, 0xda, 0x12, 0x46, 0x3e, 0x04, 0x12, 0x43, 0x32, 0x8e,
	0x1d, 0xcf, 0x6f, 0x14, 0x38, 0xa6, 0x1a, 0xc5, 0x7c, 0xe4, 0x78, 0x3e, 0x3b, 0x44, 0x1c, 0xdb,
	0xa5, 0xb6, 0x4f, 0xdd, 0x46, 0x11, 0x0f, 0x11, 0xc5, 0xd7, 0xf9, 0x0c, 0xf9, 0x0e, 0xdc, 0x8c,
	0x53, 0x98, 0xaf, 0x28, 0x3f, 0xfc, 0xa9, 0x6b, 0x8d, 0x68, 0xa3, 0xc4, 0x09, 0x1b, 0x51, 0xc2,
	0x16, 0x22, 0xec, 0xb1, 0x79, 0x72, 0x13, 0x4a, 0x8c, 0xfc, 0xd0, 0x9a, 0x50, 0xaf, 0x01, 0x1c,
	0xb9, 0x68, 0xd3, 0xb3, 0x1d, 0x36, 0x26, 0x5f, 0x87, 0x3a, 0x9b, 0xf4, 0x8e, 0x4d, 0x77, 0xec,
	0x21, 0x37, 0xca, 0x1c, 0x85, 0xdd, 0x7b, 0xc0, 0xa1, 0x8c, 0x11, 0xcd, 0xbf, 0xcc, 0x40, 0x99,
	0x1d, 0xff, 0x57, 0x56, 0x37, 0xde, 0x65, 0x46, 0x36, 0x72, 0xdc, 0xb1, 0x30, 0xc3, 0x3c, 0x37,
	0xc3, 0x32, 0xc2, 0xd0, 0x0e, 0xef, 0xc2, 0x92, 0xe7, 0x9b, 0xfe, 0x94, 0x69, 0x41, 0xf6, 0x4e,
	0xf9, 0xde, 0xf2, 0x36, 0x7a, 0x26, 0xce, 0x17, 0x3e, 0xa1, 0x0b, 0x84, 0xe6, 0x7f, 0xe7, 0x60,
	0x79, 0xe8, 0xf8, 0xe6, 0x84, 0xc1, 0xe9, 0xaf, 0xb2, 0x41, 0xbd, 0x32, 0x27, 0xd6, 0x38, 0xd0,
	0xcd, 0x08, 0xf3, 0xb2, 0x3a, 0xe1, 0x73, 0x52, 0x29, 0x91, 0x87, 0x1f, 0x02, 0xa1, 0xaf, 0x2d,
	0xcf, 0xa7, 0x63, 0xd4, 0x39, 0x54, 0x39, 0xb4, 0x2a, 0x55, 0xcc, 0x70, 0xb5, 0xe3, 0xe6, 0x77,
	0x1f, 0xd6, 0x2c, 0x3b, 0x75, 0x07, 0xb4, 0xae, 0x15, 0x31, 0x1b, 0xdf, 0xe3, 0xeb, 0x50, 0x9f,
	0x38, 0x9e, 0x1f, 0xdd, 0x00, 0x8d, 0xab, 0xca, 0xc0, 0xe1, 0xea, 0x1f, 0xc0, 0xb2, 0xcf, 0x64,
	0xc4, 0xed, 0xd5, 0x70, 0xe9, 0x99, 0xe9, 0x8e, 0x85, 0x35, 0xd5, 0xf9, 0x04, 0x13, 0xac, 0xce,
	0xc1, 0x21, 0xee, 0xd9, 0x81, 0x1f, 0xe0, 0x42, 0x04, 0xf7, 0xd9, 0x81, 0x2f, 0x71, 0xef, 0x80,
	0x8a, 0xb8, 0xbe, 0xfb, 0x5a, 0xa2, 0xa2, 0x51, 0xd5, 0x38, 0x7c, 0xe8, 0xbe, 0x4e, 0xae, 0x3a,
	0xf5, 0xc6, 0x63, 0x89, 0x5a, 0x89, 0xac, 0xba, 0xef, 0x8d, 0xc7, 0x29, 0xb8, 0xc1, 0x09, 0xaa,
	0x71, 0x5c, 0x71, 0x82, 0xe6, 0x8f, 0x14, 0x80, 0x50, 0x2b, 0xc9, 0x3a, 0x14, 0xf9, 0x15, 0xc3,
	0x30, 0x56, 0x60, 0x63, 0x26, 0xdf, 0x9b, 0x50, 0x62, 0x8e, 0x01, 0xb9, 0x94, 0x41, 0xe7, 0xc0,
	0x00, 0x9c, 0x41, 0x5b, 0x50, 0x66, 0x3e, 0xd1, 0x30, 0x4f, 0x82, 0xc8, 0x94, 0xd5, 0x81, 0x81,
	0x5a, 0x1c, 0x42, 0x6e, 0x01, 0xe0, 0x41, 0x8c, 0x03, 0xdf, 0xe7, 0xea, 0x91, 0xd5, 0x4b, 0x08,
	0x79, 0xe0, 0xfb, 0xcc, 0x7b, 0x7a, 0x53, 0xef, 0x94, 0x32, 0xa9, 0x1d, 0x53, 0x13, 0xf5, 0xa2,
	0xa8, 0x57, 0x04, 0xb0, 0xcd, 0x60, 0xcd, 0x3f, 0x54, 0x20, 0xdb, 0x75, 0x8e, 0x88, 0x06, 0xe5,
	0xd1, 0xb1, 0x69, 0x1f, 0x09, 0xad, 0x5e, 0xc4, 0x3a, 0x00, 0x09, 0xb9, 0x4e, 0xbf, 0x07, 0x35,
	0xc7, 0xb5, 0x8e, 0x2c, 0xdb, 0xf4, 0x1d, 0xd4, 0xea, 0x0c, 0xbf, 0x71, 0x35, 0x84, 0xb2, 0x7b,
	0xaf, 0xc1, 0x12, 0x12, 0x09, 0xa5, 0x17, 0xa3, 0xe6, 0xbf, 0xe7, 0xa1, 0x22, 0xb5, 0xe9, 0x09,
	0xf5, 0x4d, 0xc6, 0x83, 0x40, 0xf5, 0x02, 0xf6, 0x81, 0x04, 0xed, 0x8e, 0x91, 0x07, 0xb6, 0xcc,
	0x12, 0x70, 0xb3, 0x12, 0x42, 0xd8, 0x46, 0x51, 0xde, 0x67, 0xe3, 0xbc, 0xbf, 0x05, 0x80, 0x2a,
	0x7a, 0x6c, 0x7a, 0xc7, 0x9c, 0x7b, 0x25, 0xbd, 0xc4, 0x21, 0x8f, 0x4c, 0xef, 0x98, 0xed, 0x8c,
	0xd3, 0x96, 0x3d, 0xa6, 0xaf, 0x85, 0x43, 0x42, 0x8a, 0x5d, 0x06, 0x61, 0x7a, 0x8e, 0x08, 0xa1,
	0x04, 0xd1, 0x90, 0xaa, 0x1c, 0xbc, 0x23, 0xc5, 0x28, 0x65, 0xcc, 0xb7, 0x29, 0xf0, 0x6d, 0xb8,
	0x8c, 0xf9, 0x2e, 0x6d, 0x3c, 0xbe, 0xe1, 0xf9, 0xa6, 0xeb, 0x73, 0x3b, 0xb9, 0xb4, 0x4f, 0x62,
	0x74, 0x03, 0x46, 0x46, 0xbe, 0x07, 0x45, 0xbe, 0x08, 0xb5, 0xd1, 0x80, 0x2e, 0xbb, 0x44, 0x81,
	0x51, 0x69, 0x36, 0x57, 0x43, 0xee, 0x4b, 0x39, 0x9b, 0x00, 0x8f, 0xc8, 0x01, 0x82, 0x4f, 0xd4,
	0x1b, 0xb9, 0xce, 0x19, 0x9f, 0x2d, 0x23, 0x9f, 0x10, 0xc2, 0xa6, 0x57, 0x20, 0x8f, 0x81, 0x10,
	0x0d, 0x07, 0x07, 0x4c, 0xc0, 0x42, 0x6d, 0xd1, 0x46, 0xc4, 0x88, 0x7c, 0x03, 0x96, 0x47, 0xce,
	0x64, 0x62, 0xfa, 0xd4, 0x35, 0x27, 0x52, 0xb3, 0x6b, 0xe8, 0x7f, 0xc2, 0x09, 0xa1, 0xdf, 0x1a,
	0xd4, 0x4f, 0xcd, 0x37, 0xce, 0xd4, 0x37, 0xbc, 0xd1, 0x31, 0x1d, 0x4f, 0x27, 0xb4, 0x51, 0xbf,
	0xad, 0xdc, 0xa9, 0xdd, 0x7b, 0x47, 0xb8, 0xfe, 0xa8, 0xaa, 0x6c, 0x0f, 0x04, 0x8e, 0x5e, 0x43,
	0x22, 0x39, 0x66, 0x92, 0xb4, 0xa7, 0x27, 0x06, 0x42, 0xbd, 0x86, 0x8a, 0x92, 0xb4, 0xa7, 0x27,
	0x7b, 0x08, 0xc1, 0x43, 0xd9, 0xbe, 0x65, 0x1f, 0x31, 0x2e, 0x8a, 0x43, 0x2d, 0xcb, 0x43, 0xc9,
	0x09, 0x3c, 0x54, 0xf3, 0x3e, 0x14, 0x83, 0x95, 0xcb, 0x50, 0x78, 0xd2, 0xef, 0x0d, 0x1f, 0x75,
	0x9f, 0xab, 0xd7, 0x48, 0x15, 0x4a, 0x4f, 0xf7, 0x5b, 0xfa, 0x50, 0xd3, 0xbb, 0xcf, 0x55, 0x85,
	0x54, 0xa0, 0xd8, 0xea, 0xf5, 0xf6, 0x5b, 0xdd, 0xee, 0x73, 0x35, 0xd3, 0xfc, 0xb7, 0x12, 0x14,
	0xe5, 0x69, 0xc9, 0x37, 0xa1, 0x28, 0x35, 0x58, 0x18, 0xda, 0xf5, 0x94, 0x0b, 0xa1, 0xa0, 0x7e,
	0xfc, 0x93, 0x2d, 0x45, 0x0f, 0xd0, 0xc9, 0xa7, 0x90, 0x67, 0x31, 0x0e, 0x9d, 0x45, 0xed, 0xde,
	0xad, 0x04, 0x5d, 0xf0, 0x0f, 0x0f, 0x7c, 0x3a, 0xe2, 0x92, 0xbb, 0xa0, 0x0a, 0x1b, 0x09, 0x83,
	0x49, 0x96, 0x07, 0x93, 0x3a, 0xc2, 0x07, 0x41, 0x48, 0x79, 0x0f, 0x6a, 0xdc, 0x5e, 0x92, 0x51,
	0xa7, 0xca, 0xa0, 0x21, 0x9a, 0x0e, 0x44, 0xe8, 0x04, 0x43, 0xa4, 0x63, 0x74, 0x1a, 0xf9, 0x05,
	0x74, 0x4f, 0x45, 0xfa, 0x01, 0x27, 0xe7, 0xae, 0xe3, 0x2e, 0xa8, 0x91, 0x35, 0x71, 0xf3, 0x25,
	0x3c, 0x65, 0x88, 0x2b, 0x03, 0x9f, 0xf0, 0x39, 0xc6, 0xc4, 0x39, 0x6a, 0x14, 0x78, 0x3a, 0x00,
	0x82, 0x15, 0x5d, 0xe7, 0xe8, 0x41, 0xfe, 0x2f, 0x7e, 0xba, 0xa5, 0x7c, 0xa4, 0x97, 0x10, 0x89,
	0xb9, 0xb7, 0x1e, 0xa8, 0x13, 0xd3, 0xf3, 0x8d, 0x13, 0x67, 0x6c, 0x1d, 0xbe, 0xc1, 0xe3, 0x2e,
	0x62, 0x6d, 0x35, 0x46, 0xfd, 0x84, 0x13, 0xf3, 0xc3, 0xbe, 0x0f, 0x75, 0xb4, 0x98, 0xf0, 0xac,
	0x25, 0x7e, 0xd6, 0x1a, 0x07, 0x0f, 0xa2, 0x89, 0x4d, 0x2c, 0xc8, 0xc3, 0x6c, 0x90, 0xff, 0x08,
	0x48, 0x80, 0x12, 0x2e, 0x57, 0xe6, 0xcb, 0x2d, 0xcb, 0x99, 0x70, 0xc5, 0x11, 0xdc, 0xe4, 0x57,
	0xf1, 0xa6, 0xa3, 0x11, 0xf5, 0x3c, 0x63, 0x74, 0x6c, 0x4e, 0x26, 0x34, 0xf0, 0xdc, 0x95, 0x05,
	0x6e, 0xd5, 0x60, 0x0b, 0x0d, 0x70, 0x9d, 0xb6, 0x5c, 0x86, 0xdf, 0x6f, 0x08, 0xd7, 0xf9, 0x26,
	0x89, 0xc5, 0xab, 0x0b, 0x2c, 0xbe, 0xcc, 0x16, 0x88, 0xaf, 0xfa, 0x3e, 0xd4, 0xe3, 0x0b, 0x7a,
	0xdc, 0xf6, 0xf3, 0x7a, 0x6d, 0x14, 0xc5, 0xf3, 0x58, 0x66, 0x13, 0x22, 0x9e, 0x99, 0xae, 0x2d,
	0xb0, 0xeb, 0x1c, 0x9b, 0x04, 0x73, 0xcf, 0x4c, 0xd7, 0x46, 0x8a, 0xcf, 0xe0, 0x46, 0x48, 0x21,
	0x59, 0x83, 0x44, 0x68, 0xf0, 0xab, 0xc1, 0xb4, 0xb8, 0x30, 0xd2, 0xfd, 0x2e, 0xdc, 0x38, 0xb4,
	0xdc, 0xd8, 0x4d, 0x05, 0x35, 0xf7, 0x00, 0x97, 0xbd, 0xec, 0x2a, 0x5f, 0xa4, 0x9d, 0xd8, 0x82,
	0x39, 0x47, 0xdf, 0x79, 0x41, 0xed, 0x06, 0xe1, 0x62, 0xc7, 0x41, 0xf3, 0x0b, 0x05, 0xaa, 0x31,
	0x43, 0x25, 0x25, 0xc8, 0x77, 0xf4, 0xd6, 0xce, 0x50, 0xbd, 0x46, 0x00, 0x96, 0x06, 0xbb, 0x0f,
	0x7b, 0x5a, 0x07, 0x7d, 0xc8, 0xfe, 0x5e, 0xb7, 0xdf, 0xea, 0x68, 0x1d, 0x35, 0x43, 0x8a, 0x90,
	0xeb, 0xf6, 0x07, 0x43, 0x35, 0xcb, 0xe0, 0xed, 0x56, 0xaf, 0xad, 0x75, 0xb5, 0x8e, 0x9a, 0x63,
	0x14, 0xed, 0x6e, 0x7f, 0xa0, 0x75, 0xd4, 0x3c, 0xf3, 0x48, 0xba, 0xd6, 0xd3, 0x9e, 0x69, 0x1d,
	0x75, 0x89, 0xa1, 0xf5, 0x1f, 0x0c, 0xfa, 0x5d, 0x6d, 0xa8, 0xa9, 0x05, 0x46, 0xfe, 0xac, 0xa5,
	0xf7, 0xd4, 0x22, 0xa9, 0x01, 0xf0, 0xdd, 0x0c, 0x3e, 0x2e, 0x91, 0xeb, 0x50, 0xd7, 0xb5, 0x56,
	0xe7, 0xb9, 0xd1, 0x7e, 0xd4, 0xea, 0x76, 0xb5, 0xde, 0x43, 0x4d, 0x05, 0xe6, 0xce, 0x74, 0xad,
	0xad, 0x6b, 0xad, 0xa1, 0xd6, 0x51, 0xcb, 0x64, 0x15, 0x96, 0x75, 0xed, 0xe9, 0xbe, 0x36, 0x18,
	0x46, 0xb0, 0x2a, 0xcd, 0x3f, 0xca, 0xc0, 0x2a, 0x8f, 0x74, 0xbe, 0xe3, 0xd2, 0xae, 0xc5, 0x12,
	0x36, 0xcc, 0x70, 0xc9, 0x6f, 0x40, 0x41, 0x14, 0xbf, 0xc2, 0xc7, 0xdd, 0x96, 0x06, 0xca, 0xb1,
	0x98, 0xdb, 0x61, 0x84, 0xbb, 0xf6, 0xa1, 0xa3, 0x23, 0x9e, 0x2e, 0x09, 0x58, 0xc9, 0x3d, 0x9a,
	0xba, 0x3c, 0xa6, 0x2d, 0x9c, 0x63, 0x97, 0x05, 0x25, 0x57, 0xb8, 0x6f, 0x43, 0x1d, 0xa3, 0x33,
	0x3b, 0x9e, 0x71, 0x42, 0x7d, 0xb3, 0x91, 0xe5, 0xde, 0x62, 0x45, 0x1c, 0x26, 0x38, 0x3b, 0xf3,
	0xb8, 0x7a, 0xf5, 0x30, 0x3a, 0x64, 0xd2, 0xc3, 0x74, 0x37, 0xc7, 0x35, 0x08, 0x07, 0x17, 0x94,
	0xf1, 0xff, 0x9c, 0x87, 0x6a, 0x6c, 0xd1, 0x44, 0x86, 0xa2, 0x24, 0x33, 0x94, 0x58, 0x7a, 0x90,
	0x49, 0xa4, 0x07, 0xb1, 0xfc, 0x30, 0x9b, 0xc8, 0x0f, 0xe3, 0xb9, 0x43, 0xee, 0xff, 0x9e, 0x3b,
	0xe4, 0xaf, 0x92, 0x3b, 0x70, 0x9b, 0xa6, 0xa3, 0x17, 0xc6, 0x21, 0x97, 0x9e, 0x3d, 0x7a, 0xc3,
	0xbd, 0x36, 0xb7, 0x69, 0x3a, 0x7a, 0xb1, 0x23, 0xa1, 0x61, 0x92, 0x71, 0x48, 0xa9, 0x28, 0x20,
	0x30, 0xc9, 0xd8, 0xa1, 0x34, 0x92, 0x64, 0xb0, 0x59, 0xac, 0x17, 0x44, 0x92, 0xc1, 0xa6, 0x83,
	0x64, 0x0c, 0xe5, 0x51, 0x8a, 0x24, 0x63, 0x58, 0x74, 0xbc, 0x07, 0xb5, 0x13, 0xcb, 0xb6, 0x4e,
	0xa6, 0x27, 0xa2, 0x98, 0xe6, 0x8e, 0x36, 0xaf, 0x57, 0x05, 0x14, 0x6b, 0x69, 0x16, 0xe9, 0x59,
	0x49, 0xf9, 0x8a, 0xba, 0x86, 0x7f, 0xec, 0x52, 0xef, 0xd8, 0x99, 0x60, 0x4a, 0x93, 0xd7, 0x55,
	0x31, 0x31, 0x94, 0xf0, 0x44, 0xe2, 0x53, 0x49, 0x26, 0x3e, 0xb1, 0xa4, 0xa9, 0x9a, 0x48, 0x9a,
	0xbe, 0x05, 0x1b, 0xdc, 0x6d, 0x25, 0xdc, 0x9d, 0x31, 0xb1, 0x4e, 0x2c, 0x5f, 0x38, 0xbd, 0x1b,
	0x0c, 0x23, 0xe6, 0x20, 0xbd, 0x2e, 0x9b, 0x26, 0x2d, 0xb8, 0x95, 0xee, 0xdc, 0x25, 0x3d, 0xba,
	0xc1, 0x0d, 0x2f, 0xc5, 0x73, 0x8b, 0x25, 0xb8, 0x03, 0x8d, 0x49, 0x85, 0xbb, 0x51, 0xe1, 0x0b,
	0x49, 0x5c, 0x34, 0xcc, 0x8b, 0x86, 0xae, 0x6a, 0x39, 0xea, 0xaa, 0xfe, 0x71, 0x09, 0xea, 0x81,
	0x3a, 0x8b, 0x7a, 0x66, 0x67, 0xd6, 0xa8, 0xd0, 0xc2, 0x53, 0x8d, 0x2a, 0x92, 0xc6, 0x24, 0xcc,
	0xeb, 0xb3, 0x78, 0x2e, 0x73, 0x3b, 0x49, 0x8d, 0xdb, 0x6d, 0x33, 0xdc, 0x58, 0x3a, 0x73, 0x1f,
	0x4a, 0x61, 0x47, 0x08, 0xcd, 0xb9, 0x9e, 0xc8, 0x83, 0xc2, 0x0c, 0x20, 0x68, 0x13, 0xa5, 0x25,
	0x41, 0xb9, 0xf4, 0x24, 0x48, 0x07, 0x82, 0x92, 0x75, 0xe9, 0x88, 0x5a, 0xaf, 0xe8, 0x15, 0xb2,
	0x1b, 0x4e, 0xaf, 0x23, 0x39, 0xf7, 0x44, 0xf1, 0x94, 0x65, 0xe9, 0x12, 0x29, 0x4b, 0xd2, 0x09,
	0x16, 0xae, 0xea, 0x04, 0x53, 0x72, 0x95, 0x62, 0x6a, 0xae, 0xa2, 0x41, 0x85, 0x11, 0x99, 0x13,
	0x03, 0xe5, 0x52, 0xe2, 0x72, 0x69, 0x9e, 0x23, 0x17, 0x9d, 0xa3, 0xa2, 0x64, 0xca, 0x6e, 0x38,
	0x78, 0xfb, 0x29, 0x4f, 0x73, 0x0a, 0xa5, 0x40, 0x0b, 0xa2, 0xb1, 0xb2, 0x0a, 0x25, 0x8c, 0x8f,
	0xbb, 0xbd, 0x87, 0xaa, 0xc2, 0x83, 0xdf, 0x7e, 0xaf, 0xc7, 0x06, 0x19, 0xa2, 0x42, 0x65, 0xaf,
	0xa5, 0x0f, 0x77, 0x5b, 0x5d, 0x43, 0x44, 0x4d, 0x19, 0x3f, 0x73, 0xec, 0xbf, 0x4e, 0xbf, 0xa7,
	0xa9, 0xf9, 0x58, 0x24, 0x5d, 0x8a, 0xc7, 0xbc, 0x42, 0xf3, 0x09, 0x94, 0x23, 0x97, 0x24, 0x05,
	0xc8, 0xf6, 0xb4, 0x67, 0xea, 0x35, 0x52, 0x87, 0xb2, 0x5c, 0x9a, 0x01, 0xf8, 0xc6, 0xda, 0xef,
	0xec, 0xed, 0xea, 0x3c, 0x4c, 0x97, 0x20, 0xcf, 0x43, 0x30, 0xc6, 0x69, 0xb9, 0x9e, 0x9a, 0x6b,
	0xfe, 0x48, 0x81, 0xe5, 0xc0, 0x56, 0x9f, 0xb2, 0x40, 0x67, 0x39, 0x76, 0xa2, 0x0c, 0x55, 0x92,
	0x65, 0x68, 0xb4, 0x80, 0xcd, 0xc4, 0x0b, 0x58, 0x56, 0x1b, 0x1f, 0x4f, 0xed, 0x17, 0xa2, 0x42,
	0x15, 0x9d, 0x6b, 0x0e, 0xc2, 0x0a, 0x75, 0x05, 0xf2, 0xb6, 0x63, 0x8f, 0xa8, 0x28, 0x6e, 0x71,
	0x40, 0xbe, 0x06, 0x55, 0xfa, 0x9a, 0x77, 0x05, 0x4c, 0xdb, 0x3b, 0xa3, 0x2e, 0x57, 0xec, 0x92,
	0x5e, 0x41, 0x60, 0x8b, 0xc3, 0x9a, 0xbf, 0x9f, 0x85, 0xf5, 0x3d, 0xd7, 0x71, 0x0e, 0xfb, 0x87,
	0x3a, 0x3d, 0x9d, 0x58, 0x23, 0xd3, 0xa7, 0xc1, 0xd9, 0xc9, 0x77, 0xa1, 0xf8, 0x52, 0x9c, 0x5f,
	0x98, 0x7e, 0x43, 0x1a, 0x60, 0xf2, 0x7e, 0xd1, 0x2a, 0x46, 0xd2, 0x90, 0xdf, 0x82, 0x5a, 0x22,
	0xb1, 0x5c, 0x24, 0xc2, 0x57, 0x63, 0xc9, 0x62, 0xdc, 0x0f, 0x67, 0x13, 0x7e, 0x38, 0x45, 0xf7,
	0x73, 0xa9, 0xba, 0xbf, 0x05, 0x65, 0xce, 0xe7, 0x18, 0x4f, 0x80, 0x81, 0x90, 0x23, 0xe4, 0x71,
	0xa4, 0x32, 0xc2, 0x33, 0x2f, 0x2d, 0xd2, 0xf9, 0x93, 0xf5, 0x93, 0xec, 0x92, 0x24, 0xaa, 0xac,
	0x42, 0x4a, 0x95, 0xd5, 0xfc, 0x3d, 0x58, 0x63, 0x46, 0x37, 0xc3, 0x53, 0x2f, 0x9e, 0x34, 0x28,
	0x89, 0xa4, 0xe1, 0xa1, 0x6c, 0x4c, 0x48, 0x7e, 0x7b, 0x8d, 0x0c, 0xf7, 0x37, 0x9b, 0x42, 0x48,
	0x3c, 0x18, 0xce, 0xae, 0xaa, 0xd7, 0x38, 0x59, 0x30, 0x6e, 0xfe, 0x4b, 0x06, 0x6e, 0x9c, 0x83,
	0x3b, 0xff, 0x04, 0x71, 0x9d, 0xce, 0x24, 0x75, 0xfa, 0x12, 0x8d, 0xcf, 0xf7, 0xa0, 0x26, 0x4f,
	0x6f, 0x44, 0x73, 0xb0, 0xaa, 0x84, 0x62, 0xd8, 0xff, 0x0c, 0x4a, 0xe1, 0x25, 0xf3, 0xfc, 0x92,
	0xe7, 0x6a, 0xa2, 0x1e, 0xa2, 0x32, 0xdf, 0x2a, 0x76, 0x5b, 0x5c, 0x94, 0xf2, 0x9c, 0x5c, 0x92,
	0xe9, 0x8e, 0xac, 0x70, 0x9e, 0x23, 0xfb, 0x4a, 0x81, 0xf5, 0x36, 0x8f, 0xbd, 0xb1, 0xbc, 0x53,
	0xa4, 0xbd, 0x17, 0xf1, 0x74, 0x5e, 0xa3, 0x6b, 0xe6, 0xc1, 0x2c, 0x9b, 0xf2, 0x60, 0xf6, 0xff,
	0xf4, 0x94, 0xf5, 0x1f, 0x19, 0x58, 0x3f, 0x37, 0xcb, 0xbf, 0x28, 0x1f, 0x9e, 0xb9, 0x48, 0x26,
	0xe5, 0x22, 0x1f, 0xb0, 0x3c, 0x0e, 0x2f, 0x72, 0x1a, 0xbc, 0x23, 0xa1, 0x03, 0xac, 0x8b, 0x89,
	0x3d, 0xf9, 0x88, 0xf4, 0x21, 0x90, 0x18, 0x2e, 0x7a, 0xcb, 0x9c, 0x4c, 0xfa, 0x02, 0x64, 0xf4,
	0x99, 0x49, 0x16, 0x5d, 0x2e, 0xea, 0x2b, 0xb3, 0x2c, 0x4a, 0xeb, 0x38, 0x2c, 0x2d, 0xb0, 0x58,
	0xb2, 0xe3, 0x10, 0x63, 0x79, 0x21, 0xc9, 0xf2, 0xbf, 0xcf, 0x41, 0x83, 0xb1, 0xfc, 0x91, 0xe3,
	0xf9, 0x91, 0x07, 0x2c, 0xe4, 0xf8, 0x9c, 0x06, 0xf4, 0x2f, 0x99, 0xdb, 0xcf, 0x61, 0x2d, 0xc9,
	0x24, 0xc3, 0xb3, 0x58, 0xc8, 0x5a, 0x84, 0xef, 0xd7, 0xe3, 0xac, 0x1a, 0xb0, 0x05, 0xc8, 0x40,
	0x74, 0x30, 0xa2, 0x4b, 0xfb, 0xce, 0x42, 0x22, 0x50, 0xe3, 0xeb, 0x0e, 0x1d, 0xd2, 0x92, 0x29,
	0x6b, 0x81, 0xa7, 0x46, 0xdf, 0x88, 0x94, 0xb4, 0x69, 0x9c, 0xdf, 0x1e, 0xd0, 0x09, 0x4d, 0x34,
	0xe3, 0x92, 0x0a, 0x56, 0xbc, 0xaa, 0x82, 0xc5, 0x14, 0xa2, 0x94, 0x54, 0x88, 0x6d, 0x28, 0x47,
	0x36, 0x67, 0xb9, 0x4b, 0xab, 0xdb, 0xc5, 0xf6, 0x42, 0xab, 0x3d, 0xdc, 0xfd, 0x6d, 0x4d, 0x55,
	0x22, 0x8d, 0x83, 0x4c, 0xf3, 0x17, 0x91, 0x9e, 0x84, 0xc7, 0xee, 0x43, 0xbe, 0x99, 0x2c, 0xe0,
	0xb7, 0x2e, 0xb8, 0x6d, 0x58, 0xbf, 0xef, 0x42, 0xf5, 0x88, 0xda, 0xd4, 0x35, 0xfd, 0xab, 0x3c,
	0x92, 0x49, 0x52, 0xe1, 0x60, 0x2f, 0x4c, 0xf6, 0xa3, 0x59, 0xfe, 0x55, 0x4a, 0xf6, 0xbf, 0xcd,
	0x40, 0x43, 0xa7, 0xe6, 0xf8, 0xcd, 0x8e, 0xe3, 0x06, 0x51, 0xe3, 0x92, 0xde, 0x6a, 0x6e, 0xf5,
	0x1e, 0x0f, 0x83, 0xd9, 0x94, 0x17, 0x86, 0xe8, 0xdb, 0x46, 0x6e, 0xe6, 0x6d, 0x23, 0x6a, 0xb7,
	0xf9, 0xb8, 0xdd, 0xbe, 0xb5, 0x00, 0x36, 0xd7, 0xad, 0xb0, 0xeb, 0x59, 0x9e, 0xc1, 0xd0, 0x2d,
	0x7c, 0x22, 0x2f, 0xea, 0x45, 0xcb, 0xd3, 0xf9, 0xb8, 0xf9, 0x9f, 0x0a, 0xe3, 0x1b, 0x67, 0xd3,
	0x6c, 0x5a, 0x7b, 0xff, 0xf2, 0x29, 0x62, 0x24, 0x31, 0x4c, 0x5e, 0x2b, 0xf3, 0x56, 0xae, 0x95,
	0x9d, 0x7b, 0xad, 0x5c, 0xfc, 0x5a, 0x71, 0x91, 0xe6, 0xe3, 0x22, 0x6d, 0xfe, 0x41, 0x06, 0xd6,
	0x65, 0x8b, 0x6b, 0xf6, 0xd2, 0x9f, 0xc0, 0x92, 0xc8, 0x1f, 0x2f, 0xba, 0xb2, 0xc0, 0x9b, 0x97,
	0xde, 0x73, 0x47, 0xe1, 0x39, 0x13, 0x59, 0x7f, 0x66, 0x17, 0x0b, 0xd6, 0x9c, 0x72, 0x96, 0x17,
	0xb9, 0xb9, 0xbc, 0xc8, 0xcf, 0xe3, 0xc5, 0x52, 0x92, 0x17, 0x0a, 0x90, 0x1d, 0xc7, 0x1d, 0x51,
	0x44, 0x7e, 0x1b, 0x16, 0xb3, 0x0e, 0x45, 0x73, 0xea, 0x1f, 0x47, 0x9f, 0xeb, 0xd8, 0xf8, 0xc2,
	0xa7, 0xf0, 0xe6, 0x9f, 0x28, 0xb0, 0xa4, 0x53, 0x6f, 0x3a, 0xf1, 0xc9, 0xfb, 0x90, 0x1b, 0x39,
	0x63, 0x7c, 0xc2, 0xac, 0x05, 0x2f, 0x2b, 0x81, 0xd0, 0x9c, 0x31, 0xd5, 0x39, 0x02, 0x69, 0x40,
	0xe1, 0x84, 0x7a, 0x9e, 0x79, 0x44, 0x25, 0xeb, 0xc5, 0x70, 0xf6, 0x91, 0x3f, 0x7b, 0xd5, 0x47,
	0xfe, 0xe6, 0x3f, 0xe5, 0xa0, 0x86, 0xfc, 0x09, 0x9e, 0x7f, 0xe6, 0xa6, 0x79, 0xf1, 0xd7, 0x73,
	0xc1, 0xa4, 0xec, 0x9d, 0x52, 0xe4, 0xf5, 0xfc, 0xe2, 0xce, 0xe0, 0x7d, 0x58, 0x1b, 0x3b, 0x67,
	0xf6, 0xc4, 0x31, 0xe5, 0xb3, 0xb6, 0x7c, 0xd5, 0xc2, 0x47, 0xe2, 0x15, 0x39, 0x8b, 0x0f, 0xd6,
	0xe2, 0xb9, 0xed, 0x13, 0x58, 0x41, 0x35, 0x48, 0xd0, 0x88, 0xcf, 0x09, 0x5c, 0x21, 0xe5, 0x08,
	0x05, 0x17, 0x35, 0xa7, 0x60, 0x02, 0x5b, 0x92, 0xa2, 0x66, 0x10, 0x26, 0xb2, 0x1e, 0xa8, 0x62,
	0x3a, 0x2c, 0x9a, 0x16, 0xe9, 0x62, 0xd4, 0x90, 0x3a, 0x28, 0x9b, 0xee, 0xc6, 0xd6, 0x8b, 0x76,
	0x32, 0xea, 0x21, 0x66, 0xf0, 0x69, 0x44, 0xc0, 0x81, 0xa8, 0x93, 0x2d, 0xf1, 0x33, 0x12, 0x39,
	0xd7, 0x0e, 0x9d, 0x2d, 0x4f, 0x5c, 0xf8, 0xe2, 0x51, 0x7c, 0xec, 0x5d, 0x88, 0x6d, 0x23, 0xd8,
	0xdd, 0x68, 0x5d, 0x89, 0x37, 0x2b, 0x2f, 0x52, 0xc2, 0x06, 0xd5, 0xe7, 0x79, 0x1d, 0x9a, 0x4a,
	0x5a, 0x95, 0xda, 0xfc, 0xb9, 0x02, 0x6b, 0x71, 0x6d, 0x0a, 0xfa, 0xed, 0xbf, 0x36, 0xf3, 0xa8,
	0xb8, 0x1a, 0xa8, 0x7e, 0x8c, 0x20, 0x7c, 0x4c, 0xec, 0x06, 0x5f, 0xd4, 0x60, 0x07, 0xee, 0x7e,
	0x3a, 0x81, 0xd8, 0x61, 0x3b, 0x09, 0x48, 0x7c, 0x74, 0xb3, 0x03, 0x6b, 0xe9, 0x18, 0xa4, 0x0e,
	0xe5, 0x07, 0xfd, 0xe1, 0x23, 0x43, 0xbc, 0x6b, 0xf0, 0xbe, 0xcd, 0xb3, 0xd6, 0xee, 0xd0, 0xe8,
	0xee, 0x0e, 0x86, 0xf8, 0xcc, 0xa1, 0x6b, 0x8f, 0xb5, 0xf6, 0x90, 0x67, 0x22, 0xff, 0xca, 0xef,
	0x88, 0x19, 0x45, 0xec, 0x20, 0x17, 0x14, 0x9d, 0x5b, 0x50, 0x16, 0x02, 0xb4, 0x99, 0xf9, 0xa3,
	0x49, 0x0b, 0xfd, 0xec, 0x31, 0x7b, 0x4f, 0x53, 0xc7, 0xec, 0x5b, 0x56, 0xc7, 0x5c, 0xaa, 0x3a,
	0x36, 0xff, 0x26, 0x0b, 0x37, 0x24, 0x53, 0xde, 0xee, 0xa5, 0xbe, 0x27, 0x33, 0xd2, 0x2c, 0x17,
	0xe1, 0xdd, 0x84, 0xbb, 0x4b, 0x6c, 0x26, 0x44, 0xcb, 0xe4, 0x22, 0xf3, 0xd1, 0xed, 0x40, 0x09,
	0xb0, 0x1a, 0x5c, 0x4b, 0x6f, 0xf7, 0x49, 0x31, 0xc7, 0xdb, 0x2d, 0xf9, 0x44, 0xbb, 0xa5, 0x85,
	0x4e, 0x7a, 0xf1, 0x9c, 0xa4, 0xe8, 0xcd, 0xb1, 0x85, 0x42, 0xaa, 0x2d, 0x18, 0x00, 0xe1, 0x6d,
	0x08, 0x81, 0x5a, 0xbb, 0xdf, 0x1b, 0xea, 0xad, 0xf6, 0xd0, 0xe0, 0x8f, 0x59, 0xea, 0x35, 0xb2,
	0x0a, 0xcb, 0x9d, 0xfe, 0xb3, 0x5e, 0xb7, 0xdf, 0xea, 0x18, 0xbd, 0xfe, 0xd0, 0xe0, 0x3d, 0x3f,
	0x85, 0x2c, 0x43, 0x55, 0x3e, 0x65, 0xb5, 0x1e, 0xb6, 0x76, 0x7b, 0x6a, 0x86, 0x5c, 0x87, 0x7a,
	0x40, 0x2d, 0x52, 0xe2, 0x6c, 0xf3, 0xcf, 0xb3, 0xb0, 0xda, 0x36, 0xed, 0x11, 0x9d, 0x84, 0x7a,
	0x7d, 0xb9, 0x42, 0x7d, 0x5e, 0xf3, 0x23, 0x91, 0xf5, 0x65, 0x2f, 0xf8, 0xa2, 0x25, 0x37, 0xef,
	0x8b, 0x96, 0x44, 0x52, 0xd8, 0x82, 0x25, 0x97, 0x9a, 0x9e, 0x63, 0x73, 0xd6, 0x87, 0xca, 0x90,
	0x7a, 0x09, 0x01, 0xd5, 0x39, 0x81, 0x2e, 0x08, 0xe3, 0x02, 0x2c, 0x5c, 0x49, 0x80, 0xb1, 0x40,
	0x5d, 0x4c, 0x06, 0x6a, 0x1d, 0x2a, 0xd1, 0x8d, 0x89, 0x0a, 0x95, 0x47, 0xfd, 0x01, 0x93, 0x19,
	0x97, 0x88, 0x7a, 0x8d, 0x89, 0x27, 0x90, 0xda, 0x4e, 0x6b, 0xb7, 0xab, 0x2a, 0x4c, 0xb8, 0xba,
	0xd6, 0x1b, 0x6a, 0x7a, 0x80, 0xc6, 0xdb, 0xac, 0xfd, 0xe1, 0x23, 0x4d, 0x57, 0xb3, 0xcd, 0x3f,
	0x55, 0xe0, 0x7a, 0x90, 0x62, 0x3d, 0x76, 0x0e, 0x22, 0x75, 0x2f, 0xb3, 0x9a, 0x68, 0xdd, 0xcb,
	0xc6, 0x69, 0x9d, 0x90, 0xcc, 0x5b, 0xe9, 0x84, 0x24, 0x13, 0xcd, 0xe6, 0x7f, 0x65, 0x60, 0x25,
	0x7e, 0x32, 0xe1, 0xad, 0xe7, 0x1c, 0xed, 0x16, 0x80, 0xe5, 0x79, 0xd3, 0x78, 0xa3, 0x07, 0x21,
	0x6c, 0x7a, 0x15, 0x96, 0x3e, 0x77, 0x0e, 0x42, 0xd5, 0xc9, 0x7f, 0xee, 0x1c, 0xec, 0xf2, 0x66,
	0xf0, 0xa9, 0x39, 0x7a, 0xc1, 0x4a, 0xee, 0xa9, 0x3b, 0x91, 0xc5, 0x84, 0x00, 0xed, 0xbb, 0x13,
	0xf2, 0x19, 0xdc, 0x90, 0x08, 0x41, 0x1f, 0x2c, 0xf6, 0xb1, 0xe5, 0xaa, 0x98, 0x0e, 0x7a, 0x7c,
	0xd8, 0x62, 0x63, 0x1a, 0x41, 0xed, 0xf1, 0x55, 0x4c, 0x9a, 0xda, 0x63, 0xf9, 0x31, 0x01, 0x3b,
	0xf2, 0xa1, 0x65, 0x5b, 0xde, 0xb1, 0x31, 0xa6, 0xe6, 0x78, 0x62, 0xd9, 0x8b, 0xa9, 0xd7, 0xf2,
	0xe7, 0xce, 0xc1, 0x0e, 0xa7, 0xef, 0x08, 0xf2, 0x0b, 0xf4, 0xec, 0x67, 0x0a, 0x90, 0x04, 0xe7,
	0x59, 0x72, 0x38, 0x87, 0xef, 0x21, 0x63, 0x33, 0x51, 0xc6, 0x7e, 0xca, 0x8c, 0x8a, 0xd1, 0x8a,
	0xea, 0xf3, 0x66, 0x6a, 0x13, 0x15, 0x97, 0xd7, 0x05, 0x2a, 0xd1, 0xa0, 0xec, 0x4d, 0x0f, 0x4e,
	0xac, 0x2b, 0xf4, 0xd9, 0x00, 0x09, 0x2f, 0xd1, 0x66, 0xfb, 0x3b, 0x05, 0x56, 0xd2, 0x4e, 0x71,
	0x99, 0x0f, 0x0e, 0xaf, 0x52, 0xaf, 0xa6, 0x3f, 0x27, 0xac, 0x05, 0xfc, 0x41, 0x6f, 0x24, 0x59,
	0xc0, 0xd5, 0x98, 0x5f, 0xdf, 0x99, 0xfa, 0x5c, 0x71, 0x8a, 0x4c, 0x8d, 0x87, 0x08, 0x68, 0xfe,
	0xb5, 0x02, 0xa4, 0x43, 0xdb, 0x94, 0xf9, 0xa4, 0x49, 0xd8, 0x56, 0x7e, 0x17, 0x32, 0x2f, 0xbd,
	0x86, 0x12, 0xfb, 0xc0, 0xb7, 0x13, 0x96, 0x4d, 0x99, 0x97, 0x91, 0x12, 0x3f, 0x13, 0x2d, 0xf1,
	0x09, 0xe4, 0xa6, 0xd3, 0xc0, 0x28, 0xf8, 0xff, 0x44, 0x85, 0x6c, 0x68, 0x0b, 0xec, 0x5f, 0xf2,
	0x2d, 0x28, 0x06, 0xba, 0x7c, 0x71, 0x87, 0x29, 0x87, 0x2f, 0xdd, 0x42, 0x8d, 0x9b, 0x3f, 0x54,
	0x00, 0x3a, 0xbf, 0xc4, 0x87, 0x9b, 0x79, 0x85, 0xe9, 0x07, 0x23, 0xa8, 0x44, 0x4b, 0x1c, 0x52,
	0x86, 0xc2, 0x60, 0xbf, 0xdd, 0xd6, 0x06, 0x03, 0xf5, 0x1a, 0xd9, 0x80, 0x35, 0x96, 0x7b, 0xb5,
	0x86, 0xfb, 0xba, 0x66, 0xec, 0xf4, 0xf5, 0x27, 0xad, 0xa1, 0xa1, 0xe9, 0x7a, 0x5f, 0x57, 0x15,
	0xb2, 0x0e, 0xab, 0xed, 0xfe, 0x93, 0xbd, 0xfd, 0xa1, 0x66, 0xb4, 0x3a, 0x1d, 0x5d, 0x1b, 0x0c,
	0xc4, 0x54, 0x86, 0xe5, 0x6d, 0xdc, 0xc5, 0x0a, 0xc0, 0xca, 0xbd, 0xbf, 0x02, 0xa8, 0x3c, 0xe4,
	0x51, 0x98, 0xba, 0xaf, 0xac, 0x11, 0x25, 0xdf, 0x86, 0xeb, 0x03, 0xae, 0xae, 0xf1, 0x4f, 0x1e,
	0xce, 0xc9, 0x21, 0x36, 0xaa, 0x61, 0x76, 0xc2, 0x54, 0xe4, 0x3b, 0x50, 0x1d, 0x50, 0x3b, 0x7c,
	0x70, 0x20, 0xb7, 0x22, 0x74, 0xb3, 0x6f, 0x0e, 0x49, 0xf2, 0x1e, 0xb3, 0xf0, 0x64, 0x2f, 0x9d,
	0xdc, 0x0e, 0x6a, 0xee, 0x73, 0xda, 0xec, 0x1b, 0xe7, 0x9c, 0x8e, 0xb4, 0x61, 0x79, 0xa6, 0x0d,
	0x44, 0xb6, 0x82, 0x3d, 0xd3, 0x1b, 0x44, 0xc9, 0x43, 0xfd, 0x3a, 0x94, 0x23, 0x35, 0x31, 0x59,
	0x97, 0x7b, 0xcd, 0xd4, 0xc9, 0x49, 0xc2, 0xc7, 0xb0, 0x3c, 0xd3, 0x58, 0x23, 0x17, 0xb5, 0xdc,
	0x36, 0x56, 0x12, 0xbd, 0x30, 0x6c, 0xdd, 0xe9, 0xa0, 0xea, 0xd4, 0x77, 0x2d, 0xfa, 0x8a, 0xca,
	0xee, 0x3b, 0xb9, 0xf0, 0xf3, 0x9b, 0x8d, 0x77, 0x92, 0x7c, 0x89, 0x7d, 0xcf, 0x33, 0x64, 0x6b,
	0xc6, 0x9b, 0x3d, 0x17, 0x33, 0x27, 0x44, 0x38, 0xa7, 0x4d, 0xd4, 0x61, 0x3c, 0x4f, 0xb4, 0x53,
	0x82, 0xa3, 0x9e, 0xdb, 0x68, 0x49, 0xf2, 0xae, 0x0b, 0x2b, 0xa8, 0x86, 0x89, 0x4a, 0x3b, 0xbd,
	0x02, 0xda, 0xb8, 0x35, 0xb7, 0xce, 0x21, 0xdf, 0x87, 0x75, 0x71, 0xde, 0x1d, 0xc7, 0x4d, 0x66,
	0xeb, 0xb7, 0xe2, 0x37, 0x4a, 0x4c, 0x6f, 0x6c, 0xce, 0xcf, 0xbf, 0x49, 0x1b, 0x56, 0x74, 0x7a,
	0xea, 0xb8, 0xfe, 0x8e, 0x69, 0x4d, 0x86, 0x4e, 0x47, 0xd4, 0xa1, 0xe4, 0x9d, 0x79, 0xa9, 0x5a,
	0xf2, 0xba, 0x4f, 0x83, 0x02, 0x29, 0xca, 0xf3, 0xc7, 0xce, 0x01, 0xd9, 0x48, 0x36, 0x9c, 0xc2,
	0x6c, 0x68, 0xe3, 0x66, 0xea, 0x9c, 0xb8, 0x73, 0x07, 0x1a, 0xc8, 0xc1, 0xb4, 0x98, 0x99, 0x4e,
	0x38, 0x9d, 0xcc, 0x1c, 0xec, 0xbb, 0xb0, 0xc2, 0x7f, 0xc3, 0xf5, 0x90, 0xfa, 0xb1, 0x9f, 0x32,
	0x49, 0x4f, 0x1e, 0xfe, 0xc0, 0x6b, 0x43, 0xf6, 0x65, 0x62, 0x78, 0x0f, 0x60, 0x3d, 0x46, 0xcf,
	0x54, 0xde, 0xd3, 0x4d, 0xfb, 0x45, 0x8f, 0x9e, 0xa5, 0x2d, 0x42, 0xa2, 0x3f, 0x01, 0x11, 0x6b,
	0x74, 0xe0, 0x66, 0xfa, 0x1a, 0xfc, 0x07, 0x21, 0x97, 0x5d, 0x65, 0x07, 0x6e, 0xc4, 0x56, 0x09,
	0x7f, 0x4d, 0x92, 0xb6, 0x82, 0xec, 0xf3, 0xcd, 0xfc, 0xe6, 0xe4, 0xc1, 0x6f, 0xfe, 0xe2, 0xe7,
	0x9b, 0xca, 0x17, 0x5f, 0x6e, 0x2a, 0x3f, 0xfe, 0x72, 0x53, 0xf9, 0xd9, 0x97, 0x9b, 0xca, 0x9f,
	0x7d, 0xb5, 0xa9, 0xfc, 0xc3, 0x57, 0x9b, 0xca, 0x17, 0x5f, 0x6d, 0x2a, 0x50, 0xb5, 0x9c, 0xed,
	0x03, 0xff, 0xd0, 0x43, 0xf2, 0x07, 0xc0, 0x7d, 0xeb, 0x1e, 0x0b, 0x44, 0x7b, 0xca, 0xf7, 0xf1,
	0xb7, 0x76, 0x07, 0x4b, 0x3c, 0x30, 0x7d, 0xfa, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x71, 0x7a,
	0xdf, 0x8e, 0x95, 0x37, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GuardServiceClient is the client API for GuardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GuardServiceClient interface {
	SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error)
	SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error)
	CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error)
	ReadyForChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*Result, error)
	ForceRepair(ctx context.Context, in *ForceRepairRequest, opts ...grpc.CallOption) (*Result, error)
	ListHostContracts(ctx context.Context, in *ListHostContractsRequest, opts ...grpc.CallOption) (*ContractsList, error)
	RetrieveFileInfo(ctx context.Context, in *ListRenterFileInfoRequest, opts ...grpc.CallOption) (*FileStoreListResponse, error)
	RequestChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*RequestChallengeQuestion, error)
	ResponseChallenge(ctx context.Context, in *ResponseChallengeQuestion, opts ...grpc.CallOption) (*Result, error)
	SubmitRepairContract(ctx context.Context, in *RepairContract, opts ...grpc.CallOption) (*RepairContractResponse, error)
	RequestForRepairContracts(ctx context.Context, in *RequestRepairContracts, opts ...grpc.CallOption) (*ResponseRepairContracts, error)
	ReportFailToDownload(ctx context.Context, in *CancelContractRequest, opts ...grpc.CallOption) (*Result, error)
	// used for decentral challenge
	RequestForChallengeJob(ctx context.Context, in *ChallengeJobRequest, opts ...grpc.CallOption) (*ChallengeJobResponse, error)
	SubmitChallengeJobResult(ctx context.Context, in *ChallengeJobResult, opts ...grpc.CallOption) (*Result, error)
	// used by btfs scan
	AdminGetDailySummary(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*DailySummary, error)
	AdminGetDailyHostsRankNew(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*HostSummary, error)
	AdminGetDailyHostsRankTotal(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*HostSummary, error)
	AdminGetDailyTotalState(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*TotalStateSummary, error)
}

type guardServiceClient struct {
	cc *grpc.ClientConn
}

func NewGuardServiceClient(cc *grpc.ClientConn) GuardServiceClient {
	return &guardServiceClient{cc}
}

func (c *guardServiceClient) SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SubmitFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SendQuestions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error) {
	out := new(FileStoreStatus)
	err := c.cc.Invoke(ctx, "/guard.GuardService/CheckFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ReadyForChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ReadyForChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ForceRepair(ctx context.Context, in *ForceRepairRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ForceRepair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ListHostContracts(ctx context.Context, in *ListHostContractsRequest, opts ...grpc.CallOption) (*ContractsList, error) {
	out := new(ContractsList)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ListHostContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) RetrieveFileInfo(ctx context.Context, in *ListRenterFileInfoRequest, opts ...grpc.CallOption) (*FileStoreListResponse, error) {
	out := new(FileStoreListResponse)
	err := c.cc.Invoke(ctx, "/guard.GuardService/RetrieveFileInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) RequestChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*RequestChallengeQuestion, error) {
	out := new(RequestChallengeQuestion)
	err := c.cc.Invoke(ctx, "/guard.GuardService/RequestChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ResponseChallenge(ctx context.Context, in *ResponseChallengeQuestion, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ResponseChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) SubmitRepairContract(ctx context.Context, in *RepairContract, opts ...grpc.CallOption) (*RepairContractResponse, error) {
	out := new(RepairContractResponse)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SubmitRepairContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) RequestForRepairContracts(ctx context.Context, in *RequestRepairContracts, opts ...grpc.CallOption) (*ResponseRepairContracts, error) {
	out := new(ResponseRepairContracts)
	err := c.cc.Invoke(ctx, "/guard.GuardService/RequestForRepairContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ReportFailToDownload(ctx context.Context, in *CancelContractRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ReportFailToDownload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) RequestForChallengeJob(ctx context.Context, in *ChallengeJobRequest, opts ...grpc.CallOption) (*ChallengeJobResponse, error) {
	out := new(ChallengeJobResponse)
	err := c.cc.Invoke(ctx, "/guard.GuardService/RequestForChallengeJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) SubmitChallengeJobResult(ctx context.Context, in *ChallengeJobResult, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SubmitChallengeJobResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) AdminGetDailySummary(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*DailySummary, error) {
	out := new(DailySummary)
	err := c.cc.Invoke(ctx, "/guard.GuardService/AdminGetDailySummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) AdminGetDailyHostsRankNew(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*HostSummary, error) {
	out := new(HostSummary)
	err := c.cc.Invoke(ctx, "/guard.GuardService/AdminGetDailyHostsRankNew", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) AdminGetDailyHostsRankTotal(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*HostSummary, error) {
	out := new(HostSummary)
	err := c.cc.Invoke(ctx, "/guard.GuardService/AdminGetDailyHostsRankTotal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) AdminGetDailyTotalState(ctx context.Context, in *AdminQuery, opts ...grpc.CallOption) (*TotalStateSummary, error) {
	out := new(TotalStateSummary)
	err := c.cc.Invoke(ctx, "/guard.GuardService/AdminGetDailyTotalState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuardServiceServer is the server API for GuardService service.
type GuardServiceServer interface {
	SubmitFileStoreMeta(context.Context, *FileStoreStatus) (*Result, error)
	SendQuestions(context.Context, *FileChallengeQuestions) (*Result, error)
	CheckFileStoreMeta(context.Context, *CheckFileStoreMetaRequest) (*FileStoreStatus, error)
	ReadyForChallenge(context.Context, *ReadyForChallengeRequest) (*Result, error)
	ForceRepair(context.Context, *ForceRepairRequest) (*Result, error)
	ListHostContracts(context.Context, *ListHostContractsRequest) (*ContractsList, error)
	RetrieveFileInfo(context.Context, *ListRenterFileInfoRequest) (*FileStoreListResponse, error)
	RequestChallenge(context.Context, *ReadyForChallengeRequest) (*RequestChallengeQuestion, error)
	ResponseChallenge(context.Context, *ResponseChallengeQuestion) (*Result, error)
	SubmitRepairContract(context.Context, *RepairContract) (*RepairContractResponse, error)
	RequestForRepairContracts(context.Context, *RequestRepairContracts) (*ResponseRepairContracts, error)
	ReportFailToDownload(context.Context, *CancelContractRequest) (*Result, error)
	// used for decentral challenge
	RequestForChallengeJob(context.Context, *ChallengeJobRequest) (*ChallengeJobResponse, error)
	SubmitChallengeJobResult(context.Context, *ChallengeJobResult) (*Result, error)
	// used by btfs scan
	AdminGetDailySummary(context.Context, *AdminQuery) (*DailySummary, error)
	AdminGetDailyHostsRankNew(context.Context, *AdminQuery) (*HostSummary, error)
	AdminGetDailyHostsRankTotal(context.Context, *AdminQuery) (*HostSummary, error)
	AdminGetDailyTotalState(context.Context, *AdminQuery) (*TotalStateSummary, error)
}

// UnimplementedGuardServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGuardServiceServer struct {
}

func (*UnimplementedGuardServiceServer) SubmitFileStoreMeta(ctx context.Context, req *FileStoreStatus) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitFileStoreMeta not implemented")
}
func (*UnimplementedGuardServiceServer) SendQuestions(ctx context.Context, req *FileChallengeQuestions) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendQuestions not implemented")
}
func (*UnimplementedGuardServiceServer) CheckFileStoreMeta(ctx context.Context, req *CheckFileStoreMetaRequest) (*FileStoreStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckFileStoreMeta not implemented")
}
func (*UnimplementedGuardServiceServer) ReadyForChallenge(ctx context.Context, req *ReadyForChallengeRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadyForChallenge not implemented")
}
func (*UnimplementedGuardServiceServer) ForceRepair(ctx context.Context, req *ForceRepairRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceRepair not implemented")
}
func (*UnimplementedGuardServiceServer) ListHostContracts(ctx context.Context, req *ListHostContractsRequest) (*ContractsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHostContracts not implemented")
}
func (*UnimplementedGuardServiceServer) RetrieveFileInfo(ctx context.Context, req *ListRenterFileInfoRequest) (*FileStoreListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveFileInfo not implemented")
}
func (*UnimplementedGuardServiceServer) RequestChallenge(ctx context.Context, req *ReadyForChallengeRequest) (*RequestChallengeQuestion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestChallenge not implemented")
}
func (*UnimplementedGuardServiceServer) ResponseChallenge(ctx context.Context, req *ResponseChallengeQuestion) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResponseChallenge not implemented")
}
func (*UnimplementedGuardServiceServer) SubmitRepairContract(ctx context.Context, req *RepairContract) (*RepairContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitRepairContract not implemented")
}
func (*UnimplementedGuardServiceServer) RequestForRepairContracts(ctx context.Context, req *RequestRepairContracts) (*ResponseRepairContracts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestForRepairContracts not implemented")
}
func (*UnimplementedGuardServiceServer) ReportFailToDownload(ctx context.Context, req *CancelContractRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportFailToDownload not implemented")
}
func (*UnimplementedGuardServiceServer) RequestForChallengeJob(ctx context.Context, req *ChallengeJobRequest) (*ChallengeJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestForChallengeJob not implemented")
}
func (*UnimplementedGuardServiceServer) SubmitChallengeJobResult(ctx context.Context, req *ChallengeJobResult) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitChallengeJobResult not implemented")
}
func (*UnimplementedGuardServiceServer) AdminGetDailySummary(ctx context.Context, req *AdminQuery) (*DailySummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminGetDailySummary not implemented")
}
func (*UnimplementedGuardServiceServer) AdminGetDailyHostsRankNew(ctx context.Context, req *AdminQuery) (*HostSummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminGetDailyHostsRankNew not implemented")
}
func (*UnimplementedGuardServiceServer) AdminGetDailyHostsRankTotal(ctx context.Context, req *AdminQuery) (*HostSummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminGetDailyHostsRankTotal not implemented")
}
func (*UnimplementedGuardServiceServer) AdminGetDailyTotalState(ctx context.Context, req *AdminQuery) (*TotalStateSummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminGetDailyTotalState not implemented")
}

func RegisterGuardServiceServer(s *grpc.Server, srv GuardServiceServer) {
	s.RegisterService(&_GuardService_serviceDesc, srv)
}

func _GuardService_SubmitFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileStoreStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SubmitFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, req.(*FileStoreStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_SendQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileChallengeQuestions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SendQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SendQuestions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SendQuestions(ctx, req.(*FileChallengeQuestions))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_CheckFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFileStoreMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/CheckFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, req.(*CheckFileStoreMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ReadyForChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadyForChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ReadyForChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ReadyForChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ReadyForChallenge(ctx, req.(*ReadyForChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ForceRepair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceRepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ForceRepair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ForceRepair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ForceRepair(ctx, req.(*ForceRepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ListHostContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ListHostContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ListHostContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ListHostContracts(ctx, req.(*ListHostContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_RetrieveFileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRenterFileInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).RetrieveFileInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/RetrieveFileInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).RetrieveFileInfo(ctx, req.(*ListRenterFileInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_RequestChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadyForChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).RequestChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/RequestChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).RequestChallenge(ctx, req.(*ReadyForChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ResponseChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResponseChallengeQuestion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ResponseChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ResponseChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ResponseChallenge(ctx, req.(*ResponseChallengeQuestion))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_SubmitRepairContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SubmitRepairContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SubmitRepairContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SubmitRepairContract(ctx, req.(*RepairContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_RequestForRepairContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRepairContracts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).RequestForRepairContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/RequestForRepairContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).RequestForRepairContracts(ctx, req.(*RequestRepairContracts))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ReportFailToDownload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ReportFailToDownload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ReportFailToDownload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ReportFailToDownload(ctx, req.(*CancelContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_RequestForChallengeJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChallengeJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).RequestForChallengeJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/RequestForChallengeJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).RequestForChallengeJob(ctx, req.(*ChallengeJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_SubmitChallengeJobResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChallengeJobResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SubmitChallengeJobResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SubmitChallengeJobResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SubmitChallengeJobResult(ctx, req.(*ChallengeJobResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_AdminGetDailySummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).AdminGetDailySummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/AdminGetDailySummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).AdminGetDailySummary(ctx, req.(*AdminQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_AdminGetDailyHostsRankNew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).AdminGetDailyHostsRankNew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/AdminGetDailyHostsRankNew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).AdminGetDailyHostsRankNew(ctx, req.(*AdminQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_AdminGetDailyHostsRankTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).AdminGetDailyHostsRankTotal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/AdminGetDailyHostsRankTotal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).AdminGetDailyHostsRankTotal(ctx, req.(*AdminQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_AdminGetDailyTotalState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).AdminGetDailyTotalState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/AdminGetDailyTotalState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).AdminGetDailyTotalState(ctx, req.(*AdminQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _GuardService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "guard.GuardService",
	HandlerType: (*GuardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitFileStoreMeta",
			Handler:    _GuardService_SubmitFileStoreMeta_Handler,
		},
		{
			MethodName: "SendQuestions",
			Handler:    _GuardService_SendQuestions_Handler,
		},
		{
			MethodName: "CheckFileStoreMeta",
			Handler:    _GuardService_CheckFileStoreMeta_Handler,
		},
		{
			MethodName: "ReadyForChallenge",
			Handler:    _GuardService_ReadyForChallenge_Handler,
		},
		{
			MethodName: "ForceRepair",
			Handler:    _GuardService_ForceRepair_Handler,
		},
		{
			MethodName: "ListHostContracts",
			Handler:    _GuardService_ListHostContracts_Handler,
		},
		{
			MethodName: "RetrieveFileInfo",
			Handler:    _GuardService_RetrieveFileInfo_Handler,
		},
		{
			MethodName: "RequestChallenge",
			Handler:    _GuardService_RequestChallenge_Handler,
		},
		{
			MethodName: "ResponseChallenge",
			Handler:    _GuardService_ResponseChallenge_Handler,
		},
		{
			MethodName: "SubmitRepairContract",
			Handler:    _GuardService_SubmitRepairContract_Handler,
		},
		{
			MethodName: "RequestForRepairContracts",
			Handler:    _GuardService_RequestForRepairContracts_Handler,
		},
		{
			MethodName: "ReportFailToDownload",
			Handler:    _GuardService_ReportFailToDownload_Handler,
		},
		{
			MethodName: "RequestForChallengeJob",
			Handler:    _GuardService_RequestForChallengeJob_Handler,
		},
		{
			MethodName: "SubmitChallengeJobResult",
			Handler:    _GuardService_SubmitChallengeJobResult_Handler,
		},
		{
			MethodName: "AdminGetDailySummary",
			Handler:    _GuardService_AdminGetDailySummary_Handler,
		},
		{
			MethodName: "AdminGetDailyHostsRankNew",
			Handler:    _GuardService_AdminGetDailyHostsRankNew_Handler,
		},
		{
			MethodName: "AdminGetDailyHostsRankTotal",
			Handler:    _GuardService_AdminGetDailyHostsRankTotal_Handler,
		},
		{
			MethodName: "AdminGetDailyTotalState",
			Handler:    _GuardService_AdminGetDailyTotalState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/guard/guard.proto",
}

func (m *AdminQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	n1, err1 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintGuard(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x22
	if m.QueryCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.QueryCount))
		i--
		dAtA[i] = 0x18
	}
	n2, err2 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.QueryDate, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintGuard(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DailySummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailySummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DailySummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewShardsSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NewShardsSize))
		i--
		dAtA[i] = 0x58
	}
	if m.NewFiles != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NewFiles))
		i--
		dAtA[i] = 0x50
	}
	if m.NewContractsAveragePrice != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NewContractsAveragePrice))
		i--
		dAtA[i] = 0x48
	}
	if m.NewContractsRenter != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NewContractsRenter))
		i--
		dAtA[i] = 0x40
	}
	if m.NewContractsHost != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NewContractsHost))
		i--
		dAtA[i] = 0x38
	}
	if m.NewContracts != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NewContracts))
		i--
		dAtA[i] = 0x30
	}
	if m.WorkingStorageSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.WorkingStorageSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x1a
	}
	n3, err3 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.ResponseTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintGuard(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x12
	n4, err4 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.QueryDate, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintGuard(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HostSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		for iNdEx := len(m.Status) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Status[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RecordCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RecordCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x1a
	}
	n5, err5 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.ResponseTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintGuard(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x12
	n6, err6 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.QueryDate, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintGuard(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TotalStateSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalStateSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalStateSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalUsdtReward != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.TotalUsdtReward))
		i--
		dAtA[i] = 0x68
	}
	if m.TotalUsddReward != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.TotalUsddReward))
		i--
		dAtA[i] = 0x60
	}
	if m.TotalTrxReward != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.TotalTrxReward))
		i--
		dAtA[i] = 0x58
	}
	if m.TotalWbttReward != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.TotalWbttReward))
		i--
		dAtA[i] = 0x50
	}
	if m.TotalHostReward != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.TotalHostReward))
		i--
		dAtA[i] = 0x48
	}
	if m.LostShardSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.LostShardSize))
		i--
		dAtA[i] = 0x40
	}
	if m.InvalidContractCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.InvalidContractCount))
		i--
		dAtA[i] = 0x38
	}
	if m.ExistedShardSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ExistedShardSize))
		i--
		dAtA[i] = 0x30
	}
	if m.ValidContractCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ValidContractCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x1a
	}
	n7, err7 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.ResponseTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintGuard(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x12
	n8, err8 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.QueryDate, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintGuard(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HostStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SuspectCheat {
		i--
		if m.SuspectCheat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RewardBtt != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RewardBtt))
		i--
		dAtA[i] = 0x20
	}
	if m.WorkAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.WorkAmount))
		i--
		dAtA[i] = 0x18
	}
	if m.FileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Change) > 0 {
		i -= len(m.Change)
		copy(dAtA[i:], m.Change)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Change)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OriginatorPid) > 0 {
		i -= len(m.OriginatorPid)
		copy(dAtA[i:], m.OriginatorPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.OriginatorPid)))
		i--
		dAtA[i] = 0x12
	}
	n9, err9 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.ChangeTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ChangeTime):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintGuard(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ContractMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ContingentAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ContingentAmount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.NumPayouts != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NumPayouts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PayoutSchedule != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.PayoutSchedule))
		i--
		dAtA[i] = 0x78
	}
	if m.CollateralAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CollateralAmount))
		i--
		dAtA[i] = 0x70
	}
	if m.Amount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x68
	}
	if m.Price != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x60
	}
	if len(m.EscrowPid) > 0 {
		i -= len(m.EscrowPid)
		copy(dAtA[i:], m.EscrowPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowPid)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x52
	}
	n10, err10 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RentEnd, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentEnd):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintGuard(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x4a
	n11, err11 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RentStart, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentStart):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintGuard(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x42
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardFileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardFileSize))
		i--
		dAtA[i] = 0x30
	}
	if m.ShardIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	n12, err12 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.FirstChallengeSuccess, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.FirstChallengeSuccess):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintGuard(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.ChallengeSuccessTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeSuccessTimes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ChallengeWarnTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeWarnTimes))
		i--
		dAtA[i] = 0x78
	}
	if m.ChallengeTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeTimes))
		i--
		dAtA[i] = 0x70
	}
	n13, err13 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.LastChallengeTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.LastChallengeTime):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintGuard(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x6a
	n14, err14 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.LastSuccessChallengeTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.LastSuccessChallengeTime):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintGuard(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x62
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x4a
	}
	n15, err15 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.LastModifyTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.LastModifyTime):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintGuard(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x42
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.EscrowSignature) > 0 {
		i -= len(m.EscrowSignature)
		copy(dAtA[i:], m.EscrowSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowSignature)))
		i--
		dAtA[i] = 0x32
	}
	n16, err16 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.EscrowSignedTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.EscrowSignedTime):])
	if err16 != nil {
		return 0, err16
	}
	i -= n16
	i = encodeVarintGuard(dAtA, i, uint64(n16))
	i--
	dAtA[i] = 0x2a
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ContractMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FileStoreListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Count != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FileStoreMeta) > 0 {
		for iNdEx := len(m.FileStoreMeta) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileStoreMeta[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n18, err18 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.CurrentTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.CurrentTime):])
	if err18 != nil {
		return 0, err18
	}
	i -= n18
	i = encodeVarintGuard(dAtA, i, uint64(n18))
	i--
	dAtA[i] = 0x12
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStoreMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.CheckFrequencyWarn != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CheckFrequencyWarn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SuccessChallengeTimesLimit != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.SuccessChallengeTimesLimit))
		i--
		dAtA[i] = 0x78
	}
	if m.WarnChallengeTimesLimit != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.WarnChallengeTimesLimit))
		i--
		dAtA[i] = 0x70
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EscrowPid) > 0 {
		i -= len(m.EscrowPid)
		copy(dAtA[i:], m.EscrowPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowPid)))
		i--
		dAtA[i] = 0x62
	}
	if m.RecoverThreshold != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RecoverThreshold))
		i--
		dAtA[i] = 0x58
	}
	if m.MinimumShards != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.MinimumShards))
		i--
		dAtA[i] = 0x50
	}
	if m.ShardCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardCount))
		i--
		dAtA[i] = 0x48
	}
	if m.EscrowFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.EscrowFee))
		i--
		dAtA[i] = 0x40
	}
	if m.GuardFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.GuardFee))
		i--
		dAtA[i] = 0x38
	}
	if m.CheckFrequency != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CheckFrequency))
		i--
		dAtA[i] = 0x30
	}
	n20, err20 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RentEnd, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentEnd):])
	if err20 != nil {
		return 0, err20
	}
	i -= n20
	i = encodeVarintGuard(dAtA, i, uint64(n20))
	i--
	dAtA[i] = 0x2a
	n21, err21 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RentStart, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentStart):])
	if err21 != nil {
		return 0, err21
	}
	i -= n21
	i = encodeVarintGuard(dAtA, i, uint64(n21))
	i--
	dAtA[i] = 0x22
	if m.FileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x52
	}
	if m.RentalState != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RentalState))
		i--
		dAtA[i] = 0x48
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x42
	}
	n22, err22 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.CurrentTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.CurrentTime):])
	if err22 != nil {
		return 0, err22
	}
	i -= n22
	i = encodeVarintGuard(dAtA, i, uint64(n22))
	i--
	dAtA[i] = 0x3a
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	n23, err23 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.GuardReceiveTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.GuardReceiveTime):])
	if err23 != nil {
		return 0, err23
	}
	i -= n23
	i = encodeVarintGuard(dAtA, i, uint64(n23))
	i--
	dAtA[i] = 0x2a
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.FileStoreMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExpectAnswer) > 0 {
		i -= len(m.ExpectAnswer)
		copy(dAtA[i:], m.ExpectAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ExpectAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if m.ChunkIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChunkIndex))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProofOfReplicateChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofOfReplicateChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofOfReplicateChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n25, err25 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.HostSignTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.HostSignTime):])
	if err25 != nil {
		return 0, err25
	}
	i -= n25
	i = encodeVarintGuard(dAtA, i, uint64(n25))
	i--
	dAtA[i] = 0x32
	if len(m.HostAnswer) > 0 {
		i -= len(m.HostAnswer)
		copy(dAtA[i:], m.HostAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x1a
	}
	n26, err26 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.ChallengeTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ChallengeTime):])
	if err26 != nil {
		return 0, err26
	}
	i -= n26
	i = encodeVarintGuard(dAtA, i, uint64(n26))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ChallengeQuestion.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FileChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardQuestions) > 0 {
		for iNdEx := len(m.ShardQuestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardQuestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n28, err28 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err28 != nil {
		return 0, err28
	}
	i -= n28
	i = encodeVarintGuard(dAtA, i, uint64(n28))
	i--
	dAtA[i] = 0x32
	if len(m.Questions) > 0 {
		for iNdEx := len(m.Questions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Questions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.QuestionCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.QuestionCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckFileStoreMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckFileStoreMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckFileStoreMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	n29, err29 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err29 != nil {
		return 0, err29
	}
	i -= n29
	i = encodeVarintGuard(dAtA, i, uint64(n29))
	i--
	dAtA[i] = 0x22
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRenterFileInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRenterFileInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRenterFileInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.LastModifyTime != nil {
		n30, err30 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(*m.LastModifyTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.LastModifyTime):])
		if err30 != nil {
			return 0, err30
		}
		i -= n30
		i = encodeVarintGuard(dAtA, i, uint64(n30))
		i--
		dAtA[i] = 0x32
	}
	if m.RequestTime != nil {
		n31, err31 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(*m.RequestTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.RequestTime):])
		if err31 != nil {
			return 0, err31
		}
		i -= n31
		i = encodeVarintGuard(dAtA, i, uint64(n31))
		i--
		dAtA[i] = 0x2a
	}
	if m.RequestPageIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestPageSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListHostContractsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHostContractsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHostContractsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RequestTime != nil {
		n32, err32 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(*m.RequestTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.RequestTime):])
		if err32 != nil {
			return 0, err32
		}
		i -= n32
		i = encodeVarintGuard(dAtA, i, uint64(n32))
		i--
		dAtA[i] = 0x42
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if m.LastModifyTimeTo != nil {
		n33, err33 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(*m.LastModifyTimeTo, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.LastModifyTimeTo):])
		if err33 != nil {
			return 0, err33
		}
		i -= n33
		i = encodeVarintGuard(dAtA, i, uint64(n33))
		i--
		dAtA[i] = 0x32
	}
	if m.LastModifyTimeSince != nil {
		n34, err34 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(*m.LastModifyTimeSince, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.LastModifyTimeSince):])
		if err34 != nil {
			return 0, err34
		}
		i -= n34
		i = encodeVarintGuard(dAtA, i, uint64(n34))
		i--
		dAtA[i] = 0x2a
	}
	if m.RequestPageIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestPageSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Count != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n35, err35 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.GenerateTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.GenerateTime):])
	if err35 != nil {
		return 0, err35
	}
	i -= n35
	i = encodeVarintGuard(dAtA, i, uint64(n35))
	i--
	dAtA[i] = 0x12
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadyForChallengeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadyForChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadyForChallengeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsRepair {
		i--
		if m.IsRepair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	n37, err37 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err37 != nil {
		return 0, err37
	}
	i -= n37
	i = encodeVarintGuard(dAtA, i, uint64(n37))
	i--
	dAtA[i] = 0x32
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsRepair {
		i--
		if m.IsRepair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	n38, err38 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err38 != nil {
		return 0, err38
	}
	i -= n38
	i = encodeVarintGuard(dAtA, i, uint64(n38))
	i--
	dAtA[i] = 0x12
	if m.Question != nil {
		{
			size, err := m.Question.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsRepair {
		i--
		if m.IsRepair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	n40, err40 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.ResolveTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResolveTime):])
	if err40 != nil {
		return 0, err40
	}
	i -= n40
	i = encodeVarintGuard(dAtA, i, uint64(n40))
	i--
	dAtA[i] = 0x1a
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Answer != nil {
		{
			size, err := m.Answer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForceRepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceRepairRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForceRepairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AuthPid) > 0 {
		i -= len(m.AuthPid)
		copy(dAtA[i:], m.AuthPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.AuthPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n42, err42 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.ResponseTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime):])
	if err42 != nil {
		return 0, err42
	}
	i -= n42
	i = encodeVarintGuard(dAtA, i, uint64(n42))
	i--
	dAtA[i] = 0x1a
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RepairContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepairContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x62
	}
	n43, err43 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.GuardSignTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.GuardSignTime):])
	if err43 != nil {
		return 0, err43
	}
	i -= n43
	i = encodeVarintGuard(dAtA, i, uint64(n43))
	i--
	dAtA[i] = 0x5a
	if len(m.RepairContractId) > 0 {
		i -= len(m.RepairContractId)
		copy(dAtA[i:], m.RepairContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairContractId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.DownloadContractId) > 0 {
		i -= len(m.DownloadContractId)
		copy(dAtA[i:], m.DownloadContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.DownloadContractId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RepairSignature) > 0 {
		i -= len(m.RepairSignature)
		copy(dAtA[i:], m.RepairSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairSignature)))
		i--
		dAtA[i] = 0x42
	}
	n44, err44 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RepairSignTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RepairSignTime):])
	if err44 != nil {
		return 0, err44
	}
	i -= n44
	i = encodeVarintGuard(dAtA, i, uint64(n44))
	i--
	dAtA[i] = 0x3a
	if len(m.RepairPid) > 0 {
		i -= len(m.RepairPid)
		copy(dAtA[i:], m.RepairPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairPid)))
		i--
		dAtA[i] = 0x32
	}
	if m.RepairRewardAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RepairRewardAmount))
		i--
		dAtA[i] = 0x28
	}
	if m.DownloadRewardAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.DownloadRewardAmount))
		i--
		dAtA[i] = 0x20
	}
	if m.FileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LostShardHash) > 0 {
		for iNdEx := len(m.LostShardHash) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LostShardHash[iNdEx])
			copy(dAtA[i:], m.LostShardHash[iNdEx])
			i = encodeVarintGuard(dAtA, i, uint64(len(m.LostShardHash[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepairContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepairContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Contract != nil {
		{
			size, err := m.Contract.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestRepairContracts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRepairContracts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestRepairContracts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RepairSignature) > 0 {
		i -= len(m.RepairSignature)
		copy(dAtA[i:], m.RepairSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairSignature)))
		i--
		dAtA[i] = 0x22
	}
	n46, err46 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RepairSignTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RepairSignTime):])
	if err46 != nil {
		return 0, err46
	}
	i -= n46
	i = encodeVarintGuard(dAtA, i, uint64(n46))
	i--
	dAtA[i] = 0x1a
	if len(m.RepairNode) > 0 {
		i -= len(m.RepairNode)
		copy(dAtA[i:], m.RepairNode)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairNode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseRepairContracts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseRepairContracts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseRepairContracts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n47, err47 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.SignTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SignTime):])
	if err47 != nil {
		return 0, err47
	}
	i -= n47
	i = encodeVarintGuard(dAtA, i, uint64(n47))
	i--
	dAtA[i] = 0x32
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RepairNode) > 0 {
		i -= len(m.RepairNode)
		copy(dAtA[i:], m.RepairNode)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairNode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelContractRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelContractRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelContractRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x42
	}
	n49, err49 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.SignTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SignTime):])
	if err49 != nil {
		return 0, err49
	}
	i -= n49
	i = encodeVarintGuard(dAtA, i, uint64(n49))
	i--
	dAtA[i] = 0x3a
	if m.Reason != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x30
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	n50, err50 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err50 != nil {
		return 0, err50
	}
	i -= n50
	i = encodeVarintGuard(dAtA, i, uint64(n50))
	i--
	dAtA[i] = 0x12
	if len(m.NodePid) > 0 {
		i -= len(m.NodePid)
		copy(dAtA[i:], m.NodePid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.NodePid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x42
	}
	n51, err51 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.JobFinishDeadline, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.JobFinishDeadline):])
	if err51 != nil {
		return 0, err51
	}
	i -= n51
	i = encodeVarintGuard(dAtA, i, uint64(n51))
	i--
	dAtA[i] = 0x3a
	n52, err52 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.SendTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SendTime):])
	if err52 != nil {
		return 0, err52
	}
	i -= n52
	i = encodeVarintGuard(dAtA, i, uint64(n52))
	i--
	dAtA[i] = 0x32
	if m.PackageQuestionsCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.PackageQuestionsCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PackageUrl) > 0 {
		i -= len(m.PackageUrl)
		copy(dAtA[i:], m.PackageUrl)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PackageUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IssuerPid) > 0 {
		i -= len(m.IssuerPid)
		copy(dAtA[i:], m.IssuerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.IssuerPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodePid) > 0 {
		i -= len(m.NodePid)
		copy(dAtA[i:], m.NodePid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.NodePid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeJobResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeJobResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeJobResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	n53, err53 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(m.SubmitTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SubmitTime):])
	if err53 != nil {
		return 0, err53
	}
	i -= n53
	i = encodeVarintGuard(dAtA, i, uint64(n53))
	i--
	dAtA[i] = 0x22
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodePid) > 0 {
		i -= len(m.NodePid)
		copy(dAtA[i:], m.NodePid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.NodePid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardChallengeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardChallengeResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardChallengeResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsTimeout {
		i--
		if m.IsTimeout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeCentralQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeCentralQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeCentralQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTime != nil {
		n54, err54 := github_com_bittorrent_protobuf_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.EndTime):])
		if err54 != nil {
			return 0, err54
		}
		i -= n54
		i = encodeVarintGuard(dAtA, i, uint64(n54))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Qs) > 0 {
		for iNdEx := len(m.Qs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Qs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if m.ChunkIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChunkIndex))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGuard(dAtA []byte, offset int, v uint64) int {
	offset -= sovGuard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedAdminQuery(r randyGuard, easy bool) *AdminQuery {
	this := &AdminQuery{}
	this.RequesterPid = string(randStringGuard(r))
	v1 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.QueryDate = *v1
	this.QueryCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.QueryCount *= -1
	}
	v2 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RequestTime = *v2
	v3 := r.Intn(100)
	this.Signature = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedDailySummary(r randyGuard, easy bool) *DailySummary {
	this := &DailySummary{}
	v4 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.QueryDate = *v4
	v5 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResponseTime = *v5
	this.PreparerPid = string(randStringGuard(r))
	v6 := r.Intn(100)
	this.Signature = make([]byte, v6)
	for i := 0; i < v6; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.WorkingStorageSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.WorkingStorageSize *= -1
	}
	this.NewContracts = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.NewContracts *= -1
	}
	this.NewContractsHost = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.NewContractsHost *= -1
	}
	this.NewContractsRenter = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.NewContractsRenter *= -1
	}
	this.NewContractsAveragePrice = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.NewContractsAveragePrice *= -1
	}
	this.NewFiles = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.NewFiles *= -1
	}
	this.NewShardsSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.NewShardsSize *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 12)
	}
	return this
}

func NewPopulatedHostSummary(r randyGuard, easy bool) *HostSummary {
	this := &HostSummary{}
	v7 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.QueryDate = *v7
	v8 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResponseTime = *v8
	this.PreparerPid = string(randStringGuard(r))
	v9 := r.Intn(100)
	this.Signature = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.RecordCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RecordCount *= -1
	}
	if r.Intn(5) != 0 {
		v10 := r.Intn(5)
		this.Status = make([]*HostStatus, v10)
		for i := 0; i < v10; i++ {
			this.Status[i] = NewPopulatedHostStatus(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 7)
	}
	return this
}

func NewPopulatedTotalStateSummary(r randyGuard, easy bool) *TotalStateSummary {
	this := &TotalStateSummary{}
	v11 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.QueryDate = *v11
	v12 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResponseTime = *v12
	this.PreparerPid = string(randStringGuard(r))
	v13 := r.Intn(100)
	this.Signature = make([]byte, v13)
	for i := 0; i < v13; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.ValidContractCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ValidContractCount *= -1
	}
	this.ExistedShardSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ExistedShardSize *= -1
	}
	this.InvalidContractCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.InvalidContractCount *= -1
	}
	this.LostShardSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LostShardSize *= -1
	}
	this.TotalHostReward = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TotalHostReward *= -1
	}
	this.TotalWbttReward = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TotalWbttReward *= -1
	}
	this.TotalTrxReward = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TotalTrxReward *= -1
	}
	this.TotalUsddReward = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TotalUsddReward *= -1
	}
	this.TotalUsdtReward = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TotalUsdtReward *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 14)
	}
	return this
}

func NewPopulatedHostStatus(r randyGuard, easy bool) *HostStatus {
	this := &HostStatus{}
	this.HostPid = string(randStringGuard(r))
	this.FileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FileSize *= -1
	}
	this.WorkAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.WorkAmount *= -1
	}
	this.RewardBtt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.RewardBtt *= -1
	}
	this.SuspectCheat = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedLog(r randyGuard, easy bool) *Log {
	this := &Log{}
	v14 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ChangeTime = *v14
	this.OriginatorPid = string(randStringGuard(r))
	this.Change = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 4)
	}
	return this
}

func NewPopulatedContractMeta(r randyGuard, easy bool) *ContractMeta {
	this := &ContractMeta{}
	this.ContractId = string(randStringGuard(r))
	this.RenterPid = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.ShardIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ShardIndex *= -1
	}
	this.ShardFileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ShardFileSize *= -1
	}
	this.FileHash = string(randStringGuard(r))
	v15 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentStart = *v15
	v16 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentEnd = *v16
	this.GuardPid = string(randStringGuard(r))
	this.EscrowPid = string(randStringGuard(r))
	this.Price = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Price *= -1
	}
	this.Amount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Amount *= -1
	}
	this.CollateralAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.CollateralAmount *= -1
	}
	this.PayoutSchedule = ContractMeta_Schedule([]int32{0, 1, 2}[r.Intn(3)])
	this.NumPayouts = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.NumPayouts *= -1
	}
	this.ContingentAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ContingentAmount *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 18)
	}
	return this
}

func NewPopulatedContract(r randyGuard, easy bool) *Contract {
	this := &Contract{}
	v17 := NewPopulatedContractMeta(r, easy)
	this.ContractMeta = *v17
	this.State = Contract_ContractState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}[r.Intn(13)])
	v18 := r.Intn(100)
	this.RenterSignature = make([]byte, v18)
	for i := 0; i < v18; i++ {
		this.RenterSignature[i] = byte(r.Intn(256))
	}
	v19 := r.Intn(100)
	this.HostSignature = make([]byte, v19)
	for i := 0; i < v19; i++ {
		this.HostSignature[i] = byte(r.Intn(256))
	}
	v20 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.EscrowSignedTime = *v20
	v21 := r.Intn(100)
	this.EscrowSignature = make([]byte, v21)
	for i := 0; i < v21; i++ {
		this.EscrowSignature[i] = byte(r.Intn(256))
	}
	if r.Intn(5) != 0 {
		v22 := r.Intn(5)
		this.ChangeLog = make([]*Log, v22)
		for i := 0; i < v22; i++ {
			this.ChangeLog[i] = NewPopulatedLog(r, easy)
		}
	}
	v23 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastModifyTime = *v23
	v24 := r.Intn(100)
	this.GuardSignature = make([]byte, v24)
	for i := 0; i < v24; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.PreparerPid = string(randStringGuard(r))
	v25 := r.Intn(100)
	this.PreparerSignature = make([]byte, v25)
	for i := 0; i < v25; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	v26 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastSuccessChallengeTime = *v26
	v27 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastChallengeTime = *v27
	this.ChallengeTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeTimes *= -1
	}
	this.ChallengeWarnTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeWarnTimes *= -1
	}
	this.ChallengeSuccessTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeSuccessTimes *= -1
	}
	v28 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.FirstChallengeSuccess = *v28
	this.Token = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 19)
	}
	return this
}

func NewPopulatedFileStoreListResponse(r randyGuard, easy bool) *FileStoreListResponse {
	this := &FileStoreListResponse{}
	if r.Intn(5) != 0 {
		this.Request = NewPopulatedListRenterFileInfoRequest(r, easy)
	}
	v29 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.CurrentTime = *v29
	if r.Intn(5) != 0 {
		v30 := r.Intn(5)
		this.FileStoreMeta = make([]*FileStoreMeta, v30)
		for i := 0; i < v30; i++ {
			this.FileStoreMeta[i] = NewPopulatedFileStoreMeta(r, easy)
		}
	}
	this.Count = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	v31 := r.Intn(100)
	this.Signature = make([]byte, v31)
	for i := 0; i < v31; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedFileStoreMeta(r randyGuard, easy bool) *FileStoreMeta {
	this := &FileStoreMeta{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.FileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FileSize *= -1
	}
	v32 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentStart = *v32
	v33 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentEnd = *v33
	this.CheckFrequency = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CheckFrequency *= -1
	}
	this.GuardFee = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.GuardFee *= -1
	}
	this.EscrowFee = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EscrowFee *= -1
	}
	this.ShardCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ShardCount *= -1
	}
	this.MinimumShards = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MinimumShards *= -1
	}
	this.RecoverThreshold = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RecoverThreshold *= -1
	}
	this.EscrowPid = string(randStringGuard(r))
	this.GuardPid = string(randStringGuard(r))
	this.WarnChallengeTimesLimit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WarnChallengeTimesLimit *= -1
	}
	this.SuccessChallengeTimesLimit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.SuccessChallengeTimesLimit *= -1
	}
	this.CheckFrequencyWarn = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CheckFrequencyWarn *= -1
	}
	this.Token = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 18)
	}
	return this
}

func NewPopulatedFileStoreStatus(r randyGuard, easy bool) *FileStoreStatus {
	this := &FileStoreStatus{}
	v34 := NewPopulatedFileStoreMeta(r, easy)
	this.FileStoreMeta = *v34
	this.State = FileStoreStatus_MetaState([]int32{0, 1, 2, 3, 4, 5, 6, 7}[r.Intn(8)])
	if r.Intn(5) != 0 {
		v35 := r.Intn(5)
		this.Contracts = make([]*Contract, v35)
		for i := 0; i < v35; i++ {
			this.Contracts[i] = NewPopulatedContract(r, easy)
		}
	}
	v36 := r.Intn(100)
	this.RenterSignature = make([]byte, v36)
	for i := 0; i < v36; i++ {
		this.RenterSignature[i] = byte(r.Intn(256))
	}
	v37 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GuardReceiveTime = *v37
	if r.Intn(5) != 0 {
		v38 := r.Intn(5)
		this.ChangeLog = make([]*Log, v38)
		for i := 0; i < v38; i++ {
			this.ChangeLog[i] = NewPopulatedLog(r, easy)
		}
	}
	v39 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.CurrentTime = *v39
	v40 := r.Intn(100)
	this.GuardSignature = make([]byte, v40)
	for i := 0; i < v40; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.RentalState = FileStoreStatus_RentalState([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.PreparerPid = string(randStringGuard(r))
	v41 := r.Intn(100)
	this.PreparerSignature = make([]byte, v41)
	for i := 0; i < v41; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 12)
	}
	return this
}

func NewPopulatedChallengeQuestion(r randyGuard, easy bool) *ChallengeQuestion {
	this := &ChallengeQuestion{}
	this.ShardHash = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.ChunkIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChunkIndex *= -1
	}
	this.Nonce = string(randStringGuard(r))
	this.ExpectAnswer = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedProofOfReplicateChallenge(r randyGuard, easy bool) *ProofOfReplicateChallenge {
	this := &ProofOfReplicateChallenge{}
	v42 := NewPopulatedChallengeQuestion(r, easy)
	this.ChallengeQuestion = *v42
	v43 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ChallengeTime = *v43
	this.GuardPid = string(randStringGuard(r))
	v44 := r.Intn(100)
	this.GuardSignature = make([]byte, v44)
	for i := 0; i < v44; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.HostAnswer = string(randStringGuard(r))
	v45 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.HostSignTime = *v45
	v46 := r.Intn(100)
	this.HostSignature = make([]byte, v46)
	for i := 0; i < v46; i++ {
		this.HostSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedFileChallengeQuestions(r randyGuard, easy bool) *FileChallengeQuestions {
	this := &FileChallengeQuestions{}
	this.FileHash = string(randStringGuard(r))
	if r.Intn(5) != 0 {
		v47 := r.Intn(5)
		this.ShardQuestions = make([]*ShardChallengeQuestions, v47)
		for i := 0; i < v47; i++ {
			this.ShardQuestions[i] = NewPopulatedShardChallengeQuestions(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 3)
	}
	return this
}

func NewPopulatedShardChallengeQuestions(r randyGuard, easy bool) *ShardChallengeQuestions {
	this := &ShardChallengeQuestions{}
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.PreparerPid = string(randStringGuard(r))
	this.QuestionCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.QuestionCount *= -1
	}
	if r.Intn(5) != 0 {
		v48 := r.Intn(5)
		this.Questions = make([]*ChallengeQuestion, v48)
		for i := 0; i < v48; i++ {
			this.Questions[i] = NewPopulatedChallengeQuestion(r, easy)
		}
	}
	v49 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v49
	v50 := r.Intn(100)
	this.PreparerSignature = make([]byte, v50)
	for i := 0; i < v50; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedCheckFileStoreMetaRequest(r randyGuard, easy bool) *CheckFileStoreMetaRequest {
	this := &CheckFileStoreMetaRequest{}
	this.FileHash = string(randStringGuard(r))
	this.RenterPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	v51 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RequestTime = *v51
	v52 := r.Intn(100)
	this.Signature = make([]byte, v52)
	for i := 0; i < v52; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedListRenterFileInfoRequest(r randyGuard, easy bool) *ListRenterFileInfoRequest {
	this := &ListRenterFileInfoRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	this.RequestPageSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageSize *= -1
	}
	this.RequestPageIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageIndex *= -1
	}
	if r.Intn(5) != 0 {
		this.RequestTime = github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	if r.Intn(5) != 0 {
		this.LastModifyTime = github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	v53 := r.Intn(100)
	this.Signature = make([]byte, v53)
	for i := 0; i < v53; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedListHostContractsRequest(r randyGuard, easy bool) *ListHostContractsRequest {
	this := &ListHostContractsRequest{}
	this.HostPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	this.RequestPageSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageSize *= -1
	}
	this.RequestPageIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageIndex *= -1
	}
	if r.Intn(5) != 0 {
		this.LastModifyTimeSince = github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	if r.Intn(5) != 0 {
		this.LastModifyTimeTo = github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	this.State = ListHostContractsRequest_SelectState([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(5) != 0 {
		this.RequestTime = github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	v54 := r.Intn(100)
	this.Signature = make([]byte, v54)
	for i := 0; i < v54; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 10)
	}
	return this
}

func NewPopulatedContractsList(r randyGuard, easy bool) *ContractsList {
	this := &ContractsList{}
	if r.Intn(5) != 0 {
		this.Request = NewPopulatedListHostContractsRequest(r, easy)
	}
	v55 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GenerateTime = *v55
	if r.Intn(5) != 0 {
		v56 := r.Intn(5)
		this.Contracts = make([]*Contract, v56)
		for i := 0; i < v56; i++ {
			this.Contracts[i] = NewPopulatedContract(r, easy)
		}
	}
	this.Count = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	v57 := r.Intn(100)
	this.Signature = make([]byte, v57)
	for i := 0; i < v57; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedReadyForChallengeRequest(r randyGuard, easy bool) *ReadyForChallengeRequest {
	this := &ReadyForChallengeRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.ContractId = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	v58 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v58
	v59 := r.Intn(100)
	this.Signature = make([]byte, v59)
	for i := 0; i < v59; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.IsRepair = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 9)
	}
	return this
}

func NewPopulatedRequestChallengeQuestion(r randyGuard, easy bool) *RequestChallengeQuestion {
	this := &RequestChallengeQuestion{}
	if r.Intn(5) != 0 {
		this.Question = NewPopulatedChallengeQuestion(r, easy)
	}
	v60 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v60
	v61 := r.Intn(100)
	this.Signature = make([]byte, v61)
	for i := 0; i < v61; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.IsRepair = bool(bool(r.Intn(2) == 0))
	this.FileHash = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedResponseChallengeQuestion(r randyGuard, easy bool) *ResponseChallengeQuestion {
	this := &ResponseChallengeQuestion{}
	if r.Intn(5) != 0 {
		this.Answer = NewPopulatedChallengeQuestion(r, easy)
	}
	this.HostPid = string(randStringGuard(r))
	v62 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResolveTime = *v62
	v63 := r.Intn(100)
	this.Signature = make([]byte, v63)
	for i := 0; i < v63; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.IsRepair = bool(bool(r.Intn(2) == 0))
	this.FileHash = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 7)
	}
	return this
}

func NewPopulatedForceRepairRequest(r randyGuard, easy bool) *ForceRepairRequest {
	this := &ForceRepairRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.AuthPid = string(randStringGuard(r))
	v64 := r.Intn(100)
	this.Signature = make([]byte, v64)
	for i := 0; i < v64; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 5)
	}
	return this
}

func NewPopulatedResult(r randyGuard, easy bool) *Result {
	this := &Result{}
	this.Code = ResponseCode([]int32{0, 1, 2, 20}[r.Intn(4)])
	this.Message = string(randStringGuard(r))
	v65 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResponseTime = *v65
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 4)
	}
	return this
}

func NewPopulatedRepairContract(r randyGuard, easy bool) *RepairContract {
	this := &RepairContract{}
	this.FileHash = string(randStringGuard(r))
	v66 := r.Intn(10)
	this.LostShardHash = make([]string, v66)
	for i := 0; i < v66; i++ {
		this.LostShardHash[i] = string(randStringGuard(r))
	}
	this.FileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FileSize *= -1
	}
	this.DownloadRewardAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DownloadRewardAmount *= -1
	}
	this.RepairRewardAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.RepairRewardAmount *= -1
	}
	this.RepairPid = string(randStringGuard(r))
	v67 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RepairSignTime = *v67
	v68 := r.Intn(100)
	this.RepairSignature = make([]byte, v68)
	for i := 0; i < v68; i++ {
		this.RepairSignature[i] = byte(r.Intn(256))
	}
	this.DownloadContractId = string(randStringGuard(r))
	this.RepairContractId = string(randStringGuard(r))
	v69 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GuardSignTime = *v69
	v70 := r.Intn(100)
	this.GuardSignature = make([]byte, v70)
	for i := 0; i < v70; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 13)
	}
	return this
}

func NewPopulatedRepairContractResponse(r randyGuard, easy bool) *RepairContractResponse {
	this := &RepairContractResponse{}
	if r.Intn(5) != 0 {
		this.Contract = NewPopulatedRepairContract(r, easy)
	}
	this.Status = RepairContractResponse_ContractResponseStatus([]int32{0, 1, 2}[r.Intn(3)])
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 3)
	}
	return this
}

func NewPopulatedRequestRepairContracts(r randyGuard, easy bool) *RequestRepairContracts {
	this := &RequestRepairContracts{}
	this.FileHash = string(randStringGuard(r))
	this.RepairNode = string(randStringGuard(r))
	v71 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RepairSignTime = *v71
	v72 := r.Intn(100)
	this.RepairSignature = make([]byte, v72)
	for i := 0; i < v72; i++ {
		this.RepairSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 5)
	}
	return this
}

func NewPopulatedResponseRepairContracts(r randyGuard, easy bool) *ResponseRepairContracts {
	this := &ResponseRepairContracts{}
	this.FileHash = string(randStringGuard(r))
	this.RepairNode = string(randStringGuard(r))
	this.State = ResponseRepairContracts_RepairStat([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(5) != 0 {
		this.Status = NewPopulatedFileStoreStatus(r, easy)
	}
	this.GuardPid = string(randStringGuard(r))
	v73 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.SignTime = *v73
	v74 := r.Intn(100)
	this.GuardSignature = make([]byte, v74)
	for i := 0; i < v74; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedCancelContractRequest(r randyGuard, easy bool) *CancelContractRequest {
	this := &CancelContractRequest{}
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.ContractId = string(randStringGuard(r))
	this.RenterPid = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.Reason = CancelContractRequest_CancelReason([]int32{0, 1, 2, 3}[r.Intn(4)])
	v75 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.SignTime = *v75
	v76 := r.Intn(100)
	this.Signature = make([]byte, v76)
	for i := 0; i < v76; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 9)
	}
	return this
}

func NewPopulatedChallengeJobRequest(r randyGuard, easy bool) *ChallengeJobRequest {
	this := &ChallengeJobRequest{}
	this.NodePid = string(randStringGuard(r))
	v77 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RequestTime = *v77
	v78 := r.Intn(100)
	this.Signature = make([]byte, v78)
	for i := 0; i < v78; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 4)
	}
	return this
}

func NewPopulatedChallengeJobResponse(r randyGuard, easy bool) *ChallengeJobResponse {
	this := &ChallengeJobResponse{}
	this.NodePid = string(randStringGuard(r))
	this.IssuerPid = string(randStringGuard(r))
	this.JobId = string(randStringGuard(r))
	this.PackageUrl = string(randStringGuard(r))
	this.PackageQuestionsCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.PackageQuestionsCount *= -1
	}
	v79 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.SendTime = *v79
	v80 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.JobFinishDeadline = *v80
	v81 := r.Intn(100)
	this.Signature = make([]byte, v81)
	for i := 0; i < v81; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 9)
	}
	return this
}

func NewPopulatedChallengeJobResult(r randyGuard, easy bool) *ChallengeJobResult {
	this := &ChallengeJobResult{}
	this.NodePid = string(randStringGuard(r))
	this.JobId = string(randStringGuard(r))
	if r.Intn(5) != 0 {
		v82 := r.Intn(5)
		this.Result = make([]*ShardChallengeResult, v82)
		for i := 0; i < v82; i++ {
			this.Result[i] = NewPopulatedShardChallengeResult(r, easy)
		}
	}
	v83 := github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	this.SubmitTime = *v83
	v84 := r.Intn(100)
	this.Signature = make([]byte, v84)
	for i := 0; i < v84; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedShardChallengeResult(r randyGuard, easy bool) *ShardChallengeResult {
	this := &ShardChallengeResult{}
	this.HostPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.Nonce = string(randStringGuard(r))
	this.Result = string(randStringGuard(r))
	this.IsTimeout = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 7)
	}
	return this
}

func NewPopulatedDeCentralQuestions(r randyGuard, easy bool) *DeCentralQuestions {
	this := &DeCentralQuestions{}
	if r.Intn(5) != 0 {
		v85 := r.Intn(5)
		this.Qs = make([]*DeQuestion, v85)
		for i := 0; i < v85; i++ {
			this.Qs[i] = NewPopulatedDeQuestion(r, easy)
		}
	}
	this.Count = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	this.Uuid = string(randStringGuard(r))
	this.Url = string(randStringGuard(r))
	if r.Intn(5) != 0 {
		this.EndTime = github_com_bittorrent_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedDeQuestion(r randyGuard, easy bool) *DeQuestion {
	this := &DeQuestion{}
	this.ShardHash = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.ChunkIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChunkIndex *= -1
	}
	this.Nonce = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

type randyGuard interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneGuard(r randyGuard) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringGuard(r randyGuard) string {
	v86 := r.Intn(100)
	tmps := make([]rune, v86)
	for i := 0; i < v86; i++ {
		tmps[i] = randUTF8RuneGuard(r)
	}
	return string(tmps)
}
func randUnrecognizedGuard(r randyGuard, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldGuard(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldGuard(dAtA []byte, r randyGuard, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		v87 := r.Int63()
		if r.Intn(2) == 0 {
			v87 *= -1
		}
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(v87))
	case 1:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateGuard(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *AdminQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate)
	n += 1 + l + sovGuard(uint64(l))
	if m.QueryCount != 0 {
		n += 1 + sovGuard(uint64(m.QueryCount))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailySummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.WorkingStorageSize != 0 {
		n += 1 + sovGuard(uint64(m.WorkingStorageSize))
	}
	if m.NewContracts != 0 {
		n += 1 + sovGuard(uint64(m.NewContracts))
	}
	if m.NewContractsHost != 0 {
		n += 1 + sovGuard(uint64(m.NewContractsHost))
	}
	if m.NewContractsRenter != 0 {
		n += 1 + sovGuard(uint64(m.NewContractsRenter))
	}
	if m.NewContractsAveragePrice != 0 {
		n += 1 + sovGuard(uint64(m.NewContractsAveragePrice))
	}
	if m.NewFiles != 0 {
		n += 1 + sovGuard(uint64(m.NewFiles))
	}
	if m.NewShardsSize != 0 {
		n += 1 + sovGuard(uint64(m.NewShardsSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HostSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RecordCount != 0 {
		n += 1 + sovGuard(uint64(m.RecordCount))
	}
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TotalStateSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.QueryDate)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ValidContractCount != 0 {
		n += 1 + sovGuard(uint64(m.ValidContractCount))
	}
	if m.ExistedShardSize != 0 {
		n += 1 + sovGuard(uint64(m.ExistedShardSize))
	}
	if m.InvalidContractCount != 0 {
		n += 1 + sovGuard(uint64(m.InvalidContractCount))
	}
	if m.LostShardSize != 0 {
		n += 1 + sovGuard(uint64(m.LostShardSize))
	}
	if m.TotalHostReward != 0 {
		n += 1 + sovGuard(uint64(m.TotalHostReward))
	}
	if m.TotalWbttReward != 0 {
		n += 1 + sovGuard(uint64(m.TotalWbttReward))
	}
	if m.TotalTrxReward != 0 {
		n += 1 + sovGuard(uint64(m.TotalTrxReward))
	}
	if m.TotalUsddReward != 0 {
		n += 1 + sovGuard(uint64(m.TotalUsddReward))
	}
	if m.TotalUsdtReward != 0 {
		n += 1 + sovGuard(uint64(m.TotalUsdtReward))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HostStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovGuard(uint64(m.FileSize))
	}
	if m.WorkAmount != 0 {
		n += 1 + sovGuard(uint64(m.WorkAmount))
	}
	if m.RewardBtt != 0 {
		n += 1 + sovGuard(uint64(m.RewardBtt))
	}
	if m.SuspectCheat {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ChangeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.OriginatorPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Change)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContractMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ShardIndex != 0 {
		n += 1 + sovGuard(uint64(m.ShardIndex))
	}
	if m.ShardFileSize != 0 {
		n += 1 + sovGuard(uint64(m.ShardFileSize))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentStart)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentEnd)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.EscrowPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovGuard(uint64(m.Price))
	}
	if m.Amount != 0 {
		n += 1 + sovGuard(uint64(m.Amount))
	}
	if m.CollateralAmount != 0 {
		n += 1 + sovGuard(uint64(m.CollateralAmount))
	}
	if m.PayoutSchedule != 0 {
		n += 1 + sovGuard(uint64(m.PayoutSchedule))
	}
	if m.NumPayouts != 0 {
		n += 2 + sovGuard(uint64(m.NumPayouts))
	}
	if m.ContingentAmount != 0 {
		n += 2 + sovGuard(uint64(m.ContingentAmount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ContractMeta.Size()
	n += 1 + l + sovGuard(uint64(l))
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.EscrowSignedTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.EscrowSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.LastModifyTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.LastSuccessChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.LastChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	if m.ChallengeTimes != 0 {
		n += 1 + sovGuard(uint64(m.ChallengeTimes))
	}
	if m.ChallengeWarnTimes != 0 {
		n += 1 + sovGuard(uint64(m.ChallengeWarnTimes))
	}
	if m.ChallengeSuccessTimes != 0 {
		n += 2 + sovGuard(uint64(m.ChallengeSuccessTimes))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.FirstChallengeSuccess)
	n += 2 + l + sovGuard(uint64(l))
	l = len(m.Token)
	if l > 0 {
		n += 2 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.CurrentTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.FileStoreMeta) > 0 {
		for _, e := range m.FileStoreMeta {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovGuard(uint64(m.Count))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovGuard(uint64(m.FileSize))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentStart)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RentEnd)
	n += 1 + l + sovGuard(uint64(l))
	if m.CheckFrequency != 0 {
		n += 1 + sovGuard(uint64(m.CheckFrequency))
	}
	if m.GuardFee != 0 {
		n += 1 + sovGuard(uint64(m.GuardFee))
	}
	if m.EscrowFee != 0 {
		n += 1 + sovGuard(uint64(m.EscrowFee))
	}
	if m.ShardCount != 0 {
		n += 1 + sovGuard(uint64(m.ShardCount))
	}
	if m.MinimumShards != 0 {
		n += 1 + sovGuard(uint64(m.MinimumShards))
	}
	if m.RecoverThreshold != 0 {
		n += 1 + sovGuard(uint64(m.RecoverThreshold))
	}
	l = len(m.EscrowPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.WarnChallengeTimesLimit != 0 {
		n += 1 + sovGuard(uint64(m.WarnChallengeTimesLimit))
	}
	if m.SuccessChallengeTimesLimit != 0 {
		n += 1 + sovGuard(uint64(m.SuccessChallengeTimesLimit))
	}
	if m.CheckFrequencyWarn != 0 {
		n += 2 + sovGuard(uint64(m.CheckFrequencyWarn))
	}
	l = len(m.Token)
	if l > 0 {
		n += 2 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FileStoreMeta.Size()
	n += 1 + l + sovGuard(uint64(l))
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.GuardReceiveTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.CurrentTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RentalState != 0 {
		n += 1 + sovGuard(uint64(m.RentalState))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ChunkIndex != 0 {
		n += 1 + sovGuard(uint64(m.ChunkIndex))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ExpectAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProofOfReplicateChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ChallengeQuestion.Size()
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.HostSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ShardQuestions) > 0 {
		for _, e := range m.ShardQuestions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.QuestionCount != 0 {
		n += 1 + sovGuard(uint64(m.QuestionCount))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckFileStoreMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRenterFileInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RequestPageSize != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageSize))
	}
	if m.RequestPageIndex != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageIndex))
	}
	if m.RequestTime != nil {
		l = github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.RequestTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.LastModifyTime != nil {
		l = github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.LastModifyTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHostContractsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RequestPageSize != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageSize))
	}
	if m.RequestPageIndex != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageIndex))
	}
	if m.LastModifyTimeSince != nil {
		l = github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.LastModifyTimeSince)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.LastModifyTimeTo != nil {
		l = github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.LastModifyTimeTo)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if m.RequestTime != nil {
		l = github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.RequestTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContractsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.GenerateTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovGuard(uint64(m.Count))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadyForChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.IsRepair {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Question != nil {
		l = m.Question.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.IsRepair {
		n += 2
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Answer != nil {
		l = m.Answer.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResolveTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.IsRepair {
		n += 2
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForceRepairRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.AuthPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGuard(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.ResponseTime)
	n += 1 + l + sovGuard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepairContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.LostShardHash) > 0 {
		for _, s := range m.LostShardHash {
			l = len(s)
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.FileSize != 0 {
		n += 1 + sovGuard(uint64(m.FileSize))
	}
	if m.DownloadRewardAmount != 0 {
		n += 1 + sovGuard(uint64(m.DownloadRewardAmount))
	}
	if m.RepairRewardAmount != 0 {
		n += 1 + sovGuard(uint64(m.RepairRewardAmount))
	}
	l = len(m.RepairPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RepairSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.RepairSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.DownloadContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RepairContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.GuardSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepairContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Contract != nil {
		l = m.Contract.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGuard(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestRepairContracts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RepairNode)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RepairSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.RepairSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseRepairContracts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RepairNode)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelContractRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovGuard(uint64(m.Reason))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodePid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodePid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.IssuerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PackageUrl)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.PackageQuestionsCount != 0 {
		n += 1 + sovGuard(uint64(m.PackageQuestionsCount))
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SendTime)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.JobFinishDeadline)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeJobResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodePid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_bittorrent_protobuf_types.SizeOfStdTime(m.SubmitTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardChallengeResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.IsTimeout {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeCentralQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Qs) > 0 {
		for _, e := range m.Qs {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovGuard(uint64(m.Count))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_bittorrent_protobuf_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ChunkIndex != 0 {
		n += 1 + sovGuard(uint64(m.ChunkIndex))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGuard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGuard(x uint64) (n int) {
	return sovGuard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AdminQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.QueryDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryCount", wireType)
			}
			m.QueryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailySummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailySummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailySummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.QueryDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.ResponseTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingStorageSize", wireType)
			}
			m.WorkingStorageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingStorageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewContracts", wireType)
			}
			m.NewContracts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewContracts |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewContractsHost", wireType)
			}
			m.NewContractsHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewContractsHost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewContractsRenter", wireType)
			}
			m.NewContractsRenter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewContractsRenter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewContractsAveragePrice", wireType)
			}
			m.NewContractsAveragePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewContractsAveragePrice |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFiles", wireType)
			}
			m.NewFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewFiles |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewShardsSize", wireType)
			}
			m.NewShardsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewShardsSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.QueryDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.ResponseTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCount", wireType)
			}
			m.RecordCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, &HostStatus{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalStateSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalStateSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalStateSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.QueryDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.ResponseTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidContractCount", wireType)
			}
			m.ValidContractCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidContractCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistedShardSize", wireType)
			}
			m.ExistedShardSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExistedShardSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidContractCount", wireType)
			}
			m.InvalidContractCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidContractCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostShardSize", wireType)
			}
			m.LostShardSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LostShardSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHostReward", wireType)
			}
			m.TotalHostReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHostReward |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWbttReward", wireType)
			}
			m.TotalWbttReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalWbttReward |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTrxReward", wireType)
			}
			m.TotalTrxReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTrxReward |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsddReward", wireType)
			}
			m.TotalUsddReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsddReward |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsdtReward", wireType)
			}
			m.TotalUsdtReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsdtReward |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkAmount", wireType)
			}
			m.WorkAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardBtt", wireType)
			}
			m.RewardBtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardBtt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuspectCheat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuspectCheat = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.ChangeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginatorPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginatorPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Change = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardIndex", wireType)
			}
			m.ShardIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardFileSize", wireType)
			}
			m.ShardFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAmount", wireType)
			}
			m.CollateralAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutSchedule", wireType)
			}
			m.PayoutSchedule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayoutSchedule |= ContractMeta_Schedule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPayouts", wireType)
			}
			m.NumPayouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPayouts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContingentAmount", wireType)
			}
			m.ContingentAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContingentAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Contract_ContractState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.EscrowSignedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowSignature = append(m.EscrowSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowSignature == nil {
				m.EscrowSignature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.LastModifyTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.LastSuccessChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.LastChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimes", wireType)
			}
			m.ChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeWarnTimes", wireType)
			}
			m.ChallengeWarnTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeWarnTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeSuccessTimes", wireType)
			}
			m.ChallengeSuccessTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeSuccessTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstChallengeSuccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.FirstChallengeSuccess, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &ListRenterFileInfoRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.CurrentTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStoreMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileStoreMeta = append(m.FileStoreMeta, &FileStoreMeta{})
			if err := m.FileStoreMeta[len(m.FileStoreMeta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFrequency", wireType)
			}
			m.CheckFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckFrequency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardFee", wireType)
			}
			m.GuardFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowFee", wireType)
			}
			m.EscrowFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EscrowFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCount", wireType)
			}
			m.ShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumShards", wireType)
			}
			m.MinimumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumShards |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverThreshold", wireType)
			}
			m.RecoverThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarnChallengeTimesLimit", wireType)
			}
			m.WarnChallengeTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarnChallengeTimesLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessChallengeTimesLimit", wireType)
			}
			m.SuccessChallengeTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessChallengeTimesLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFrequencyWarn", wireType)
			}
			m.CheckFrequencyWarn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckFrequencyWarn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStoreMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileStoreMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FileStoreStatus_MetaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardReceiveTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.GuardReceiveTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.CurrentTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentalState", wireType)
			}
			m.RentalState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RentalState |= FileStoreStatus_RentalState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkIndex", wireType)
			}
			m.ChunkIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectAnswer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofOfReplicateChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeQuestion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChallengeQuestion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.ChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAnswer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.HostSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardQuestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardQuestions = append(m.ShardQuestions, &ShardChallengeQuestions{})
			if err := m.ShardQuestions[len(m.ShardQuestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionCount", wireType)
			}
			m.QuestionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuestionCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &ChallengeQuestion{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckFileStoreMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRenterFileInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRenterFileInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRenterFileInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageSize", wireType)
			}
			m.RequestPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageIndex", wireType)
			}
			m.RequestPageIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestTime == nil {
				m.RequestTime = new(time.Time)
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifyTime == nil {
				m.LastModifyTime = new(time.Time)
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(m.LastModifyTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHostContractsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHostContractsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHostContractsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageSize", wireType)
			}
			m.RequestPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageIndex", wireType)
			}
			m.RequestPageIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTimeSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifyTimeSince == nil {
				m.LastModifyTimeSince = new(time.Time)
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(m.LastModifyTimeSince, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTimeTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifyTimeTo == nil {
				m.LastModifyTimeTo = new(time.Time)
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(m.LastModifyTimeTo, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ListHostContractsRequest_SelectState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestTime == nil {
				m.RequestTime = new(time.Time)
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &ListHostContractsRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.GenerateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadyForChallengeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadyForChallengeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadyForChallengeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRepair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRepair = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Question == nil {
				m.Question = &ChallengeQuestion{}
			}
			if err := m.Question.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRepair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRepair = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Answer == nil {
				m.Answer = &ChallengeQuestion{}
			}
			if err := m.Answer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.ResolveTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRepair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRepair = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceRepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceRepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceRepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.ResponseTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LostShardHash = append(m.LostShardHash, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadRewardAmount", wireType)
			}
			m.DownloadRewardAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadRewardAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairRewardAmount", wireType)
			}
			m.RepairRewardAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairRewardAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RepairSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairSignature = append(m.RepairSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RepairSignature == nil {
				m.RepairSignature = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.GuardSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contract == nil {
				m.Contract = &RepairContract{}
			}
			if err := m.Contract.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RepairContractResponse_ContractResponseStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRepairContracts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRepairContracts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRepairContracts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RepairSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairSignature = append(m.RepairSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RepairSignature == nil {
				m.RepairSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseRepairContracts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseRepairContracts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseRepairContracts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ResponseRepairContracts_RepairStat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &FileStoreStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.SignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelContractRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelContractRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelContractRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= CancelContractRequest_CancelReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.SignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodePid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodePid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssuerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageQuestionsCount", wireType)
			}
			m.PackageQuestionsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageQuestionsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.SendTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobFinishDeadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.JobFinishDeadline, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeJobResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeJobResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeJobResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodePid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ShardChallengeResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(&m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardChallengeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardChallengeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardChallengeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTimeout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTimeout = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeCentralQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeCentralQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeCentralQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qs = append(m.Qs, &DeQuestion{})
			if err := m.Qs[len(m.Qs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_bittorrent_protobuf_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkIndex", wireType)
			}
			m.ChunkIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGuard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGuard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGuard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGuard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGuard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGuard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGuard = fmt.Errorf("proto: unexpected end of group")
)
